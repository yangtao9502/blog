<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Netty中粘包/拆包处理</title>
    <url>/2019/12/09/10-netty/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/10.jpg"></p>
<blockquote>
<p>TCP 是基于流传输的协议，请求数据在其传输的过程中是没有界限区分，所以我们在读取请求的时候，不一定能获取到一个完整的数据包。如果一个包较大时，可能会切分成多个包进行多次传输。同时，如果存在多个小包时，可能会将其整合成一个大包进行传输。这就是 TCP 协议的粘包&#x2F;拆包概念。</p>
</blockquote>
<span id="more"></span>

<p><strong>本文基于 Netty5 进行分析</strong></p>
<h1 id="粘包-拆包描述"><a href="#粘包-拆包描述" class="headerlink" title="粘包&#x2F;拆包描述"></a>粘包&#x2F;拆包描述</h1><p>假设当前有<code>123</code>和<code>abc</code>两个数据包，那么他们传输情况示意图如下：</p>
<p><img src="https://images.ytao.top/netty-tcp.png"></p>
<ul>
<li>I 为正常情况，两次传输两个独立完整的包。</li>
<li>II 为粘包情况，<code>123</code>和<code>abc</code>封装成了一个包。</li>
<li>III 为拆包情况，图中的描述是将<code>123</code>拆分成了<code>1</code>和<code>23</code>，并且<code>1</code>和<code>abc</code>一起传输。<code>123</code>和<code>abc</code>也可能是<code>abc</code>进行拆包。甚至<code>123</code>和<code>abc</code>进行多次拆分也有可能。</li>
</ul>
<h1 id="Netty-粘包-拆包问题"><a href="#Netty-粘包-拆包问题" class="headerlink" title="Netty 粘包&#x2F;拆包问题"></a>Netty 粘包&#x2F;拆包问题</h1><p>为突出 Netty 的粘包&#x2F;拆包问题，这里通过例子进行重现问题，以下为突出问题的主要代码：</p>
<p>服务端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端网络事件的读写操作类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Created by YangTao.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 接收消息计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// client端消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        i++;</span><br><span class="line">        </span><br><span class="line">        System.out.print(msg);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对每条读取到的消息进行打数标记</span></span><br><span class="line">        System.out.println(<span class="string">&quot;================== [&quot;</span>+ i +<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="comment">// 发送应答消息给客户端</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">rmsg</span> <span class="operator">=</span> Unpooled.copiedBuffer(String.valueOf(i).getBytes());</span><br><span class="line">        ctx.write(rmsg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他操作 .......</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端发送数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Created by YangTao.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;logger&quot;</span>, <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.connect(HOST, PORT).channel();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= <span class="number">300</span>)&#123;</span><br><span class="line">                channel.writeAndFlush(String.format(<span class="string">&quot;【时间 %s: \t%s】&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), i));</span><br><span class="line">                <span class="comment">// 打印发送请求的次数</span></span><br><span class="line">                System.out.println(i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (group != <span class="literal">null</span>)</span><br><span class="line">                 group.shutdownGracefully();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码中，我们第一反应理解的是，如果非异常情况下客户端所有数据发送成功，并且服务端全部接收到。那么从打印信息中可以看到客户端的发送次数<code>i</code>和服务端的接收消息计数<code>i</code>应该是相同的数。那么下面通过运行程序，查看打印结果。</p>
<p><img src="https://images.ytao.top/netty-e-1.png"></p>
<p>如上图所示，<code>【】</code>中的最后一个数字与<code>[]</code>中数字对上的是已独立完整的包接收到<strong>（粘包&#x2F;拆包示意图中的情况 I）</strong>。但是<code>【】</code>中为<code>37</code>和<code>38</code>的出现了粘包情况<strong>（粘包&#x2F;拆包示意图中的情况 II）</strong>，两条数据粘合在一起。</p>
<p><img src="https://images.ytao.top/netty-e-2.png"></p>
<p>上图中可以看到<code>【】</code>中<code>167</code>的数据被拆分为了两部分（图中画绿线数据），该情况为拆包<strong>（粘包&#x2F;拆包示意图中的情况 III）</strong>。</p>
<p>上面程序没有考虑到 TCP 的粘包&#x2F;拆包问题，所以如果是我们实际应用的程序的话，不能保证数据的正常情况，就会导致程序异常。</p>
<h1 id="Netty-解决粘包-拆包问题"><a href="#Netty-解决粘包-拆包问题" class="headerlink" title="Netty 解决粘包&#x2F;拆包问题"></a>Netty 解决粘包&#x2F;拆包问题</h1><h2 id="LineBasedFrameDecoder-换行符处理"><a href="#LineBasedFrameDecoder-换行符处理" class="headerlink" title="LineBasedFrameDecoder 换行符处理"></a>LineBasedFrameDecoder 换行符处理</h2><p>Netty 的强大，方便，简单使用的优势，在粘包&#x2F;拆包问题上也提供了多种编解码解决方案，并且很容易理解和掌握。<br>这里使用 LineBasedFrameDecoder 和 StringDecoder（将接收到的对象转换成字符串） 来解决粘包&#x2F;拆包问题。<br>只需在服务端和客户端分别添加 LineBasedFrameDecoder 和 StringDecoder解码器，因为是双向会话，所以两端都要添加，由于我一开始就添加 StringDecoder 编码器，所以只需添加 LineBasedFrameDecoder 就够了。<br>服务端：</p>
<p><img src="https://images.ytao.top/netty-decode-s.png"></p>
<p>客户端：</p>
<p><img src="https://images.ytao.top/netty-decode-c.png"></p>
<p>服务端网络事件操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端网络事件的读写操作类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Created by YangTao.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 接收消息计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// client端消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        i++;</span><br><span class="line">        </span><br><span class="line">        System.out.print(msg);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对每条读取到的消息进行打数标记</span></span><br><span class="line">        System.out.println(<span class="string">&quot;================== [&quot;</span>+ i +<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="comment">// 发送应答消息给客户端</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">rmsg</span> <span class="operator">=</span> Unpooled.copiedBuffer(String.valueOf(i + System.getProperty(<span class="string">&quot;line.separator&quot;</span>)).getBytes());</span><br><span class="line">        ctx.write(rmsg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他操作 .......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端发送数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端发送数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Created by YangTao.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 连接操作 .......</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 channel</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channel();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= <span class="number">300</span>)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.format(<span class="string">&quot;【时间 %s: \t%s】&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), i) + System.getProperty(<span class="string">&quot;line.separator&quot;</span>);</span><br><span class="line">                <span class="type">byte</span>[] bytes = str.getBytes();</span><br><span class="line">                <span class="comment">// 写入缓冲区</span></span><br><span class="line">                buf = Unpooled.buffer(bytes.length);</span><br><span class="line">                buf.writeBytes(bytes);</span><br><span class="line">                channel.writeAndFlush(buf);</span><br><span class="line">                <span class="comment">// 打印发送请求的次数</span></span><br><span class="line">                System.out.println(i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 退出操作 .......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>细心观察代码的变化，应该会发现现在的代码每次在发送消息的时候，在消息末尾后加了换行分隔符。<strong>注意，使用 LineBasedFrameDecoder 时，换行分隔符必须加，否则接收消息端收不到消息，如果手写换行分割，要记得区分不同系统的适配</strong>。</p>
<p>经过多次测试 3W 条请求，没有再出现过粘包&#x2F;拆包情况，看最后一条数据数字是否相同便知。</p>
<p><img src="https://images.ytao.top/netty-end-10.png"></p>
<h2 id="DelimiterBasedFrameDecoder-自定义分隔符"><a href="#DelimiterBasedFrameDecoder-自定义分隔符" class="headerlink" title="DelimiterBasedFrameDecoder 自定义分隔符"></a>DelimiterBasedFrameDecoder 自定义分隔符</h2><p>自定义分隔符和换行分隔符差不多，只需将发送的数据后换行符换成你自己设定的分割符即可。</p>
<p>服务端和客户端均在 pipeline 添加 DelimiterBasedFrameDecoder:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定的分隔符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELIMITER</span> <span class="operator">=</span> <span class="string">&quot;$@$&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前数据2048个字节中没有分隔符，就会抛出异常，避免内存溢出。也可以自定义预检查当前读取的数据，自定义这里超过的规则</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> <span class="title class_">DelimiterBasedFrameDecoder</span>(</span><br><span class="line">        <span class="number">2048</span>, </span><br><span class="line">        Unpooled.wrappedBuffer(DELIMITER.getBytes())) <span class="comment">// 分割符缓冲对象</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="FixedLengthFrameDecoder-根据固定长度"><a href="#FixedLengthFrameDecoder-根据固定长度" class="headerlink" title="FixedLengthFrameDecoder 根据固定长度"></a>FixedLengthFrameDecoder 根据固定长度</h2><p>设定固定长度，进行数据传输，如果不达固定长度，使用空格补全。</p>
<p>服务端和客户端均在 pipeline 添加 FixedLengthFrameDecoder:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 100为指定的固定长度</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">100</span>));</span><br></pre></td></tr></table></figure>

<p>每次读取数据时都会按照 FixedLengthFrameDecoder 中设置的固定长度进行解码，如果出现粘包，那么会进行多次解码，如果出现拆包的情况，那么 FixedLengthFrameDecoder 会先缓存当前部分包的信息，当接收下一个包时，会与缓存的部分包进行拼接，知道满足规定的长度。</p>
<h2 id="动态指定长度"><a href="#动态指定长度" class="headerlink" title="动态指定长度"></a>动态指定长度</h2><p>动态指定长度就是说，每条消息的长度都是随着消息头进行指定，这里使用的编码器为 LengthFieldBasedFrameDecoder。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">pipeline().addLast(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(</span><br><span class="line">        <span class="number">2048</span>, <span class="comment">// 帧的最大长度，即每个数据包最大限度</span></span><br><span class="line">        <span class="number">0</span>, <span class="comment">// 长度字段偏移量</span></span><br><span class="line">        <span class="number">4</span>, <span class="comment">// 长度字段所占的字节数</span></span><br><span class="line">        <span class="number">0</span>, <span class="comment">// 消息头的长度，可以为负数</span></span><br><span class="line">        <span class="number">4</span>) <span class="comment">// 需要忽略的字节数，从消息头开始，这里是指整个包</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发送消息时，创建自己的消息对象编码器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建 byteBuf</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> getBuf();</span><br><span class="line"></span><br><span class="line"><span class="comment">// .....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置该条消息内容长度</span></span><br><span class="line">buf.writeInt(msg.length());</span><br><span class="line"><span class="comment">// 设置消息内容</span></span><br><span class="line">buf.writeBytes(msg.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>服务端读取的时候就直接读取即可，没其他特殊操作。</p>
<p>除了以上 Netty 提供的现成方案，还可以通过重写 MessageToByteEncoder 编码实现自定义协议。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>Netty 极大的为使用者提供了多种解决粘包&#x2F;拆包方案，并且可以很愉快的对多种消息进行自动解码，在使用过程中也极容易掌握和理解，很大程度上提升开发效率和稳定性。</p>
</blockquote>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch之安装及基本操作API</title>
    <url>/2019/12/14/11-elasticsearch/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/elasticsearch.png"></p>
<blockquote>
<p>ElasticSearch 是目前非常流行的搜索引擎，对海量数据搜索是非常友好，并且在高并发场景下，也能发挥出稳定，快速特点。也是大数据和索搜服务的开发人员所极力追捧的中间件。虽然 ElasticSearch 深受大家的喜爱，但是它的迭代速度之快，所以在相关社区老是有听说到学不动了的话语，也正是这种不断完善，才能拥有现在的社区活跃。我使用 ElasticSearch 时，从 5.x 到  6.x 版本，再到现在接触到 7.x 版本。从版本升级中，也看到了 ElasticSearch 对主流技术变化的拥抱，最明显的是新版 JDK 版本的支持及容器技术的支持。</p>
</blockquote>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><strong>本文基于目前最新版本<code>ElasticSearch-7.5.0</code>进行操作，如官网下载太慢，可在【ytao公众号】中发送<code>es</code>获取下载链接。</strong></p>
<span id="more"></span>

<p>安装环境及本文相关包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">操作系统	CentOS 7.5 64位</span><br><span class="line">ElasticSearch 7.5.0</span><br><span class="line">Kinbana 7.5.0</span><br></pre></td></tr></table></figure>

<h2 id="JDK-环境"><a href="#JDK-环境" class="headerlink" title="JDK 环境"></a>JDK 环境</h2><p>ElasticSearch 在 7.x 中自带 JDK 环境，所以现在不一定要安装 JDK。默认是先判断当前服务器是否安装 JDK，如果安装了就使用服务器已安装的 JDK，否则会使用自带的 JDK，当然这个也是可以手动设置。</p>
<h2 id="创建启动账号"><a href="#创建启动账号" class="headerlink" title="创建启动账号"></a>创建启动账号</h2><p>由于 ElasticSearch 默认是不支持 root 账号权限启动，所以第一步要先创建启动账号。<br>创建一个 ElasticSearch 的运行组 es:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd es</span><br></pre></td></tr></table></figure>

<p>在 es 组中创建用户：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd elastic -g es </span><br></pre></td></tr></table></figure>

<p>设置新用户密码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd elastic</span><br></pre></td></tr></table></figure>

<p>给解压出的 ElasticSearch 包授权：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chown</span> -R elastic:es elasticsearch-7.5.0</span><br></pre></td></tr></table></figure>

<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>进入到<code>/elasticsearch-7.5.0</code>目录，在<code>config</code>目录里有个<code>elasticsearch.yml</code>文件，修改里面当前需要的配置。</p>
<ul>
<li>cluster.name 是所属集群的名称</li>
<li>node.name 当前节点名称</li>
<li>network.host 当前节点所绑定地址，绑定到<code>0.0.0.0</code>所有的访问</li>
<li>http.port 对外提供服务的端口号</li>
<li>path.data 数据存储目录，这个我一般不适用默认目录，但是要给自定义的目录授权</li>
<li>path.log 日志目录，和 path.data 类似配置</li>
</ul>
<p>另外一个重要的配置，在当前目录中的<code>jvm.options</code>文件设置。<br>这里设置堆内存大小，建议设置机器内存的 50% 大小。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Xms4g</span><br><span class="line">-Xmx4g</span><br></pre></td></tr></table></figure>

<p>其他配置暂时没用到，暂不分析，今后的文章中用到再进行讲解。</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>安装配置文件设置的值默认启动，直接执行<code>./bin/elasticsearch</code>，果然不出乎所意料，启动异常。</p>
<p><img src="https://images.ytao.top/elasticsearch-start-error.png"></p>
<p>上图中抛了两个异常。</p>
<ul>
<li>第一个是说虚拟内存太小，至少需要 262144。</li>
<li>第二个当前默认配置不适合，[discovery.seed_hosts, discovery.seed_providers, cluster.initial_master_nodes]配置中至少有一个配置。</li>
</ul>
<p>现在就增大服务器虚拟内存：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 编辑 sysctl.conf 文件</span><br><span class="line">vim /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line"># 在 sysctl.conf 中添加</span><br><span class="line">vm.max_map_count=262144</span><br><span class="line"></span><br><span class="line"># 查看刚设置的是否生效</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<p>设置 cluster.initial_master_nodes 配置参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cluster.initial_master_nodes: [<span class="string">&quot;node-1&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>再次启动完成后，没有异常抛出，访问<code>ip:9200</code>，返回数据信息，其中包括集群名称，节点名，版本信息等等：</p>
<p><img src="https://images.ytao.top/elasticsearch-start-success.png"></p>
<h1 id="基本操作API"><a href="#基本操作API" class="headerlink" title="基本操作API"></a>基本操作API</h1><p>在进行 API 操作前先安装 kibana，以下命令执行将全部在 kibana 中执行。解压 kibana 后，在<code>kibana.yml</code>中设置 ElasticSearch 地址<code>elasticsearch.hosts: [&quot;http://ip:9200&quot;]</code>。通过<code>bin/kibana</code>进行启动。安装比较简单，这里不做详细阐述。</p>
<h2 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>创建 person 索引例子，number_of_shards 为分片数量，number_of_replicas 为索引的副本数，这里主要演示创建索引时可设置一些相关参数，且为非必填项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT /person</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span> : &#123; </span><br><span class="line">   <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">     <span class="string">&quot;name&quot;</span> : &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="string">&quot;fields&quot;</span> : &#123;</span><br><span class="line">          <span class="string">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ignore_above&quot;</span> : 256  // 长度超过ignore_above设定的值，不会被索引或存储</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;number_of_shards&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;number_of_replicas&quot;</span>: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行命令结果：</p>
<p><img src="https://images.ytao.top/elasticsearch-put-index.png"></p>
<h3 id="查询索引"><a href="#查询索引" class="headerlink" title="查询索引"></a>查询索引</h3><p>使用 GET 请求方式查询索引信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /person</span><br></pre></td></tr></table></figure>

<p>返回结果</p>
<p><img src="https://images.ytao.top/elasticsearch-get-index.png"></p>
<h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>使用 DELETE 请求方式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除 person 索引</span></span><br><span class="line">DELETE /person</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除全部索引</span></span><br><span class="line">DELETE /_all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通配符删除</span></span><br><span class="line">DELETE /person*</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="mapping-操作"><a href="#mapping-操作" class="headerlink" title="mapping 操作"></a>mapping 操作</h2><p>查询 person 索引的 mapping ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /person/_mapping</span><br></pre></td></tr></table></figure>

<p>向 person 索引中添加 remark 字段，之前 mapping 中的 name 不会被删除，。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /person/_mapping</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;properties&quot;</span> : &#123;</span><br><span class="line">      <span class="string">&quot;remark2&quot;</span> : &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="string">&quot;fields&quot;</span> : &#123;</span><br><span class="line">        <span class="string">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="string">&quot;ignore_above&quot;</span> : 256</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h2><h3 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h3><p>添加文档有两种方式，第一种就是使用指定索引的 type 添加文档，7.x开始，type 指定只能是 _doc 值，同时也是不支持多 type 的（ps：之前使用type主要用来将索引逻辑分区）。第二种就是使用 _create 进行创建数据。</p>
<h4 id="index-方式添加文档"><a href="#index-方式添加文档" class="headerlink" title="index 方式添加文档"></a>index 方式添加文档</h4><p>使用<code>_doc</code> API向 person 中添加文档：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT /person/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>:<span class="string">&quot;ytao&quot;</span>,</span><br><span class="line">  <span class="string">&quot;blog&quot;</span>:<span class="string">&quot;公众号 ytao&quot;</span>,</span><br><span class="line">  <span class="string">&quot;remark&quot;</span>:<span class="string">&quot;https://ytao.top&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加文档后返回的数据：</p>
<p><img src="https://images.ytao.top/elasticsearch-put-doc.png"></p>
<p>上面命令执行过程，如果索引或 mapping 不存在，都会自动创建。这里的 id 我们也可以自动生成，但是请求不能使用 PUT 方式，要改为 POST 方式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /person/_doc/</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>:<span class="string">&quot;ytao&quot;</span>,</span><br><span class="line">  <span class="string">&quot;blog&quot;</span>:<span class="string">&quot;公众号 ytao&quot;</span>,</span><br><span class="line">  <span class="string">&quot;remark&quot;</span>:<span class="string">&quot;https://ytao.top&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果上面我们插入 id 为 1 的文档重复执行，那么会先删除掉旧的文档，再引用新的文档，并且所对应的<code>_version</code>版本号值会较之前的 +1。</p>
<h4 id="create-方式添加文档"><a href="#create-方式添加文档" class="headerlink" title="create 方式添加文档"></a>create 方式添加文档</h4><p>使用<code>_create</code> API向 person 添加文档：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT /person/_create/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>:<span class="string">&quot;yangtao&quot;</span>,</span><br><span class="line">  <span class="string">&quot;blog&quot;</span>:<span class="string">&quot;ytao&#x27;s blog&quot;</span>,</span><br><span class="line">  <span class="string">&quot;remark&quot;</span>:<span class="string">&quot;coder&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里 id 必须指明，否则添加失败，并且文档中已存在的 id 不能进行添加。</p>
<h3 id="获取和查询文档"><a href="#获取和查询文档" class="headerlink" title="获取和查询文档"></a>获取和查询文档</h3><h4 id="根据-id-获取文档"><a href="#根据-id-获取文档" class="headerlink" title="根据 id 获取文档"></a>根据 id 获取文档</h4><p>使用 GET 获取文档：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /person/_doc/1</span><br></pre></td></tr></table></figure>

<p>返回数据中：</p>
<p><img src="https://images.ytao.top/elasticsearch-get.png"></p>
<h4 id="根据字段进行查询"><a href="#根据字段进行查询" class="headerlink" title="根据字段进行查询"></a>根据字段进行查询</h4><p>使用<code>_search</code> API进行查询，这里暂时不做深入讲解。<br>查询 name 为 ytao 的文档，并且通过<code>from=0&amp;size=2</code>分页查询。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># q 为查询参数，查询的字段和值用 : 进行分割</span></span><br><span class="line">GET /person/_search?q=name:ytao&amp;from=0&amp;size=2</span><br></pre></td></tr></table></figure>

<p>返回结果：</p>
<p><img src="https://images.ytao.top/elasticsearch-simple-search.png"></p>
<h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><p>更新文档使用 <code>_update</code> API进行更新。<strong>更新内容必须包含在<code>doc</code>中</strong>。更新对源数据只能是添加或修改字段，这也是和使用<code>_doc</code>添加数据的区别，不是通过删除旧的文档进行更新的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST /person/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;doc&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;blog&quot;</span>:<span class="string">&quot;ytao&#x27;s blog&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><p>文档删除使用 DELETE 请求，然后指定 id：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DELETE /person/_doc/1</span><br></pre></td></tr></table></figure>

<h3 id="批量操作文档"><a href="#批量操作文档" class="headerlink" title="批量操作文档"></a>批量操作文档</h3><p>批量处理可以一次请求中处理多个任务，使用<code>_bulk</code> API进行。<br>下面就以索引添加方式添加一个文档到索引中，然后更新文档中 blog 字段为例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST _bulk</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;person&quot;, &quot;_id&quot;:1&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;ytao&quot;,&quot;blog&quot;:&quot;公众号 ytao&quot;,&quot;remark&quot;:&quot;https://ytao.top&quot;&#125;</span><br><span class="line">&#123;&quot;update&quot;:&#123;&quot;_index&quot;:&quot;person&quot;, &quot;_id&quot;:1&#125;&#125;</span><br><span class="line">&#123;&quot;doc&quot;:&#123;&quot;blog&quot;:&quot;ytao&#x27;s blog&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>返回结果中，按每一个操作分别返回结果信息，当其中有请求错误时，不会影响其他请求操作。</p>
<p><img src="https://images.ytao.top/elasticsearch-bulk.png"></p>
<h3 id="批量获取文档"><a href="#批量获取文档" class="headerlink" title="批量获取文档"></a>批量获取文档</h3><p>批量获取文档，使用<code>_mget</code> API进行，通过一次指定多个文档 id，进行请求。<br>例如在 person 索引中获取 id 为 1,2 的文档：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">POST _mget</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;docs&quot;</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;person&quot;</span>,</span><br><span class="line">      <span class="string">&quot;_id&quot;</span>: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;person&quot;</span>,</span><br><span class="line">      <span class="string">&quot;_id&quot;</span>: 2</span><br><span class="line">    &#125; </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回结果：</p>
<p><img src="https://images.ytao.top/elasticsearch-mget.png"></p>
<h3 id="批量查询文档"><a href="#批量查询文档" class="headerlink" title="批量查询文档"></a>批量查询文档</h3><p>批量查询文档，使用<code>_msearch</code> API进行，将多个查询整合到一个请求中。<br>下面就是分别在指定索引中查询的不同条件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /person/_msearch</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:<span class="string">&quot;person&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;query&quot;</span>:&#123;<span class="string">&quot;match&quot;</span>:&#123;<span class="string">&quot;blog&quot;</span>:<span class="string">&quot;ytao&#x27;s blog&quot;</span>&#125;&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:<span class="string">&quot;person&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;query&quot;</span>:&#123;<span class="string">&quot;match&quot;</span>:&#123;<span class="string">&quot;remark&quot;</span>:<span class="string">&quot;coder&quot;</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>返回结果：</p>
<p><img src="https://images.ytao.top/elasticsearch-simple-msearch.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>本文对 ElasticSearch 的最基础的，常用的操作 API，这里已经介绍完毕。要想学习 ElasticSearch，建议从 API 操作入手，千万别上来就直接拿着代码就干，虽然各语言都已提供相关工具包，但是这些封装也都是基于 API 上的。更多的 API 在今后文章涉及时再进行分析。</p>
</blockquote>
<p>更多 API 相关信息，建议查阅官网，这里有比较详细的介绍：<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.5/rest-apis.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.5/rest-apis.html</a> </p>
]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty之缓冲区ByteBuf解读（一）</title>
    <url>/2019/12/23/12-netty-buf/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/luffy-s.jpg"></p>
<blockquote>
<p>Netty 在数据传输过程中，会使用缓冲区设计来提高传输效率。虽然，Java 在 NIO 编程中已提供 ByteBuffer 类进行使用，但是在使用过程中，其编码方式相对来说不太友好，也存在一定的不足。所以高性能的 Netty 框架实现了一套更加强大，完善的 ByteBuf，其设计理念也是堪称一绝。</p>
</blockquote>
<span id="more"></span>

<h1 id="ByteBuffer-分析"><a href="#ByteBuffer-分析" class="headerlink" title="ByteBuffer 分析"></a>ByteBuffer 分析</h1><p>在分析 ByteBuf 之前，先简单讲下 ByteBuffer 类的操作。便于更好理解 ByteBuf 。</p>
<p>ByteBuffer 的读写操作共用一个位置指针，读写过程通过以下代码案例分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配一个缓冲区，并指定大小</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 设置当前最大缓存区大小限制</span></span><br><span class="line">buffer.limit(<span class="number">15</span>);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;allocate: pos=%s lim=%s cap=%s&quot;</span>, buffer.position(), buffer.limit(), buffer.capacity()));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;ytao公众号&quot;</span>;</span><br><span class="line"><span class="comment">// 向缓冲区写入数据</span></span><br><span class="line">buffer.put(content.getBytes());</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;put: pos=%s lim=%s cap=%s&quot;</span>, buffer.position(), buffer.limit(), buffer.capacity()));</span><br></pre></td></tr></table></figure>

<p>其中打印了缓冲区三个参数，分别是：</p>
<ul>
<li>position 读写指针位置</li>
<li>limit 当前缓存区大小限制</li>
<li>capacity 缓冲区大小</li>
</ul>
<p>打印结果：</p>
<p><img src="https://images.ytao.top/buf-buffer-put.png"></p>
<p>当我们写入内容后，读写指针值为 13，<code>ytao公众号</code>英文字符占 1 个 byte，每个中文占 4 个 byte，刚好 13，小于设置的当前缓冲区大小 15。</p>
<p>接下来，读取内容里的 ytao 数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.flip();</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;flip: pos=%s lim=%s cap=%s&quot;</span>, buffer.position(), buffer.limit(), buffer.capacity()));</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] readBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">buffer.get(readBytes);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;get(4): pos=%s lim=%s cap=%s&quot;</span>, buffer.position(), buffer.limit(), buffer.capacity()));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">readContent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(readBytes);</span><br><span class="line">System.out.println(<span class="string">&quot;readContent:&quot;</span>+readContent);</span><br></pre></td></tr></table></figure>

<p>读取内容需要创建个 byte 数组来接收，并制定接收的数据大小。</p>
<p>在写入数据后再读取内容，必须主动调用<code>ByteBuffer#flip</code>或<code>ByteBuffer#clear</code>。</p>
<p><code>ByteBuffer#flip</code>它会将写入数据后的指针位置值作为当前缓冲区大小，再将指针位置归零。会使写入数据的缓冲区改为待取数据的缓冲区，也就是说，读取数据会从刚写入的数据第一个索引作为读取数据的起始索引。</p>
<p><code>ByteBuffer#flip</code>相关源码：</p>
<p><img src="https://images.ytao.top/buf-buffer-flip.png"></p>
<p><code>ByteBuffer#clear</code>则会重置 limit 为默认值，与 capacity 大小相同。</p>
<p><img src="https://images.ytao.top/buf-buffer-clear.png"></p>
<p>接下读取剩余部分内容：</p>
<p>第二次读取的时候，可使用<code>buffer#remaining</code>来获取大于或等于剩下的内容的字节大小，该函数实现为<code>limit - position</code>，所以当前缓冲区域一定在这个值范围内。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">readBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.remaining()];</span><br><span class="line">buffer.get(readBytes);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;get(remaining): pos=%s lim=%s cap=%s&quot;</span>, buffer.position(), buffer.limit(), buffer.capacity()));</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="https://images.ytao.top/buf-buffer-get-remaining.png"></p>
<p>以上操作过程中，索引变化如图：</p>
<p><img src="https://images.ytao.top/buf-buffer-idx-change.png"></p>
<h1 id="ByteBuf-读写操作"><a href="#ByteBuf-读写操作" class="headerlink" title="ByteBuf 读写操作"></a>ByteBuf 读写操作</h1><p>ByteBuf 有读写指针是分开的，分别是<code>buf#readerIndex</code>和<code>buf#writerIndex</code>，当前缓冲器大小<code>buf#capacity</code>。</p>
<p>这里缓冲区被两个指针索引和容量划分为三个区域：</p>
<ul>
<li>0 -&gt; readerIndex 为已读缓冲区域，已读区域可重用节约内存，readerIndex 值大于或等于 0</li>
<li>readerIndex -&gt; writerIndex 为可读缓冲区域，writerIndex 值大于或等于 readerIndex</li>
<li>writerIndex -&gt; capacity 为可写缓冲区域，capacity 值大于或等于 writerIndex</li>
</ul>
<p>如下图所示：</p>
<p><img src="https://images.ytao.top/buf-area.png"></p>
<h2 id="分配缓冲区"><a href="#分配缓冲区" class="headerlink" title="分配缓冲区"></a>分配缓冲区</h2><p>ByteBuf 分配一个缓冲区，仅仅给定一个初始值就可以。默认是 256。初始值不像 ByteBuffer 一样是最大值，ByteBuf 的最大值是<code>Integer.MAX_VALUE</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.buffer(<span class="number">13</span>);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;init: ridx=%s widx=%s cap=%s&quot;</span>, buf.readerIndex(), buf.writerIndex(), buf.capacity()));</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="https://images.ytao.top/buf-init.png"></p>
<h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><p>ByteBuf 写操作和 ByteBuffer 类似，只是写指针是单独记录的，ByteBuf 的写操作支持多种类型，有以下多个API：</p>
<p><img src="https://images.ytao.top/buf-write-type.png"></p>
<p>写入字节数组类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;ytao公众号&quot;</span>;</span><br><span class="line">buf.writeBytes(content.getBytes());</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;write: ridx=%s widx=%s cap=%s&quot;</span>, buf.readerIndex(), buf.writerIndex(), buf.capacity()));</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="https://images.ytao.top/buf-write-console.png"></p>
<p>索引示意图：</p>
<p><img src="https://images.ytao.top/buf-write-idx.png"></p>
<h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p>一样的，ByteBuf 写操作和 ByteBuffer 类似，只是写指针是单独记录的，ByteBuf 的读操作支持多种类型，有以下多个API：</p>
<p><img src="https://images.ytao.top/buf-read-type.png"></p>
<p>从当前 readerIndex 位置读取四个字节内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span>[] dst = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">buf.readBytes(dst);</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(dst));</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;read(4): ridx=%s widx=%s cap=%s&quot;</span>, buf.readerIndex(), buf.writerIndex(), buf.capacity()));</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<p><img src="https://images.ytao.top/buf-read-console.png"></p>
<p>索引示意图：</p>
<p><img src="https://images.ytao.top/buf-read-idx.png"></p>
<h1 id="ByteBuf-动态扩容"><a href="#ByteBuf-动态扩容" class="headerlink" title="ByteBuf 动态扩容"></a>ByteBuf 动态扩容</h1><p>通过上面的 ByteBuffer 分配缓冲区例子，向里面添加 [ytao公众号ytao公众号] 内容，使写入的内容大于 limit 的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">buffer.limit(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;ytao公众号ytao公众号&quot;</span>;</span><br><span class="line">buffer.put(content.getBytes());</span><br></pre></td></tr></table></figure>

<p>运行结果异常：</p>
<p><img src="https://images.ytao.top/buf-buffer-overflow.png"></p>
<p>内容字节大小超过了 limit 的值时，缓冲区溢出异常，所以我们每次写入数据前，得检查缓区大小是否有足够空间，这样对编码上来说，不是一个好的体验。</p>
<p>使用 ByteBuf 添加同样的内容，给定同样的初始容器大小。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.buffer(<span class="number">15</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;ytao公众号ytao公众号&quot;</span>;</span><br><span class="line">buf.writeBytes(content.getBytes());</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;write: ridx=%s widx=%s cap=%s&quot;</span>, buf.readerIndex(), buf.writerIndex(), buf.capacity()));</span><br></pre></td></tr></table></figure>

<p>打印运行结果:</p>
<p><img src="https://images.ytao.top/buf-write-over-console.png"></p>
<p>通过上面打印信息，可以看到 cap 从设置的 15 变为了 64，当我们容器大小不够时，就是进行扩容，接下来我们分析扩容过程中是如何做的。<br>进入 writeBytes 里面：</p>
<p><img src="https://images.ytao.top/buf-over-code1.png"></p>
<p>校验写入内容长度：</p>
<p><img src="https://images.ytao.top/buf-over-code2.png"></p>
<p>在可写区域检查里：</p>
<ul>
<li>如果写入内容为空，抛出非法参数异常。</li>
<li>如果写入内容大小小于或等于可写区域大小，则返回当前缓冲区，当中的<code>writableBytes()</code>函数为可写区域大小<code>capacity - writerIndex</code></li>
<li>如果写入内容大小大于最大可写区域大小，则抛出索引越界异常。</li>
<li>最后剩下条件的就是写入内容大小大于可写区域，小于最大区域大小，则分配一个新的缓冲区域。</li>
</ul>
<p><img src="https://images.ytao.top/buf-over-code3.png"></p>
<p>在容量不足，重新分配缓冲区的里面，以 4M 为阀门：</p>
<ul>
<li>如果待写内容刚好为 4M, 那么就分配 4M 的缓冲区。</li>
<li>如果待写内容超过这个阀门且与阀门值之和不大于最大容量值，就分配(阀门值+内容大小值)的缓冲区；如果超过这个阀门且与阀门值之和大于最大容量值，则分配最大容量的缓冲区。</li>
<li>如果待写内容不超过阀门值且大于 64，那么待分配缓冲区大小就以 64 的大小进行倍增，直到相等或大于待写内容。</li>
<li>如果待写内容不超过阀门值且不大于 64，则返回待分配缓冲区大小为 64。</li>
</ul>
<p><img src="https://images.ytao.top/buf-over-code4.png"></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote>
<p>Netty 实现的缓冲区，八个基本类型中，除了布尔类型，其他7种都有自己对应的 Buffer，但是实际使用过程中， ByteBuf 才是我们尝试用的，它可兼容任何类型。ByteBuf 在 Netty 体系中是最基础也是最重要的一员，要想更好掌握和使用 Netty，先理解并掌握 ByteBuf 是必需条件之一。 </p>
</blockquote>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty之缓冲区ByteBuf解读（二）</title>
    <url>/2019/12/31/13-netty-buf/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/banner-13.jpg"></p>
<blockquote>
<p>上篇介绍了 ByteBuf 的简单读写操作以及读写指针的基本介绍，本文继续对 ByteBuf 的基本操作进行解读。</p>
</blockquote>
<h1 id="读写指针回滚"><a href="#读写指针回滚" class="headerlink" title="读写指针回滚"></a>读写指针回滚</h1><p>这里的 demo 例子还是使用上节使用的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.buffer(<span class="number">15</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;ytao公众号&quot;</span>;</span><br><span class="line">buf.writeBytes(content.getBytes());</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;\nwrite: ridx=%s widx=%s cap=%s&quot;</span>, buf.readerIndex(), buf.writerIndex(), buf.capacity()));</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] dst = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">buf.readBytes(dst);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;\nread(4): ridx=%s widx=%s cap=%s&quot;</span>, buf.readerIndex(), buf.writerIndex(), buf.capacity()));</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>进入 readBytes 方法，可以看到每次读取的时候，指针是累加的，如图：</p>
<p><img src="https://images.ytao.top/bytebuf-readbytes.png"></p>
<p>但是，有时我们可能需要对当前操作进行回滚，让指针回到之前的位置。这时，mark 和 reset 搭配使用，可以实现该操作需求。<br>mark 用来记录可能需要回滚的当前位置，reset 是将指针回滚至 mark 记录的值。<br>比如，接着面的 demo，再读取三个字节，然后回滚读取三个字节的操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buf.markReaderIndex();</span><br><span class="line">dst = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">3</span>];</span><br><span class="line">buf.readBytes(dst);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;\nmarkRead and read(3): ridx=%s widx=%s cap=%s&quot;</span>, buf.readerIndex(), buf.writerIndex(), buf.capacity()));</span><br><span class="line"></span><br><span class="line">buf.resetReaderIndex();</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;\nresetReaderIndex: ridx=%s widx=%s cap=%s&quot;</span>, buf.readerIndex(), buf.writerIndex(), buf.capacity()));</span><br></pre></td></tr></table></figure>

<p>先将读索引进行 mark，然后读取内容，在调用读取的 reset，指针索引如下：</p>
<p><img src="https://images.ytao.top/bytebuf-mark-reset-read.png"></p>
<p>读指针累加到 7 后，又重新回滚至 4 的位置。</p>
<p>同样，写指针也是如此操作进行回滚。所以 mark 和 reset 都有一个读和写。</p>
<p><img src="https://images.ytao.top/bytebuf-mark-method.png"></p>
<p>以及</p>
<p><img src="https://images.ytao.top/bytebuf-reset-method.png"></p>
<h1 id="读写指针清空"><a href="#读写指针清空" class="headerlink" title="读写指针清空"></a>读写指针清空</h1><p>将读写指针清为初始值，使用 clear() 函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.buffer(<span class="number">15</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;ytao公众号&quot;</span>;</span><br><span class="line">buf.writeBytes(content.getBytes());</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;\nwrite: ridx=%s widx=%s cap=%s&quot;</span>, buf.readerIndex(), buf.writerIndex(), buf.capacity()));</span><br><span class="line">buf.markWriterIndex();</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] dst = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">buf.readBytes(dst);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;\nread(4): ridx=%s widx=%s cap=%s&quot;</span>, buf.readerIndex(), buf.writerIndex(), buf.capacity()));</span><br><span class="line">buf.markReaderIndex();</span><br><span class="line"></span><br><span class="line">buf.clear();</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;\nclear: ridx=%s widx=%s cap=%s&quot;</span>, buf.readerIndex(), buf.writerIndex(), buf.capacity()));</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://images.ytao.top/bytebuf-clear.png"></p>
<p>clear 只会将指针的位置重置为初始值，并不会清空缓冲区里的内容，如下图。同时，也可使用 mark 和 reset 进行验证，这里不再进行演示。</p>
<p><img src="https://images.ytao.top/bytebuf-clear-method.png"></p>
<h1 id="查找字符位置"><a href="#查找字符位置" class="headerlink" title="查找字符位置"></a>查找字符位置</h1><p>查找字符是在很多场景下，都会使用到，比如前面文章讲过的粘包&#x2F;拆包处理，就有根据字符串进行划分包数据。其实现原理就是根据查找指定字符进行读取。<br>ByteBuf 也提供多种不同的查找方法进行处理：</p>
<h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><p>indexOf 函数，拥有三个参数，查找开始位置索引 <code>fromIndex</code>， 查询位置最大的索引 <code>toIndex</code>，查找字节 <code>value</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fromIndex 为 0， toIndex 为 13， value 为 a</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> buf.indexOf(<span class="number">0</span>, <span class="number">13</span>, (<span class="type">byte</span>)<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;[a]索引位置：&quot;</span>+i);</span><br></pre></td></tr></table></figure>

<p>在索引 0~13 中返回查找的字符 a 索引位置：</p>
<p><img src="https://images.ytao.top/bytebuf-search-indexOf.png"></p>
<p>indexOf 源码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ByteBuf 实现类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex, <span class="type">byte</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ByteBufUtil.indexOf(<span class="built_in">this</span>, fromIndex, toIndex, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ByteBufUtil 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(ByteBuf buffer, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex, <span class="type">byte</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断查询起始和终点索引大小</span></span><br><span class="line">    <span class="keyword">if</span> (fromIndex &lt;= toIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> firstIndexOf(buffer, fromIndex, toIndex, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastIndexOf(buffer, fromIndex, toIndex, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">firstIndexOf</span><span class="params">(ByteBuf buffer, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex, <span class="type">byte</span> value)</span> &#123;</span><br><span class="line">    fromIndex = Math.max(fromIndex, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &gt;= toIndex || buffer.capacity() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从起始索引进行遍历到终点索引，如果这区间有查找的字节，就返回第一个字节的位置，否则返回 -1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> fromIndex; i &lt; toIndex; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer.getByte(i) == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(ByteBuf buffer, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex, <span class="type">byte</span> value)</span> &#123;</span><br><span class="line">    fromIndex = Math.min(fromIndex, buffer.capacity());</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span> || buffer.capacity() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  从起始索引进行遍历到终点索引倒着遍历，获取的是查找区间的最后一个字节位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> fromIndex - <span class="number">1</span>; i &gt;= toIndex; i --) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer.getByte(i) == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="bytesBefore"><a href="#bytesBefore" class="headerlink" title="bytesBefore"></a>bytesBefore</h2><p>bytesBefore 函数拥有三个重载方法：</p>
<p><img src="https://images.ytao.top/bytebuf-bytesBefore-list.png"></p>
<p>bytesBefore 函数的实现，就是在 indexOf 上进行一层查找区间的封装，最后都是在 indexOf 中实现查找。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bytesBefore</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> length, <span class="type">byte</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">// 最终都进入 indexOf 中查找</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> indexOf(index, index + length, value);</span><br><span class="line">    <span class="keyword">if</span> (endIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回相对查找起始索引的位置</span></span><br><span class="line">    <span class="keyword">return</span> endIndex - index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>这里返回的是相对查找起始索引的位置。</p>
<h2 id="forEachByte"><a href="#forEachByte" class="headerlink" title="forEachByte"></a>forEachByte</h2><p>forEachByte 函数有两个重载方法：</p>
<p><img src="https://images.ytao.top/bytebuf-forEachByte-list.png"></p>
<p>这里涉及到一个 ByteBufProcessor 接口，这个是对一些常用的字节，其中包括 空，空白键，换行等等进行了抽象定义。<br>forEachByte 函数实现主要逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">forEachByteAsc0</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> length, ByteBufProcessor processor)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (processor == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;processor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> index + length;</span><br><span class="line"><span class="comment">// 起始 -&gt; 终点索引，进行遍历</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 如果可以匹配上字节，返回该索引位置</span></span><br><span class="line">        <span class="keyword">if</span> (processor.process(_getByte(i))) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; endIndex);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    PlatformDependent.throwException(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找区间遍历完没有匹配上，返回 -1</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="forEachByteDesc"><a href="#forEachByteDesc" class="headerlink" title="forEachByteDesc"></a>forEachByteDesc</h2><p>forEachByteDesc 也是有两个重载方法：</p>
<p><img src="https://images.ytao.top/bytebuf-forEachByteDesc-list.png"></p>
<p>forEachByteDesc 从函数名字可以看出，指的倒序查找。意指从查找区间最大索引到最小索引进行遍历：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">forEachByteDesc0</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> length, ByteBufProcessor processor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (processor == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;processor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从最大索引开始，进行遍历</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index + length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (processor.process(_getByte(i))) &#123;</span><br><span class="line">                i --;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 直到 i 小于查找区间最小索引值时，遍历完成</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (i &gt;= index);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        PlatformDependent.throwException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有找到指定字节返回 -1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查找操作的具体实现还是比较好理解，进入代码查看实现一般都能读懂。</p>
<h1 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h1><p>ByteBuf 复制后会生成一个新的 ByteBuf 对象。<br><strong>copy()</strong> 整个对象被复制，其所有数据都是该对象自身维护，与旧对象无任何关联关系。包括缓冲区内容，但是该方法的的容量默认为旧 buf 的可读区间大小，读索引为 0，写索引为旧数据写索引的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> buf.copy();</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;\ncopy: ridx=%s widx=%s cap=%s&quot;</span>, buf2.readerIndex(), buf2.writerIndex(), buf2.capacity()));</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://images.ytao.top/bytebuf-copy-1.png"></p>
<p><strong>copy(int index, int length)</strong> 为指定复制的起始位置及长度，其他与上面 copy() 类似。<br><strong>duplicate()</strong> 这个也是复制，但是与 copy 函数不同的是，复制后生成的 ByteBuf 和旧的 ByteBuf 是共享一份缓冲区内容的。它复制的只是自己可以单独维护的一份索引。并且它复制的默认容量也是和旧的一样。</p>
<h1 id="对象引用-回收"><a href="#对象引用-回收" class="headerlink" title="对象引用&#x2F;回收"></a>对象引用&#x2F;回收</h1><p>ByteBuf 对象被引用后，可以调用 <strong>retain()</strong> 函数进行累计计数。每调用一次 retain() 则会 +1。<br>其在 AbstractReferenceCountedByteBuf 实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ByteBuf <span class="title function_">retain</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">refCnt</span> <span class="operator">=</span> <span class="built_in">this</span>.refCnt;</span><br><span class="line">        <span class="keyword">if</span> (refCnt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalReferenceCountException</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 达到最大值时，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (refCnt == Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalReferenceCountException</span>(Integer.MAX_VALUE, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保证线程安全，这里 CAS 进行累加</span></span><br><span class="line">        <span class="keyword">if</span> (refCntUpdater.compareAndSet(<span class="built_in">this</span>, refCnt, refCnt + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(T obj, <span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="comment">// unsafe 为jdk的 Unsafe 类</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(obj, offset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，可以进行添加多个引用，自己指定数量，<strong>retain(int increment)</strong> 带参函数实现，和上面 +1 实现思路一样，代码就不贴出来了。</p>
<p>ByteBuf 在申请内存使用完后，需要对其进行释放，否则可能会造成资源浪费及内存泄漏的风险。这也是 ByteBuf 自己实现的一套有效回收机制。<br>释放的函数为 **release()**，它的实现就是每次 -1。直到为 1 时，调用释放函数 <strong>deallocate()</strong> 进行释放。<br>其在 AbstractReferenceCountedByteBuf 实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">refCnt</span> <span class="operator">=</span> <span class="built_in">this</span>.refCnt;</span><br><span class="line">        <span class="keyword">if</span> (refCnt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalReferenceCountException</span>(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 引用数量 -1</span></span><br><span class="line">        <span class="keyword">if</span> (refCntUpdater.compareAndSet(<span class="built_in">this</span>, refCnt, refCnt - <span class="number">1</span>)) &#123;</span><br><span class="line">            当引用数量为 <span class="number">1</span> 时，符合释放条件</span><br><span class="line">            <span class="keyword">if</span> (refCnt == <span class="number">1</span>) &#123;</span><br><span class="line">                deallocate();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，释放也支持一次释放多个引用数量，也是通过指定数量，传递给 <strong>release(int decrement)</strong> 进行引用数量的减少并释放对象。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>本文对 ByteBuf 中最基本，最常用 API 进行的解读，这也是在实际开发中或阅读相关代码时，可能会遇到的基本 API，通过两篇文章的说明，相信对 ByteBuf 的基本使用不会存在太大问题，还有些未分析到的 API，根据自己对 ByteBuf 已有的理解，差不多也能进行分析。</p>
</blockquote>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis5新特性Streams作消息队列</title>
    <url>/2020/01/06/14-redis-streams/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/banner-14.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>Redis 5 新特性中，Streams 数据结构的引入，可以说它是在本次迭代中最大特性。它使本次 5.x 版本迭代中，Redis 作为消息队列使用时，得到更完善，更强大的原生支持，其中尤为明显的是持久化消息队列。同时，stream 借鉴了 kafka 的消费组模型概念和设计，使消费消息处理上更加高效快速。本文就 Streams 数据结构中常用 API 进行分析。</p>
</blockquote>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>本文所使用 Redis 版本为 5.0.5 。如果使用更早的 5.x 版本，有些 API 使用效果，与本文中描述略有不同。</p>
<h1 id="添加消息"><a href="#添加消息" class="headerlink" title="添加消息"></a>添加消息</h1><p>Streams 添加数据使用 <strong>XADD</strong> 指令进行添加，消息中的数据以 K-V 键值对的形式进行操作。一条消息可以存在多个键值对，添加命令格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XADD key ID field string [field string ...]</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>其中 key 为 Streams 的名称，ID 为消息的唯一标志，不可重复，field string 就为键值对。下面我们就添加以 person 为名称的流，进行操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XADD person * name ytao des https://ytao.top</span><br></pre></td></tr></table></figure>

<p>上面添加案例中，ID 使用 * 号复制，这里代表着服务端自动生成 Id，添加后返回数据 <code>&quot;1578238486193-0&quot;</code></p>
<p>这里自动生成的 Id 格式为 <code>&lt;millisecondsTime&gt;-&lt;sequenceNumber&gt;</code><br>Id 是由两部分组成：</p>
<ol>
<li>millisecondsTime 为当前服务器时间毫秒时间戳。</li>
<li>sequenceNumber 当前序列号，取值来源于当前毫秒内，生成消息的顺序，默认从 0 开始加 1 递增。</li>
</ol>
<p>比如：1578238486193-3 表示在 1578238486193 毫秒的时间戳时，添加的第 4 条消息。</p>
<p>除了服务端自动生成 Id 方式外，也支持指定 Id 的生成，但是指定 Id 有以下条件限制：</p>
<ol>
<li>Id 中的前后部分必须为数字。</li>
<li>最小 Id 为 0-1，不能为 0-0，但是 2-0，3-0 …. 是被允许的。</li>
<li>添加的消息，Id 的前半部分不能比存在 Id 最大的值小，Id 后半部分不能比存在前半部分相同的最大后半部分小。</li>
</ol>
<p>否则，当不满足上述条件时，添加后会抛出异常：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(error) ERR The ID specified <span class="keyword">in</span> XADD is equal or smaller than the target stream top item</span><br></pre></td></tr></table></figure>

<p>实际上，当添加一条消息时，会进行两部操作。第一步，先判断如果不存在 Streams，则创建 Streams 的名称，再添加消息到 Streams 中。即使添加消息时，由于 Id 异常，也可以在 Redis 中存在以当前 Streams 的名称。<br>Streams 中 Id 也可作为指针使用，因为它是一个有序的标记。</p>
<p>生产中，如果这样使用添加消息，会存在一个问题，那就是消息数量太大时，会使服务宕机。这里 Streams 的设计初期也有考虑到这个问题，那就是可以指定 Streams 的容量。如果容量操作这个设定的值，就会对调旧的消息。在添加消息时，设置 <code>MAXLEN</code> 参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XADD person MAXLEN 5 * name ytao des https://ytao.top</span><br></pre></td></tr></table></figure>

<p>这样就指定该了 Streams 中的容量为 5 条消息。也可使用 <strong>XTRIM</strong> 截取消息，从小到大剔除多余的消息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XTRIM person MAXLEN 8</span><br></pre></td></tr></table></figure>

<h1 id="消息数量"><a href="#消息数量" class="headerlink" title="消息数量"></a>消息数量</h1><p>查看消息数量使用 <strong>XLEN</strong> 指令进行操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XLEN key</span><br></pre></td></tr></table></figure>

<p>例：查看 person 流中的消息数量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; XLEN person</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure>

<h1 id="查询消息"><a href="#查询消息" class="headerlink" title="查询消息"></a>查询消息</h1><p>查询 Streams 中的消息使用 <strong>XRANGE</strong> 和 <strong>XREVRANGE</strong> 指令。</p>
<h2 id="XRANGE"><a href="#XRANGE" class="headerlink" title="XRANGE"></a>XRANGE</h2><p>查询数据时，可以按照指定 Id 范围进行查询，XRANGE 查询指令格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XRANGE key start end [COUNT count]</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>key 为 Streams 的名称</li>
<li>start 为范围查询开始 Id，包含本 Id。</li>
<li>start 为范围查询结束 Id，包含本 Id。</li>
<li>Count 为查询返回最大的消息数量，非必填。</li>
</ul>
<p>这里 start 和 end 有<code>-</code>和<code>+</code>两个非指定值，他们分别表示无穷小和无穷大，所以当使用这个两个值时，会查询出全部的消息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; XRANGE person - +</span><br><span class="line">1) 1) <span class="string">&quot;0-1&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;ytao&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;https://ytao.top&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;0-2&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;luffy&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;valiant!&quot;</span></span><br><span class="line">3) 1) <span class="string">&quot;2-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;gaga&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;fishion!&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面查询的消息数据，可以看到是按照先进先出的顺序查询出来的。</p>
<p>使用 COUNT 指定查询返回的数量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询所有的消息，并且返回一条数据</span></span><br><span class="line">&gt; XRANGE person - + COUNT 1</span><br><span class="line">1) 1) <span class="string">&quot;0-1&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;ytao&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;https://ytao.top&quot;</span></span><br></pre></td></tr></table></figure>

<p>在范围查询中，Id 的后半部分可省略，后半部分中的数据会全部查询到。</p>
<h2 id="XREVRANGE"><a href="#XREVRANGE" class="headerlink" title="XREVRANGE"></a>XREVRANGE</h2><p><strong>XREVRANGE</strong> 的查询和 <strong>XRANGE</strong> 指令中的使用类似，但查询的 start 和 end 参数顺序进行了调换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XREVRANGE key end start [COUNT count]</span><br></pre></td></tr></table></figure>

<p>使用案例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; XREVRANGE person +  -</span><br><span class="line">1) 1) <span class="string">&quot;2-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;gaga&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;fishion!&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;0-2&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;luffy&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;valiant!&quot;</span></span><br><span class="line">3) 1) <span class="string">&quot;0-1&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;ytao&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;https://ytao.top&quot;</span></span><br></pre></td></tr></table></figure>

<p>查询后的结果与 <strong>XRANGE</strong> 的结果顺序刚好相反，其他都一样，这两个指令可进行消息的升序和降序的返回。</p>
<h1 id="删除消息"><a href="#删除消息" class="headerlink" title="删除消息"></a>删除消息</h1><p>删除消息使用 <strong>XDEL</strong> 指令操作，只需指定将要删除的 Streams 名称和 Id 即可，支持一次删除多个消息 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XDEL key ID [ID ...]</span><br></pre></td></tr></table></figure>

<p>删除案例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询所有消息</span></span><br><span class="line">&gt; XRANGE person - +</span><br><span class="line">1) 1) <span class="string">&quot;0-1&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;ytao&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;https://ytao.top&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;0-2&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;luffy&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;valiant!&quot;</span></span><br><span class="line">3) 1) <span class="string">&quot;2-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;gaga&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;fishion!&quot;</span></span><br><span class="line"><span class="comment"># 删除消息      </span></span><br><span class="line">&gt; XDEL person 2-0</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 再次查询删除后的所有消息</span></span><br><span class="line">&gt; XRANGE person - +</span><br><span class="line">1) 1) <span class="string">&quot;0-1&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;ytao&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;https://ytao.top&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;0-2&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;luffy&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;valiant!&quot;</span></span><br><span class="line"><span class="comment"># 查询删除后的长度      </span></span><br><span class="line">&gt; XLEN person</span><br><span class="line">(<span class="built_in">integer</span>) 2            </span><br></pre></td></tr></table></figure>

<p>从上面可以看到，删除消息后，长度也会减少相应的数量。</p>
<h1 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h1><p>在 Redis 的 PUB&#x2F;SUB 中，我们是通过订阅来消费消息，在 Streams 数据结构中，同样也能实现同等功能，当没有新的消息时，可进行阻塞等待。不仅支持单独消费，而且还可以支持群组消费。</p>
<h2 id="单独消费"><a href="#单独消费" class="headerlink" title="单独消费"></a>单独消费</h2><p>单独消费使用 <strong>XREAD</strong> 指令。可以看到，下面命令中，STREAMS，key, 以及 ID 为必填项。ID 表示将要读取大于该 ID 的消息。当 ID 值使用 <code>$</code> 赋予时，表示已存在消息的最大 Id 值。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure>

<p>上面的 <code>COUNT</code> 参数用来指定读取的最大数量，与 <strong>XRANGE</strong> 的用法一样。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; XREAD COUNT 1 STREAMS person 0</span><br><span class="line">1) 1) <span class="string">&quot;person&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;0-1&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;ytao&quot;</span></span><br><span class="line">            3) <span class="string">&quot;des&quot;</span></span><br><span class="line">            4) <span class="string">&quot;https://ytao.top&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; XREAD COUNT 2 STREAMS person 0</span><br><span class="line">1) 1) <span class="string">&quot;person&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;0-1&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;ytao&quot;</span></span><br><span class="line">            3) <span class="string">&quot;des&quot;</span></span><br><span class="line">            4) <span class="string">&quot;https://ytao.top&quot;</span></span><br><span class="line">      2) 1) <span class="string">&quot;0-2&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;luffy&quot;</span></span><br><span class="line">            3) <span class="string">&quot;des&quot;</span></span><br><span class="line">            4) <span class="string">&quot;valiant!&quot;</span></span><br></pre></td></tr></table></figure>

<p>在 <strong>XREAD</strong> 里面还有个 <code>BLOCK</code> 参数，这个是用来阻塞订阅消息的，<code>BLOCK</code> 携带的参数为阻塞时间，单位为毫秒，如果在这个时间内没有新的消息消费，那么就会释放该阻塞。当这里的时间指定为 0 时，会一直阻塞，直到有新的消息来消费到。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 窗口 1 开启阻塞，等待新消息的到来</span></span><br><span class="line">&gt; XREAD BLOCK 0 STREAMS person $</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另开一个连接窗口 2，添加一条新的消息</span></span><br><span class="line">&gt; XADD person 2-2 name tao des coder</span><br><span class="line"><span class="string">&quot;2-2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 窗口 1，获取到有新的消息来消费，并且带有阻塞的时间</span></span><br><span class="line">&gt; XREAD BLOCK 0 STREAMS person $</span><br><span class="line">1) 1) <span class="string">&quot;person&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;2-2&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;tao&quot;</span></span><br><span class="line">            3) <span class="string">&quot;des&quot;</span></span><br><span class="line">            4) <span class="string">&quot;coder&quot;</span></span><br><span class="line">(60.81s)</span><br></pre></td></tr></table></figure>

<p>当使用 <strong>XREAD</strong> 进行顺序消费时，需要额外记录下读取到位置的 Id，方便下次继续消费。</p>
<h2 id="群组消费"><a href="#群组消费" class="headerlink" title="群组消费"></a>群组消费</h2><p>群组消费的主要目的也就是为了分流消息给不同的客户端处理，以更高效的速率处理消息。为达到这一肝功能需求，我们需要做三件事：<strong>创建群组</strong>，<strong>群组读取消息</strong>，<strong>向服务端确认消息以处理</strong>。</p>
<h3 id="群组操作"><a href="#群组操作" class="headerlink" title="群组操作"></a>群组操作</h3><p>操作群组使用 <strong>XGROUP</strong> 指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XGROUP [CREATE key groupname id-or-$] [SETID key id-or-$] [DESTROY key groupname] [DELCONSUMER key groupname consumername]</span><br></pre></td></tr></table></figure>

<p>上面命令中，包含操作有：</p>
<ul>
<li>CREATE 创建消费组。</li>
<li>SETID 修改下一个处理消息的 Id。</li>
<li>DESTROY 销毁消费组。</li>
<li>DELCONSUMER 删除消费组中指定的消费者。</li>
</ul>
<p>我们当前需要使用的是创建消费组：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以当前存在的最大 Id 作为消费起始 </span></span><br><span class="line">&gt; XGROUP CREATE person group1 $</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h3 id="群组读取消息"><a href="#群组读取消息" class="headerlink" title="群组读取消息"></a>群组读取消息</h3><p>群组读取使用 <strong>XREADGROUP</strong> 指令，<code>COUNT</code>和<code>BLOCK</code>的使用类似 <strong>XREAD</strong> 的操作，只是多了个群组和消费者的指定：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure>

<p>由于群组消费和单独消费类似，这里只进行个阻塞分析，这里 Id 也有个特殊值<code>&gt;</code>，表示还未进行消费的消息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 窗口 1，消费群组中，taotao 消费者建立阻塞监听</span></span><br><span class="line">XREADGROUP GROUP group1 taotao BLOCK 0 STREAMS person &gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 窗口 2，消费群组中，yangyang 消费者建立阻塞监听 </span></span><br><span class="line">XREADGROUP GROUP group1 yangyang BLOCK 0 STREAMS person &gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 窗口 3，添加消费消息</span></span><br><span class="line">&gt; XADD person 3-1 name tony des 666</span><br><span class="line"><span class="string">&quot;3-1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 窗口 1，读取到新消息，此时 窗口 2 没有任何反应</span></span><br><span class="line">&gt; XREADGROUP GROUP group1 taotao BLOCK 0 STREAMS person &gt;</span><br><span class="line">1) 1) <span class="string">&quot;person&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;3-1&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;tony&quot;</span></span><br><span class="line">            3) <span class="string">&quot;des&quot;</span></span><br><span class="line">            4) <span class="string">&quot;666&quot;</span></span><br><span class="line">(77.54s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 窗口 3，再次添加消费消息</span></span><br><span class="line">&gt; XADD person 3-2 name james des abc!</span><br><span class="line"><span class="string">&quot;3-2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 窗口 2，读取到新消息，此时 窗口 1 没有任何反应</span></span><br><span class="line">&gt; XREADGROUP GROUP group1 yangyang BLOCK 0 STREAMS person &gt;</span><br><span class="line">1) 1) <span class="string">&quot;person&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;3-2&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;james&quot;</span></span><br><span class="line">            3) <span class="string">&quot;des&quot;</span></span><br><span class="line">            4) <span class="string">&quot;abc!&quot;</span></span><br><span class="line">(76.36s)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上执行流程中，group1 群组中有两个消费者，当添加两条消息后，这两个消费者轮流消费。</p>
<h3 id="消息ACK"><a href="#消息ACK" class="headerlink" title="消息ACK"></a>消息ACK</h3><p>消息消费后，为避免再次重复消费，这是需要向服务端发送 ACK，确保消息被消费后的标记。<br>例如下列情况，我们上面我们将最新两条消息已进行了消费，但是当我们再次读取消息时，还是被读到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;  XREADGROUP GROUP group1 yangyang STREAMS person 0</span><br><span class="line">1) 1) <span class="string">&quot;person&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;3-2&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;james&quot;</span></span><br><span class="line">            3) <span class="string">&quot;des&quot;</span></span><br><span class="line">            4) <span class="string">&quot;abc!&quot;</span></span><br></pre></td></tr></table></figure>

<p>这时，我们使用 <strong>XACK</strong> 指令告诉服务器，我们已处理的消息:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">XACK key group ID [ID ...]0</span><br></pre></td></tr></table></figure>

<p>让服务器标记 3-2 已处理：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; XACK person group1 3-2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>再次获取群组读取消息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;  XREADGROUP GROUP group1 yangyang STREAMS person 0</span><br><span class="line">1) 1) <span class="string">&quot;person&quot;</span></span><br><span class="line">   2) (empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure>

<p>队列中没有了可读消息。<br>除了上面以讲解到的 API 外，查看消费群组信息可使用 <strong>XINFO</strong> 指令查看，本文不做分析。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>上面对 Streams 常用 API 进行了分析，我们可以感受到 Redis 在消息队列支持的道路上，也越来越强大。如果使用过它的 PUB&#x2F;SUB 功能的话，就会感受到 5.x 迭代正是将你的一些痛点进行了优化。</p>
</blockquote>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Streams</tag>
      </tags>
  </entry>
  <entry>
    <title>ElasticSearch之映射常用操作</title>
    <url>/2020/01/15/15-elasticsearch-mapping/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/elasticsearch.png"></p>
<p>本文案例操作，建议先阅读我之前的文章<a href="https://ytao.top/2019/12/14/11-elasticsearch/">《ElasticSearch之安装及基本操作API》</a></p>
<blockquote>
<p>Mapping (映射)类似关系型数据库中的表的结构定义。我们将数据以 JSON 格式存入到 ElasticSearch 中后，在搜索引擎中 JSON 字段映射对应的类型，这时需要 mapping 来定义内容的类型。</p>
</blockquote>
<span id="more"></span>

<h1 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h1><p>JSON 数据类型映射到 ElasticSearch 定义的类型，常用的简单类型有：</p>
<table>
<thead>
<tr>
<th align="center">JSON类型</th>
<th align="center">ElasticSearch 类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">文本类型</td>
<td align="center">Text&#x2F;Keyword</td>
</tr>
<tr>
<td align="center">整数类型</td>
<td align="center">long&#x2F;integer</td>
</tr>
<tr>
<td align="center">浮点类型</td>
<td align="center">float&#x2F;double</td>
</tr>
<tr>
<td align="center">时间类型</td>
<td align="center">date</td>
</tr>
<tr>
<td align="center">布尔值</td>
<td align="center">boolean</td>
</tr>
<tr>
<td align="center">数组</td>
<td align="center">Text&#x2F;Keyword</td>
</tr>
</tbody></table>
<p>上面要注意的是时间类型，JSON 中并没有时间类型，这里主要指时间格式数据的类型。</p>
<h1 id="定义映射"><a href="#定义映射" class="headerlink" title="定义映射"></a>定义映射</h1><p>在关系型数据库中，存储数据之前，我们会先创建表结构，给字段指定一个存在的类型。同样 ElasticSearch 在进行数据存储前，也可以先定义好存储数据的 Mapping 结构。<br>先定义一个简单的 person Mapping：</p>
<p><img src="https://images.ytao.top/es-mapping-1.png"></p>
<p>上图中就是一个 Mapping 的定义，如果是在 ElasticSearch7 之前，mappings 里还有 _type 属性。</p>
<h1 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h1><p>当没有事先定义好 Mapping，添加数据时，ElasticSearch 会自动根据字段进行换算出对应的类型，但是换算出来的类型并不一定是我们想要的字段类型，还是需要人为的干预进行修改成想要的 Mapping。</p>
<h1 id="更新映射"><a href="#更新映射" class="headerlink" title="更新映射"></a>更新映射</h1><p>使用 <strong>dynamic</strong> 控制映射是否可以被更新。</p>
<h2 id="dynamic-true"><a href="#dynamic-true" class="headerlink" title="dynamic-true"></a>dynamic-true</h2><p>设置 dynamic 为<code>true</code>是默认 dynamic 的默认值，新增字段数据可以写入，同时也可以被索引，Mapping 结构也会被更新。</p>
<p><img src="https://images.ytao.top/es-dynamic-true.png"></p>
<p>添加数据，同时多添加一个没被定义的 <code>gender</code> 字段。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 向 person 中添加数据</span></span><br><span class="line">PUT person/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;uId&quot;</span>: 1,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;ytao&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: 18,</span><br><span class="line">  <span class="string">&quot;address&quot;</span>: <span class="string">&quot;广东省珠海市&quot;</span>,</span><br><span class="line">  <span class="string">&quot;birthday&quot;</span>: <span class="string">&quot;2020-01-15T12:00:00Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;money&quot;</span>: 108.2,</span><br><span class="line">  <span class="string">&quot;isStrong&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;男&quot;</span>    <span class="comment"># Mapping 中未定义的字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加成功，搜索 <code>gender</code> 字段：</p>
<p><img src="https://images.ytao.top/es-dynamic-true-search.png"></p>
<p>查看 Mapping 结构：</p>
<p><img src="https://images.ytao.top/es-dynamic-true-mapping.png"></p>
<p>新添加的字段值，在添加过程中 Mapping 已自动添加字段。</p>
<h2 id="dynamic-false"><a href="#dynamic-false" class="headerlink" title="dynamic-false"></a>dynamic-false</h2><p>设置 dynamic 为<code>false</code>时，新增字段数据可以写入，不可以被索引，Mapping 结构会被更新。<br>同样先将 dynamic 设置为 false，然后向里面添加数据，其他步骤和上面 true 操作一样。定义 Mapping，添加数据。<br>搜索 <code>gender</code> 字段：</p>
<p><img src="https://images.ytao.top/es-dynamic-false-search.png"></p>
<p>此时新增字段数据无法被索引，但数据可以写入。</p>
<p><img src="https://images.ytao.top/es-dynamic-false-search2.png"></p>
<p>Mappnig 也不会添加新增的字段：</p>
<p><img src="https://images.ytao.top/es-dynamic-false-mapping.png"></p>
<h2 id="dynamic-strict"><a href="#dynamic-strict" class="headerlink" title="dynamic-strict"></a>dynamic-strict</h2><p>设置 dynamic 为<code>strict</code>时，从字面上意思也可以看出，对于动态映射是较严格的，新增字段数据不可以写入，不可以被索引，Mapping 结构不会被更新。只能按照定义好的 Mapping 结构添加数据。<br>在添加新字段数据时，就马上会抛出异常：</p>
<p><img src="https://images.ytao.top/es-dynamic-strict-search.png"></p>
<h1 id="自动识别日期类型"><a href="#自动识别日期类型" class="headerlink" title="自动识别日期类型"></a>自动识别日期类型</h1><p>上文中，当 dynamic 设置为 true 时，添加新字段数据自动识别类型更新 Mapping，如果是日期类型的话，我们是可以指定识别的类型。<br>指定 person 的 <strong>dynamic_date_formats</strong> 格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT person/_mapping</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;dynamic_date_formats&quot;</span>: [<span class="string">&quot;yyyy/MM/dd&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是可以指定多个时间格式。<br>向 person 添加新数据，分别是 today 和 firstDate：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT person/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;today&quot;</span>: <span class="string">&quot;2020-01-15&quot;</span>,</span><br><span class="line">  <span class="string">&quot;firstDate&quot;</span>: <span class="string">&quot;2020/01/15&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加新字段数据后的 Mapping：</p>
<p><img src="https://images.ytao.top/es-dynamic_date_format.png"></p>
<p>由于上面我们指定了时间格式为 <code>yyyy/MM/dd</code> 时是可以识别为时间格式，所以 today 字段的值为 <code>yyyy-MM-dd</code> 格式无法识别为时间类型，判为 text 类型。</p>
<h1 id="多字段"><a href="#多字段" class="headerlink" title="多字段"></a>多字段</h1><p>Mapping 中可以定义 <strong>fields</strong> 多字段属性，以满足不同场景下的实现。比如 <code>address</code> 定义为 <code>text</code> 类型，fields 里面又有定义 <code>keyword</code> 类型，这里主要是区分两个不同不同使用场景。</p>
<ul>
<li><code>text</code> 会建立分词倒排索引，用于全文检索。</li>
<li><code>keyword</code> 不会建立分词倒排索引，用于排序和聚合。</li>
</ul>
<p>添加数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 向 person 中添加数据</span></span><br><span class="line">PUT person/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;uId&quot;</span>: 1,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;ytao&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: 18,</span><br><span class="line">  <span class="string">&quot;address&quot;</span>: <span class="string">&quot;广东省珠海市&quot;</span>,</span><br><span class="line">  <span class="string">&quot;birthday&quot;</span>: <span class="string">&quot;2020-01-15T12:00:00Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;money&quot;</span>: 108.2,</span><br><span class="line">  <span class="string">&quot;isStrong&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询<code>address</code>数据。</p>
<p><img src="https://images.ytao.top/es-search-text.png"></p>
<p>查询<code>address.keyword</code>数据。</p>
<p><img src="https://images.ytao.top/es-search-keyword.png"></p>
<p>通过<code>keyword</code>检索时，由于不会建立分词索引，并没有获取到数据。</p>
<h1 id="控制索引"><a href="#控制索引" class="headerlink" title="控制索引"></a>控制索引</h1><p>在字段中使用 <strong>index</strong> 指定当前字段索引是否能被搜索到。指定类型为 boolean 类型，false 为不可搜索到，true 为可以搜索到。<br>先删除之前的 Mapping：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DELETE person</span><br></pre></td></tr></table></figure>

<p>创建 Mapping，设置<code>name</code>属性的 <code>index</code> 为 false。</p>
<p><img src="https://images.ytao.top/es-mapping-2.png"></p>
<p>再次添加上面的数据后搜索<code>name</code>字段：</p>
<p><img src="https://images.ytao.top/es-index-error.png"></p>
<p>字段 index 设置 false 后，由于没有被索引，所以搜索无法获取到索引。</p>
<h1 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h1><p>现在向 ElasticSearch 中添加一条 address 为空的数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PUT person/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;uId&quot;</span>: 2,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: 22,</span><br><span class="line">  <span class="string">&quot;address&quot;</span>: null,</span><br><span class="line">  <span class="string">&quot;birthday&quot;</span>: <span class="string">&quot;2020-01-15T12:00:00Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;money&quot;</span>: 68.7,</span><br><span class="line">  <span class="string">&quot;isStrong&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搜索 address.keyword 为空的数据：</p>
<p><img src="https://images.ytao.top/es-search-null-1.png"></p>
<p>搜索返回异常，默认是不被允许搜索 NUll。<br>这是需要在 Mapping 指定 <strong>null_value</strong> 属性，并且不能在<code>text</code>类型中声明。</p>
<p><img src="https://images.ytao.top/es-null_value.png"></p>
<p>搜索 address.keyword 为空的数据：</p>
<p><img src="https://images.ytao.top/es-search-null-2.png"></p>
<p>设置 <code>&quot;null_value&quot;: &quot;NULL&quot;</code> 后，空值可以处理搜索。</p>
<h1 id="聚合多个字段"><a href="#聚合多个字段" class="headerlink" title="聚合多个字段"></a>聚合多个字段</h1><p>聚合多个字段放到一个索引中，使用 <strong>copy_to</strong> 进行聚合。例如我们在多字段查询中，这是不需要对每个字段进行过滤筛选，只需对聚合字段即可。<br>在使用 copy_to 时，是通过指定聚合的名称实现。</p>
<p><img src="https://images.ytao.top/es-copy_to.png"></p>
<p>实际上，copy_to 不使用数组格式添加名称，也会自动转换成数据格式。</p>
<p>添加两条数据，待校验搜索：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 向 person 中添加数据</span></span><br><span class="line">PUT person/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;uId&quot;</span>: 1,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;ytao&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: 18,</span><br><span class="line">  <span class="string">&quot;address&quot;</span>: <span class="string">&quot;广东省珠海市&quot;</span>,</span><br><span class="line">  <span class="string">&quot;birthday&quot;</span>: <span class="string">&quot;2020-01-15T12:00:00Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;money&quot;</span>: 108.2,</span><br><span class="line">  <span class="string">&quot;isStrong&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT person/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;uId&quot;</span>: 2,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;杨广东&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: 22,</span><br><span class="line">  <span class="string">&quot;address&quot;</span>: null,</span><br><span class="line">  <span class="string">&quot;birthday&quot;</span>: <span class="string">&quot;2020-01-15T12:00:00Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;money&quot;</span>: 68.7,</span><br><span class="line">  <span class="string">&quot;isStrong&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询 <code>full_name</code> 的值，会返回 name 和 address 相关的值的对象。</p>
<p><img src="https://images.ytao.top/es-copy_to-search.png"></p>
<p>从上面返回结果看到，_source 中的字段没有增加相应的 copy_to 字段名，所以 copy_to 只会拷贝字段内容至索引，并不会改变包含的字段。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>通过本文对创建 Mapping 文件的常用并且实用的操作介绍，也基本能掌握这些日常的使用。了解 Mapping 的功能操作，相信对存储时的设计也有一定帮助。</p>
</blockquote>
]]></content>
      <categories>
        <category>ElasticSearch</category>
      </categories>
      <tags>
        <tag>ElasticSearch</tag>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo之服务暴露</title>
    <url>/2020/03/01/16-dubbo/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/dubbo.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文 Dubbo 使用版本<code>2.7.5</code><br>Dubbo 通过使用<code>dubbo:service</code>配置或<code>@service</code>在解析完配置后进行服务暴露，供服务消费者消费。<br>Dubbo 的服务暴露有两种：</p>
<ul>
<li>远程暴露</li>
<li>本地暴露</li>
</ul>
<p>可以通过<code>scope </code>显式指定暴露方式：</p>
<ul>
<li>none 不暴露</li>
<li>remote 远程暴露</li>
<li>local 本地暴露</li>
</ul>
<span id="more"></span>

<h1 id="服务暴露流程"><a href="#服务暴露流程" class="headerlink" title="服务暴露流程"></a>服务暴露流程</h1><p>下面是一个服务暴露的流程图：</p>
<p><img src="https://images.ytao.top/dubbo_rpc_export.jpg"></p>
<p><strong>ProxyFactory</strong> 是动态代理，用来创建 Invoker 对象，实现代理使用<code>JavassistProxyFactory</code>和<code>JdkProxyFactory</code>。<br><strong>Invoker</strong> 是一个服务对象实例，Dubbo 框架的实体域。它可以是一个本地的实现，一个远程的实现或一个集群的实现，可以向它发起 Invoker 调用。<br><strong>Protocol</strong> 是服务域，负责 Invoker 的生命周期管理，是 Invoker 暴露和引用的主要功能入口，对应该类的<code>export</code>和<code>refer</code>方法。<br><strong>Exporter</strong> 是根据不同协议暴露 Invoker 进行封装的类，它会根据不同的协议头进行识别（比如：<code>registry://</code>和<code>dubbo://</code>），调用对应<code>XXXProtocol</code>的<code>export()</code>方法。</p>
<p>从上图中可以看到，Dubbo 中服务暴露分为两个大步骤：第一步通过代理将服务实例转换成 Invoker，这就是通过我们常用的反射实现。第二步将 Invoker 根据具体的协议转换成 Exporter，这是就是我们要分析的核心。从这里可以看到 Dubbo 服务对象都是围绕 Invoker 进行工作。</p>
<h1 id="远程暴露"><a href="#远程暴露" class="headerlink" title="远程暴露"></a>远程暴露</h1><p>服务远程暴露从字面上理解，就是将服务跨网络进行远程通信，并非同一 JVM 中的服务进行调用。<br>服务最后都是转换成<code>org.apache.dubbo.config.spring.ServiceBean</code>，它的UML类图：</p>
<p><img src="https://images.ytao.top/dubbo_servicebean-uml.png"></p>
<p><code>ServiceBean</code>继承自<code>ServiceConfig</code>，服务在<code>ServiceConfig#doExportUrls</code>根据不同协议进行暴露。</p>
<p><img src="https://images.ytao.top/dubbo_serviceconfig_doexporturls.png"></p>
<p>通过获取所有注册中心实例（registryURLs）后，进行依次暴露，暴露操作在<code>doExportUrlsFor1Protocol</code>中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> &#123;</span><br><span class="line">	Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line">	<span class="comment">// 配置信息存入 map</span></span><br><span class="line">	</span><br><span class="line">	.....</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 获取服务URL</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">port</span> <span class="operator">=</span> findConfigedPorts(protocolConfig, name, map);</span><br><span class="line">	<span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(name, host, port, getContextPath(protocolConfig).map(p -&gt; p + <span class="string">&quot;/&quot;</span> + path).orElse(path), map);</span><br><span class="line">    </span><br><span class="line">	.....</span><br><span class="line"></span><br><span class="line">	<span class="type">String</span> <span class="variable">scope</span> <span class="operator">=</span> url.getParameter(SCOPE_KEY);</span><br><span class="line">	<span class="comment">// 如果 scope 配置为 none，则服务不进行暴露</span></span><br><span class="line">	<span class="keyword">if</span> (!SCOPE_NONE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 本地暴露</span></span><br><span class="line">		<span class="keyword">if</span> (!SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">			exportLocal(url);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 远程暴露</span></span><br><span class="line">		<span class="keyword">if</span> (!SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">		    <span class="comment">// 判断是否有注册中心</span></span><br><span class="line">			<span class="keyword">if</span> (CollectionUtils.isNotEmpty(registryURLs)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">                    <span class="comment">//if protocol is only injvm ,not register</span></span><br><span class="line">                    <span class="keyword">if</span> (LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    url = url.addParameterIfAbsent(DYNAMIC_KEY, registryURL.getParameter(DYNAMIC_KEY));</span><br><span class="line">                    <span class="comment">// 获取监控URL</span></span><br><span class="line">                    <span class="type">URL</span> <span class="variable">monitorUrl</span> <span class="operator">=</span> ConfigValidationUtils.loadMonitor(<span class="built_in">this</span>, registryURL);</span><br><span class="line">                    <span class="keyword">if</span> (monitorUrl != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 追加监控上报地址，在拦截器上报数据</span></span><br><span class="line">                        url = url.addParameterAndEncoded(MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 日志打印</span></span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (url.getParameter(REGISTER_KEY, <span class="literal">true</span>)) &#123;</span><br><span class="line">                            logger.info(<span class="string">&quot;Register dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; url &quot;</span> + url + <span class="string">&quot; to registry &quot;</span> + registryURL);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            logger.info(<span class="string">&quot;Export dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; to url &quot;</span> + url);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// For providers, this is used to enable custom proxy to generate invoker</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">proxy</span> <span class="operator">=</span> url.getParameter(PROXY_KEY);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotEmpty(proxy)) &#123;</span><br><span class="line">                        registryURL = registryURL.addParameter(PROXY_KEY, proxy);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将服务对象转换成 Invoker</span></span><br><span class="line">                    Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));</span><br><span class="line">                    <span class="type">DelegateProviderMetaDataInvoker</span> <span class="variable">wrapperInvoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegateProviderMetaDataInvoker</span>(invoker, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 暴露服务，向注册中心注册服务，进入对应的 RegistryProtocol</span></span><br><span class="line">                    Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                    exporters.add(exporter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 没有注册中心时</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;Export dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; to url &quot;</span> + url);</span><br><span class="line">                &#125;</span><br><span class="line">                Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">                <span class="type">DelegateProviderMetaDataInvoker</span> <span class="variable">wrapperInvoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegateProviderMetaDataInvoker</span>(invoker, <span class="built_in">this</span>);</span><br><span class="line">                <span class="comment">// 直接暴露服务</span></span><br><span class="line">                Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                exporters.add(exporter);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 存储Dubbo服务的元数据，元数据可以存储在远端配置中心和本地，默认是存储在本地</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@since</span> 2.7.0</span></span><br><span class="line"><span class="comment">             * ServiceData Store</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">WritableMetadataService</span> <span class="variable">metadataService</span> <span class="operator">=</span> WritableMetadataService.getExtension(url.getParameter(METADATA_KEY, DEFAULT_METADATA_STORAGE_TYPE));</span><br><span class="line">            <span class="keyword">if</span> (metadataService != <span class="literal">null</span>) &#123;</span><br><span class="line">                metadataService.publishServiceDefinition(url);</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">this</span>.urls.add(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是代码片段为暴露服务的核心，可以看到 scope 由三个值控制是否暴露和远程或本地暴露，默认远程和本地都暴露。<br>在远程调用中，分为<strong>使用注册中心暴露</strong>和<strong>直接暴露</strong>（默认dubbo协议），它们之间的区别在url上：</p>
<ul>
<li>无注册中心：dubbo:&#x2F;&#x2F;192.168.3.19:20880&#x2F;xxxx</li>
<li>有注册中心：**registry:&#x2F;&#x2F;127.0.0.1:2181&#x2F;org.apache.dubbo.registry.RegistryService?application&#x3D;provider&amp;dubbo&#x3D;2.0.2&amp;export&#x3D;**dubbo:&#x2F;&#x2F;192.168.3.19:20880&#x2F;xxxx</li>
</ul>
<p>无注册中心的直接暴露服务。<br>有注册中心的先创建注册中心，再得到 export 的服务地址，然后暴露服务，当服务暴露成功后把服务元数据注册到注册中心。</p>
<p>代码中<code>protocol#export</code>会根据服务 url 的请求头进行区分不同<code>XXXProtocol#export</code>的逻辑，比如。<br>目前 Dubbo 中有以下几种：</p>
<p><img src="https://images.ytao.top/dubbo_protocol_impl.png"></p>
<h1 id="本地暴露"><a href="#本地暴露" class="headerlink" title="本地暴露"></a>本地暴露</h1><p>同一个应用中，可能既要提供服务远程暴露给其他应用引用，也要给自身提供引用。如果只提供远程暴露的话，当自身应用需要引用自身的服务时，需要通过远程通信访问，那么这大大浪费网络资源。这是就需要用 injvm 协议暴露，就是我们所说的本地暴露，无需跨网络远程通信，可以更好的节省资源。<br>通过上面代码中，我们知道本地暴露调用的是<code>ServiceConfig#exportLocal</code>方法。</p>
<p><img src="https://images.ytao.top/dubbo_serviceconfig_exportlocal.png"></p>
<p>本地暴露会指定 injvm 协议，并且 host 指定为本地<code>127.0.0.1</code>和端口号为0。<br>protocol.export 调用 <code>InjvmProtocol#export</code> 实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Exporter&lt;T&gt; <span class="title function_">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InjvmExporter</span>&lt;T&gt;(invoker, invoker.getUrl().getServiceKey(), exporterMap);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>export 中返回了 InjvmExporter 实例化对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InjvmExporter</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">AbstractExporter</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap;</span><br><span class="line"></span><br><span class="line">    InjvmExporter(Invoker&lt;T&gt; invoker, String key, Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap) &#123;</span><br><span class="line">        <span class="built_in">super</span>(invoker);</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.exporterMap = exporterMap;</span><br><span class="line">        exporterMap.put(key, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unexport</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.unexport();</span><br><span class="line">        exporterMap.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本地暴露就比较简单，将 Invoker 直接保存在 InjvmExporter 的 exporterMap 中。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote>
<p>本篇对 Dubbo 的服务暴露流程进行了分析，核心点就是开篇图中的得到 Invoker 后转化到 Export。其中更多详细的地方，由于展开后篇幅太大，不能一一写到，会在今后相关的 Dubbo 文章再进行讲解。</p>
</blockquote>
]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile 手摸手带你解析</title>
    <url>/2020/03/15/18-volatile/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/volatile.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>volatile 是 Java 里的一个重要的指令，它是由 Java 虚拟机里提供的一个轻量级的同步机制。一个共享变量声明为 volatile 后，特别是在多线程操作时，正确使用 volatile 变量，就要掌握好其原理。</p>
<span id="more"></span>

<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>volatile 具有<strong>可见性</strong>和<strong>有序性</strong>的特性，同时，对 volatile 修饰的变量进行单个读写操作是具有<strong>原子性</strong>。</p>
<p>这几个特性到底是什么意思呢？</p>
<ul>
<li><strong>可见性：</strong> 当一个线程更新了 volatile 修饰的共享变量，那么任意其他线程都能知道这个变量最后修改的值。简单的说，就是多线程运行时，一个线程修改 volatile 共享变量后，其他线程获取值时，一定都是这个修改后的值。</li>
<li><strong>有序性：</strong> 一个线程中的操作，相对于自身，都是有序的，Java 内存模型会限制编译器重排序和处理器重排序。意思就会说 volatile 内存语义单个线程中是串行的语义。</li>
<li><strong>原子性：</strong> 多线程操作中，非复合操作单个 volatile 的读写是具有原子性的。</li>
</ul>
<h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><p>可见性是在多线程中保证共享变量的数据有效，接下来我们通过有 volatile 修饰的变量和无 volatile 修饰的变量代码的执行结果来做对比分析。</p>
<h2 id="无-volatile-修饰变量"><a href="#无-volatile-修饰变量" class="headerlink" title="无 volatile 修饰变量"></a>无 volatile 修饰变量</h2><p>以下是没有 volatile 修饰变量代码，通过创建两个线程，来验证 flag 被其中一个线程修改后的执行情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YANGTAO on 2020/3/15 0015.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValatileDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A 线程，判断其他线程修改 flag 之后，数据是否对本线程有效</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.printf(<span class="string">&quot;********** %s 线程执行结束！ **********&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// B 线程，修改 flag 值</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 避免 B 线程比 A 线程先运行修改 flag 值  </span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 如果 flag 值修改后，让 B 线程先打印信息</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                System.out.printf(<span class="string">&quot;********** %s 线程执行结束！ **********&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，当 flag 初始值 true，被 B 线程修改为 false。如果修改后的值对 A 线程有效，那么正常情况下 A 线程会先于 B 线程结束。执行结果如下：</p>
<p><img src="https://images.ytao.top/volatile-no-kejian.png"></p>
<p>执行结果是：当 B 线程执行结束后，<code>flag = false</code>并未对 A 线程生效，A 线程死循环。</p>
<h2 id="volatile-修饰变量"><a href="#volatile-修饰变量" class="headerlink" title="volatile 修饰变量"></a>volatile 修饰变量</h2><p>在上述代码中，当我们把 flag 使用 volatile 修饰:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YANGTAO on 2020/3/15 0015.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValatileDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A 线程，判断其他线程修改 flag 之后，数据是否对本线程有效</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.printf(<span class="string">&quot;********** %s 线程执行结束！ **********&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// B 线程，修改 flag 值</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 避免 B 线程比 A 线程先运行修改 flag 值  </span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 如果 flag 值修改后，让 B 线程先打印信息</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                System.out.printf(<span class="string">&quot;********** %s 线程执行结束！ **********&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://images.ytao.top/volatile-kejian.png"></p>
<p>B 线程修改 flag 值后，对 A 线程数据有效，A 线程跳出循环，执行完成。所以 volatile 修饰的变量，有新值写入后，对其他线程来说，数据是有效的，能被其他线程读到。</p>
<h2 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h2><p>上面代码中的变量加了 volatile 修饰，为什么就能被其他线程读取到，这就涉及到 Java 内存模型规定的变量访问规则。</p>
<ul>
<li><strong>主内存：</strong>主内存是机器硬件的内存，主要对应Java 堆中的对象实例数据部分。</li>
<li><strong>工作内存：</strong>每个线程都有自己的工作内存，对应虚拟机栈中的部分区域，线程对变量的读&#x2F;写操作都必须在工作内存中进行，不能直接读写主内存的变量。</li>
</ul>
<p>上面<code>无 volatile 修饰变量</code>部分的代码执行示意图如下：</p>
<p><img src="https://images.ytao.top/volatile-no-volatile.png"></p>
<p>当 A 线程读取到 flag 的初始值为<code>true</code>，进行 while 循环操作，B 线程将工作内存 B 里的 flag 更新为<code>false</code>，然后将值发送到主内存进行更新。随后，由于此时的 A 线程不会主动刷新主内存中的值到工作内存 A 中，所以线程 A 所取得 flag 值一直都是<code>true</code>，A 线程也就为死循环不会停止下来。</p>
<p>上面<code>volatile 修饰变量</code>部分的代码执行示意图如下：</p>
<p><img src="https://images.ytao.top/volatile-has-volatile.png"></p>
<p>当 B 线程更新 volatile 修饰的变量时，会向 A 线程通过线程之间的通信发送通知（JDK5 或更高版本），并且将工作内存 B 中更新的值同步到主内存中。A 线程接收到通知后，不会再读取工作内存 A 中的值，会将主内存的变量通过主内存和工作内存之间的交互协议，拷贝到工作内存 A 中，这时读取的值就是线程 A 更新后的值<code>flag = false</code>。<br>整个变量值得传递过程中，线程之间不能直接访问自身以外的工作内存，必须通过主内存作为中转站传递变量值。在这传递过程中是存在拷贝操作的，但是对象的引用，虚拟机不会整个对象进行拷贝，会存在线程访问的字段拷贝。</p>
<h1 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h1><p>volatile 包含禁止指令重排的语义，Java 内存模型会限制编译器重排序和处理器重排序，简而言之就是单个线程内表现为串行语义。<br><strong>那什么是重排序？</strong><br>重排序的目的是编译器和处理器为了优化程序性能而对指令序列进行重排序，但在单线程和单处理器中，重排序不会改变有数据依赖关系的两个操作顺序。<br>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YANGTAO on 2020/3/15 0015.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReorderDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">        b = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重排序后：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReorderDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        b = <span class="number">3</span>;  <span class="comment">// a 和 b 重排序后，调换了位置</span></span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果在单核处理器和单线程中数据之间存在依赖关系则不会进行重排序，比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YANGTAO on 2020/3/15 0015.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReorderDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于 a 和 b 存在数据依赖关系，则不会进行重排序</span></span><br></pre></td></tr></table></figure>

<p>volatile 实现特有的内存语义，Java 内存模型定义以下规则（表格中的 No 代表不可以重排序）：</p>
<p><img src="https://images.ytao.top/volatile-rule.png"></p>
<p>Java 内存模型在指令序列中插入内存屏障来处理 volatile 重排序规则，策略如下：</p>
<ul>
<li>volatile 写操作前插入一个 StoreStore 屏障</li>
<li>volatile 写操作后插入一个 StoreLoad 屏障</li>
<li>volatile 读操作后插入一个 LoadLoad 屏障</li>
<li>volatile 读操作后插入一个 LoadStore 屏障</li>
</ul>
<p>该四种屏障意义：</p>
<ul>
<li>StoreStore：在该屏障后的写操作执行之前，保证该屏障前的写操作已刷新到主内存。</li>
<li>StoreLoad：在该屏障后的读取操作执行之前，保证该屏障前的写操作已刷新到主内存。</li>
<li>LoadLoad：在该屏障后的读取操作执行之前，保证该屏障前的读操作已读取完毕。</li>
<li>LoadStore：在该屏障后的写操作执行之前，保证该屏障前的读操作已读取完毕。</li>
</ul>
<h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><p>前面有提到 volatile 的原子性是相对于单个 volatile 变量的读&#x2F;写具有，比如下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YANGTAO on 2020/3/15 0015.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  <span class="comment">// 创建 10 个线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;    <span class="comment">// 每个线程累加 1000</span></span><br><span class="line">                    num ++;</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;, String.valueOf(i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 所有线程累加计算的数据</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;num: %d&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果 volatile 修饰 num，在 num++ 运算中能持有原子性，那么根据以上数量的累加，最后应该是 <code>num: 10000</code>。<br>代码执行结果：</p>
<p><img src="https://images.ytao.top/volatile-atomic.png"></p>
<p>结果与我们预计数据的相差挺多，虽然 volatile 变量在更新值的时候回通知其他线程刷新主内存中最新数据，但这只能保证其基本类型变量读&#x2F;写的原子操作（如：num &#x3D; 2）。由于<code>num++</code>是属于一个非原子操作的复合操作，所以不能保证其原子性。</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ol>
<li>volatile 变量最后的运算结果不依赖变量的当前值，也就是前面提到的直接赋值变量的原子操作，比如：保存数据遍历的特定条件的一个值。</li>
<li>可以进行状态标记，比如：是否初始化，是否停止等等。</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>volatile 是一个简单又轻量级的同步机制，但在使用过程中，局限性比较大，要想使用好它，必须了解其原理及本质，所以在使用过程中遇到的问题，相比于其他同步机制来说，更容易出现问题。但使用好 volatile，在某些解决问题上能获取更佳的性能。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo之服务消费原理</title>
    <url>/2020/03/08/17-dubbo-reference/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/dubbo.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章<a href="https://ytao.top/2020/03/01/16-dubbo/">《Dubbo之服务暴露》</a>分析 Dubbo 服务是如何暴露的，本文接着分析 Dubbo 服务的消费流程。主要从以下几个方面进行分析：<strong>注册中心的暴露</strong>；<strong>通过注册中心进行服务消费通知</strong>；<strong>直连服务进行消费</strong>。<br>服务消费端启动时，将自身的信息注册到注册中心的目录，同时还订阅服务提供方的目录，当服务提供方的 URL 发生更改时，实时获取新的数据。</p>
<span id="more"></span>

<h1 id="服务消费端流程"><a href="#服务消费端流程" class="headerlink" title="服务消费端流程"></a>服务消费端流程</h1><p>下面是一个服务消费的流程图：</p>
<p><img src="https://images.ytao.top/dubbo_rpc_refer.jpg"></p>
<p>上图中可以看到，服务消费的流程与服务暴露的流程有点类似逆向的。同样，Dubbo 服务也是分为两个大步骤：第一步就是将远程服务通过<code>Protocol</code>转换成<code>Invoker</code>(概念在上篇文章中有解释)。第二步通过动态代理将<code>Invoker</code>转换成消费服务需要的接口。</p>
<p><code>org.apache.dubbo.config.ReferenceConfig </code>类是<code>ReferenceBean</code>的父类，与生产端服务的<code>ServiceBean</code>一样，存放着解析出来的 XML 和注解信息。类关系如下：</p>
<p><img src="https://images.ytao.top/dubbo_referencebean.png"></p>
<h1 id="服务初始化中转换的入口"><a href="#服务初始化中转换的入口" class="headerlink" title="服务初始化中转换的入口"></a>服务初始化中转换的入口</h1><p>当我们消费端调用本地接口就能实现远程服务的调用，这是怎么实现的呢？根据上面的流程图，来分析消费原理。<br>在消费端进行初始化时<code>ReferenceConfig#init</code>，会执行<code>ReferenceConfig#createProxy</code>来完成这一系列操作。以下为<code>ReferenceConfig#createProxy</code>主要的代码部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">createProxy</span><span class="params">(Map&lt;String, String&gt; map)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否为 Jvm 本地引用</span></span><br><span class="line">    <span class="keyword">if</span> (shouldJvmRefer(map)) &#123;</span><br><span class="line">        <span class="comment">// 通过 injvm 协议，获取本地服务</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(LOCAL_PROTOCOL, LOCALHOST_VALUE, <span class="number">0</span>, interfaceClass.getName()).addParameters(map);</span><br><span class="line">        invoker = REF_PROTOCOL.refer(interfaceClass, url);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        urls.clear();</span><br><span class="line">        <span class="comment">// 判断是否有自定义的直连地址，或注册中心地址</span></span><br><span class="line">        <span class="keyword">if</span> (url != <span class="literal">null</span> &amp;&amp; url.length() &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            String[] us = SEMICOLON_SPLIT_PATTERN.split(url);</span><br><span class="line">            <span class="keyword">if</span> (us != <span class="literal">null</span> &amp;&amp; us.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String u : us) &#123;</span><br><span class="line">                    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> URL.valueOf(u);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isEmpty(url.getPath())) &#123;</span><br><span class="line">                        url = url.setPath(interfaceName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (UrlUtils.isRegistry(url)) &#123;</span><br><span class="line">                        <span class="comment">// 如果是注册中心Protocol类型，则向地址中添加 refer 服务消费元数据</span></span><br><span class="line">                        urls.add(url.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 直连服务提供端</span></span><br><span class="line">                        urls.add(ClusterUtils.mergeUrl(url, map));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 组装注册中心的配置</span></span><br><span class="line">            <span class="keyword">if</span> (!LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol())) &#123;</span><br><span class="line">                <span class="comment">// 检查配置中心</span></span><br><span class="line">                checkRegistry();</span><br><span class="line">                List&lt;URL&gt; us = ConfigValidationUtils.loadRegistries(<span class="built_in">this</span>, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(us)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (URL u : us) &#123;</span><br><span class="line">                        <span class="type">URL</span> <span class="variable">monitorUrl</span> <span class="operator">=</span> ConfigValidationUtils.loadMonitor(<span class="built_in">this</span>, u);</span><br><span class="line">                        <span class="keyword">if</span> (monitorUrl != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 监控上报信息</span></span><br><span class="line">                            map.put(MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 注册中心地址添加 refer 服务消费元数据</span></span><br><span class="line">                        urls.add(u.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只有一条注册中心数据，即单注册中心</span></span><br><span class="line">        <span class="keyword">if</span> (urls.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 将远程服务转化成 Invoker</span></span><br><span class="line">            invoker = REF_PROTOCOL.refer(interfaceClass, urls.get(<span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 因为多注册中心就会存在多个 Invoker，这里用保存在 List 中</span></span><br><span class="line">            List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Invoker&lt;?&gt;&gt;();</span><br><span class="line">            <span class="type">URL</span> <span class="variable">registryURL</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                <span class="comment">// 将每个注册中心转换成 Invoker 数据</span></span><br><span class="line">                invokers.add(REF_PROTOCOL.refer(interfaceClass, url));</span><br><span class="line">                <span class="keyword">if</span> (UrlUtils.isRegistry(url)) &#123;</span><br><span class="line">                    <span class="comment">// 会覆盖前遍历的注册中心，使用最后一条注册中心数据</span></span><br><span class="line">                    registryURL = url;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (registryURL != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 默认使用 zone-aware 策略来处理多个订阅</span></span><br><span class="line">                <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span> registryURL.addParameterIfAbsent(CLUSTER_KEY, ZoneAwareCluster.NAME);</span><br><span class="line">                <span class="comment">// 将转换后的多个 Invoker 合并成一个</span></span><br><span class="line">                invoker = CLUSTER.join(<span class="keyword">new</span> <span class="title class_">StaticDirectory</span>(u, invokers));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                invoker = CLUSTER.join(<span class="keyword">new</span> <span class="title class_">StaticDirectory</span>(invokers));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用动态代理，将 Invoker 转换成本地接口代理</span></span><br><span class="line">    <span class="keyword">return</span> (T) PROXY_FACTORY.getProxy(invoker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面转换的过程中，主要可概括为：先分为本地引用和远程引用两类。本地就是以 inJvm 协议的获取本地服务，这不做过多说明；远程引用分为直连服务和通过注册中心。注册中心分为单注册中心和多注册中心的情况，单注册中心好解决，直接使用即可，多注册中心时，将转换后的 Invoker 合并成一个 Invoker。最后通过动态代理将 Invoker 转换成本地接口代理。</p>
<h1 id="获取-Invoker-实例"><a href="#获取-Invoker-实例" class="headerlink" title="获取 Invoker 实例"></a>获取 Invoker 实例</h1><p>由于本地服务时直接从缓存中获取，这里就注册中心的消费进行分析，上面代码片段中使用的是<code>REF_PROTOCOL.refer</code>进行转换，该方法代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="comment">// 获取服务的注册中心url，里面会设置注册中心的协议和移除 registry 的参数</span></span><br><span class="line">    url = getRegistryUrl(url);</span><br><span class="line">    <span class="comment">// 获取注册中心实例</span></span><br><span class="line">    <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> registryFactory.getRegistry(url);</span><br><span class="line">    <span class="keyword">if</span> (RegistryService.class.equals(type)) &#123;</span><br><span class="line">        <span class="keyword">return</span> proxyFactory.getInvoker((T) registry, type, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务消费元数据</span></span><br><span class="line">    Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));</span><br><span class="line">    <span class="comment">// 从服务消费元数据中获取分组信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> qs.get(GROUP_KEY);</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="literal">null</span> &amp;&amp; group.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((COMMA_SPLIT_PATTERN.split(group)).length &gt; <span class="number">1</span> || <span class="string">&quot;*&quot;</span>.equals(group)) &#123;</span><br><span class="line">            <span class="comment">// 执行 Invoker 转换工作</span></span><br><span class="line">            <span class="keyword">return</span> doRefer(getMergeableCluster(), registry, type, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行 Invoker 转换工作</span></span><br><span class="line">    <span class="keyword">return</span> doRefer(cluster, registry, type, url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面主要是获取服务消费的注册中心实例和进行服务分组，最后调用<code>doRefer</code>方法进行转换工作，以下为<code>doRefer</code>的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 RegistryDirectory 对象</span></span><br><span class="line">    RegistryDirectory&lt;T&gt; directory = <span class="keyword">new</span> <span class="title class_">RegistryDirectory</span>&lt;T&gt;(type, url);</span><br><span class="line">    <span class="comment">// 设置注册中心</span></span><br><span class="line">    directory.setRegistry(registry);</span><br><span class="line">    <span class="comment">// 设置协议</span></span><br><span class="line">    directory.setProtocol(protocol);</span><br><span class="line">    <span class="comment">// directory.getUrl().getParameters() 是服务消费元数据</span></span><br><span class="line">    Map&lt;String, String&gt; parameters = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class="line">    <span class="type">URL</span> <span class="variable">subscribeUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line">    <span class="keyword">if</span> (!ANY_VALUE.equals(url.getServiceInterface()) &amp;&amp; url.getParameter(REGISTER_KEY, <span class="literal">true</span>)) &#123;</span><br><span class="line">        directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url));</span><br><span class="line">        <span class="comment">// 消费消息注册到注册中心</span></span><br><span class="line">        registry.register(directory.getRegisteredConsumerUrl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    directory.buildRouterChain(subscribeUrl);</span><br><span class="line">    <span class="comment">// 服务消费者订阅：服务提供端，动态配置，路由的通知</span></span><br><span class="line">    directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,</span><br><span class="line">            PROVIDERS_CATEGORY + <span class="string">&quot;,&quot;</span> + CONFIGURATORS_CATEGORY + <span class="string">&quot;,&quot;</span> + ROUTERS_CATEGORY));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多个Invoker合并为一个</span></span><br><span class="line">    <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> cluster.join(directory);</span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面实现主要是完成创建 RegistryDirectory 对象，将消费服务元数据注册到注册中心，通过 RegistryDirectory 对象里的信息，实现服务提供端，动态配置及路由的订阅相关功能。</p>
<p>RegistryDirectory 这个类实现了 NotifyListener 这个通知监听接口，当订阅的服务，配置或路由发生变化时，会接收到通知，进行相应改变：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(List&lt;URL&gt; urls)</span> &#123;</span><br><span class="line">    <span class="comment">// 将服务提供方配置，路由配置，服务提供方的服务分别以不同的 key 保存在 Map 中</span></span><br><span class="line">    Map&lt;String, List&lt;URL&gt;&gt; categoryUrls = urls.stream()</span><br><span class="line">            .filter(Objects::nonNull)</span><br><span class="line">            .filter(<span class="built_in">this</span>::isValidCategory)</span><br><span class="line">            .filter(<span class="built_in">this</span>::isNotCompatibleFor26x)</span><br><span class="line">            .collect(Collectors.groupingBy(url -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (UrlUtils.isConfigurator(url)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> CONFIGURATORS_CATEGORY;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UrlUtils.isRoute(url)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ROUTERS_CATEGORY;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UrlUtils.isProvider(url)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> PROVIDERS_CATEGORY;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新服务提供方配置</span></span><br><span class="line">    List&lt;URL&gt; configuratorURLs = categoryUrls.getOrDefault(CONFIGURATORS_CATEGORY, Collections.emptyList());</span><br><span class="line">    <span class="built_in">this</span>.configurators = Configurator.toConfigurators(configuratorURLs).orElse(<span class="built_in">this</span>.configurators);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新路由配置</span></span><br><span class="line">    List&lt;URL&gt; routerURLs = categoryUrls.getOrDefault(ROUTERS_CATEGORY, Collections.emptyList());</span><br><span class="line">    toRouters(routerURLs).ifPresent(<span class="built_in">this</span>::addRouters);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载服务提供方的服务信息</span></span><br><span class="line">    List&lt;URL&gt; providerURLs = categoryUrls.getOrDefault(PROVIDERS_CATEGORY, Collections.emptyList());</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.x added for extend URL address</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ExtensionLoader&lt;AddressListener&gt; addressListenerExtensionLoader = ExtensionLoader.getExtensionLoader(AddressListener.class);</span><br><span class="line">    List&lt;AddressListener&gt; supportedListeners = addressListenerExtensionLoader.getActivateExtension(getUrl(), (String[]) <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (supportedListeners != <span class="literal">null</span> &amp;&amp; !supportedListeners.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AddressListener addressListener : supportedListeners) &#123;</span><br><span class="line">            providerURLs = addressListener.notify(providerURLs, getUrl(),<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新加载 Invoker 实例</span></span><br><span class="line">    refreshOverrideAndInvoker(providerURLs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>RegistryDirectory#notify</code>里面最后会刷新 Invoker 进行重新加载，下面是核心代码的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshOverrideAndInvoker</span><span class="params">(List&lt;URL&gt; urls)</span> &#123;</span><br><span class="line">    <span class="comment">// mock zookeeper://xxx?mock=return null</span></span><br><span class="line">    overrideDirectoryUrl();</span><br><span class="line">    <span class="comment">// 刷新 invoker </span></span><br><span class="line">    refreshInvoker(urls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshInvoker</span><span class="params">(List&lt;URL&gt; invokerUrls)</span> &#123;</span><br><span class="line">    Assert.notNull(invokerUrls, <span class="string">&quot;invokerUrls should not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (invokerUrls.size() == <span class="number">1</span></span><br><span class="line">            &amp;&amp; invokerUrls.get(<span class="number">0</span>) != <span class="literal">null</span></span><br><span class="line">            &amp;&amp; EMPTY_PROTOCOL.equals(invokerUrls.get(<span class="number">0</span>).getProtocol())) &#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 刷新之前的 Invoker</span></span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = <span class="built_in">this</span>.urlInvokerMap; <span class="comment">// local reference</span></span><br><span class="line">        <span class="comment">// 加载新的 Invoker Map</span></span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);<span class="comment">// Translate url list to Invoker map</span></span><br><span class="line">        <span class="comment">// 获取新的 Invokers</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; newInvokers = Collections.unmodifiableList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(newUrlInvokerMap.values()));</span><br><span class="line">        <span class="comment">// 缓存新的 Invokers</span></span><br><span class="line">        routerChain.setInvokers(newInvokers);</span><br><span class="line">        <span class="built_in">this</span>.invokers = multiGroup ? toMergeInvokerList(newInvokers) : newInvokers;</span><br><span class="line">        <span class="built_in">this</span>.urlInvokerMap = newUrlInvokerMap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过新旧 Invokers 对比，销毁无用的 Invokers</span></span><br><span class="line">            destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); <span class="comment">// Close the unused Invoker</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;destroyUnusedInvokers error. &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取刷新前后的 Invokers，将新的 Invokers 重新缓存起来，通过对比，销毁无用的 Invoker。</p>
<p>上面将 URL 转换 Invoker 是在<code>RegistryDirectory#toInvokers</code>中进行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Invoker&lt;T&gt;&gt; <span class="title function_">toInvokers</span><span class="params">(List&lt;URL&gt; urls)</span> &#123;</span><br><span class="line">    Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">    Set&lt;String&gt; keys = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">String</span> <span class="variable">queryProtocols</span> <span class="operator">=</span> <span class="built_in">this</span>.queryMap.get(PROTOCOL_KEY);</span><br><span class="line">    <span class="keyword">for</span> (URL providerUrl : urls) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 过滤消费端不匹配的协议，及非法协议</span></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并服务提供端配置数据</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> mergeUrl(providerUrl);</span><br><span class="line">        <span class="comment">// 过滤重复的服务提供端配置数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> url.toFullString();</span><br><span class="line">        <span class="keyword">if</span> (keys.contains(key)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        keys.add(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存键是不与使用者端参数合并的url，无论使用者如何合并参数，如果服务器url更改，则再次引用</span></span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = <span class="built_in">this</span>.urlInvokerMap; <span class="comment">// local reference</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = localUrlInvokerMap == <span class="literal">null</span> ? <span class="literal">null</span> : localUrlInvokerMap.get(key);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 缓存无对应 invoker，再次调用 protocol#refer 是否有数据</span></span><br><span class="line">        <span class="keyword">if</span> (invoker == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">enabled</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (url.hasParameter(DISABLED_KEY)) &#123;</span><br><span class="line">                    enabled = !url.getParameter(DISABLED_KEY, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    enabled = url.getParameter(ENABLED_KEY, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">                    invoker = <span class="keyword">new</span> <span class="title class_">InvokerDelegate</span>&lt;&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Failed to refer invoker for interface:&quot;</span> + serviceType + <span class="string">&quot;,url:(&quot;</span> + url + <span class="string">&quot;)&quot;</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将新的 Invoker 缓存起来</span></span><br><span class="line">            <span class="keyword">if</span> (invoker != <span class="literal">null</span>) &#123; <span class="comment">// Put new invoker in cache</span></span><br><span class="line">                newUrlInvokerMap.put(key, invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 缓存里有数据，则进行重新覆盖</span></span><br><span class="line">            newUrlInvokerMap.put(key, invoker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    keys.clear();</span><br><span class="line">    <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>通过《Dubbo之服务暴露》和本文两篇文章对 Dubbo 服务暴露和服务消费原理的了解。我们可以看到，不管是暴露还是消费，Dubbo 都是以 Invoker 为数据交换主体进行，通过对 Invoker 发起调用，实现一个远程或本地的实现。</p>
</blockquote>
]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo 扩展点加载机制：从 Java SPI 到 Dubbo SPI</title>
    <url>/2020/03/22/19-dubbo-spi/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/iu.jpg"></p>
<p>SPI 全称为 Service Provider Interface，是一种服务发现机制。当程序运行调用接口时，会根据配置文件或默认规则信息加载对应的实现类。所以在程序中并没有直接指定使用接口的哪个实现，而是在外部进行装配。<br>要想了解 Dubbo 的设计与实现，其中 Dubbo SPI 加载机制是必须了解的，在 Dubbo 中有大量功能的实现都是基于 Dubbo SPI 实现解耦，同时也使得 Dubbo 获得如此好的可扩展性。</p>
<span id="more"></span>

<h1 id="Java-SPI"><a href="#Java-SPI" class="headerlink" title="Java SPI"></a>Java SPI</h1><p>通过完成一个 Java SPI 的操作来了解它的机制。</p>
<ul>
<li>创建一个 AnimalService 接口及 category 方法</li>
<li>创建一个实现类 Cat</li>
<li>创建 META-INF&#x2F;services 目录，并在该目录下创建一个文件，文件名为 AnimalService 的全限定名作为文件名</li>
<li>在文件中添加实现类 Cat 的全限定名</li>
</ul>
<p>Animal 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AnimalService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">category</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Cat 实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">AnimalService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">category</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat: Meow ~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 META-INF&#x2F;services 目录下的 top.ytao.demo.spi.AnimalService 文件中添加：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top.ytao.demo.spi.Cat</span><br></pre></td></tr></table></figure>

<p>加载 SPI 的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaSPITest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">javaSPI</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ServiceLoader&lt;AnimalService&gt; serviceLoader = ServiceLoader.load(AnimalService.class);</span><br><span class="line">        <span class="comment">// 遍历在配置文件中已配置的 AnimalService 的所有实现类</span></span><br><span class="line">        <span class="keyword">for</span> (AnimalService animalService : serviceLoader) &#123;</span><br><span class="line">            animalService.category();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://images.ytao.top/dubbo-java-spi.png"></p>
<p>就这样，一个 Java SPI 就实现完成了，通过 <code>ServiceLoader.load</code> 获取加载所有接口已配置的接口实现类，然后可以遍历找出需要的实现。</p>
<h1 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h1><p>本文 Dubbo 版本为<code>2.7.5</code><br>Dubbo SPI 相较于 Java SPI 更为强大，并且都是由自己实现的一套 SPI 机制。其中主要的改进和优化：</p>
<ul>
<li>相对于 Java SPI 一次性加载所有实现，Dubbo SPI 是按需加载，只加载需要使用的实现类。同时带有缓存支持。</li>
<li>更为详细的扩展加载失败信息。</li>
<li>增加了对扩展 IOC 和 AOP的支持。</li>
</ul>
<h2 id="Dubbo-SPI-示例"><a href="#Dubbo-SPI-示例" class="headerlink" title="Dubbo SPI 示例"></a>Dubbo SPI 示例</h2><p>Dubbo SPI 的配置文件放在 META-INF&#x2F;dubbo 下面，并且实现类的配置方式采用 K-V 的方式，key 为实例化对象传入的参数，value 为扩展点实现类全限定名。例如 Cat 的配置文件内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> = top.ytao.demo.spi.Cat</span><br></pre></td></tr></table></figure>

<p>Dubbo SPI 加载过程中，对 Java SPI 的目录也是可以被兼容的。</p>
<p>同时需要在接口上增加 @SPI 注解，@SPI 中可以指定 key 值，加载 SPI 如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboSPITest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dubboSPI</span><span class="params">()</span>&#123;</span><br><span class="line">        ExtensionLoader&lt;AnimalService&gt; extensionLoader = ExtensionLoader.getExtensionLoader(AnimalService.class);</span><br><span class="line">        <span class="comment">// 获取扩展类实现</span></span><br><span class="line">        <span class="type">AnimalService</span> <span class="variable">cat</span> <span class="operator">=</span> extensionLoader.getExtension(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Dubbo SPI&quot;</span>);</span><br><span class="line">        cat.category();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<p><img src="https://images.ytao.top/dubbo-dubbo-spi.png"></p>
<h3 id="获取-ExtensionLoader-实例"><a href="#获取-ExtensionLoader-实例" class="headerlink" title="获取 ExtensionLoader 实例"></a>获取 ExtensionLoader 实例</h3><p>获取 ExtensionLoader 实例是通过上面 getExtensionLoader 方法，具体实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ExtensionLoader&lt;T&gt; <span class="title function_">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension type == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查 type 必须为接口</span></span><br><span class="line">    <span class="keyword">if</span> (!type.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension type (&quot;</span> + type + <span class="string">&quot;) is not an interface!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查接口是否有 SPI 注解</span></span><br><span class="line">    <span class="keyword">if</span> (!withExtensionAnnotation(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension type (&quot;</span> + type +</span><br><span class="line">                <span class="string">&quot;) is not an extension, because it is NOT annotated with @&quot;</span> + SPI.class.getSimpleName() + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存中获取 ExtensionLoader 实例</span></span><br><span class="line">    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 加载 ExtensionLoader 实例到缓存中</span></span><br><span class="line">        EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> <span class="title class_">ExtensionLoader</span>&lt;T&gt;(type));</span><br><span class="line">        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面获取扩展类加载器过程主要是检查传入的 type 是否合法，以及从扩展类加载器缓存中是否存在当前类型的接口，如果不存在则添加当前接口至缓存中。<br><code>ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS</code> 是扩展类加载器的缓存，它是以接口作为 key， 扩展类加载器作为 value 进行缓存。</p>
<h3 id="获取扩展类对象"><a href="#获取扩展类对象" class="headerlink" title="获取扩展类对象"></a>获取扩展类对象</h3><p>获取扩展类对象的方法<code>ExtensionLoader#getExtension</code>，在这里完成扩展对象的缓存及创建工作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getExtension</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension name == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果传入的参数为 true ，则获取默认扩展类对象操作</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;true&quot;</span>.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取扩展对象，Holder 里的 value 属性保存着扩展对象实例</span></span><br><span class="line">    <span class="keyword">final</span> Holder&lt;Object&gt; holder = getOrCreateHolder(name);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> holder.get();</span><br><span class="line">    <span class="comment">// 使用双重检查锁</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">            instance = holder.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建扩展对象</span></span><br><span class="line">                instance = createExtension(name);</span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取 holder 对象是从缓存<code>ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances</code>中获取，如果不存在，则以扩展名 key，创建一个 Holder 对象作为 value，设置到扩展对象缓存。<br>如果是新创建的扩展对象实例，那么 holder.get() 一定是 null ，扩展对象为空时，经过双重检查锁，创建扩展对象。</p>
<h3 id="创建扩展对象"><a href="#创建扩展对象" class="headerlink" title="创建扩展对象"></a>创建扩展对象</h3><p>创建扩展对象过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">createExtension</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 从全部扩展类中，获取当前扩展名对应的扩展类</span></span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从缓存中获取扩展实例，及设置扩展实例缓存</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向当前实例注入依赖</span></span><br><span class="line">        injectExtension(instance);</span><br><span class="line">        <span class="comment">// 获取包装扩展类缓存</span></span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClasses)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">                <span class="comment">// 创建包装扩展类实例，并向其注入依赖</span></span><br><span class="line">                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化扩展对象</span></span><br><span class="line">        initExtension(instance);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Extension instance (name: &quot;</span> + name + <span class="string">&quot;, class: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;) couldn&#x27;t be instantiated: &quot;</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面创建扩展过程中，里面有个 Wrapper 类，这里使用到装饰器模式，该类是没有具体的实现，而是把通用逻辑进行抽象。<br>创建这个过程是从所有扩展类中获取当前扩展名对应映射关系的扩展类，以及向当前扩展对象注入依赖。</p>
<p>获取所有扩展类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">    <span class="comment">// 获取普通扩展类缓存</span></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">    <span class="comment">// 如果缓存中没有，通过双重检查锁后进行加载</span></span><br><span class="line">    <span class="keyword">if</span> (classes == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">            classes = cachedClasses.get();</span><br><span class="line">            <span class="keyword">if</span> (classes == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 加载全部扩展类</span></span><br><span class="line">                classes = loadExtensionClasses();</span><br><span class="line">                cachedClasses.set(classes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查普通扩展类缓存是否为空，如果不为空则重新加载，真正加载扩展类在<code>loadExtensionClasses</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVICES_DIRECTORY</span> <span class="operator">=</span> <span class="string">&quot;META-INF/services/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DUBBO_DIRECTORY</span> <span class="operator">=</span> <span class="string">&quot;META-INF/dubbo/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DUBBO_INTERNAL_DIRECTORY</span> <span class="operator">=</span> DUBBO_DIRECTORY + <span class="string">&quot;internal/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">    <span class="comment">// 获取 @SPI 上的默认扩展名</span></span><br><span class="line">    cacheDefaultExtensionName();</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 先加载 Dubbo 内部的扩展类， 通过 Boolean 值控制</span></span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName(), <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 由于 Dubbo 迁到 apache ，所以包名有变化，会替换之前的 alibaba 为 apache</span></span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName().replace(<span class="string">&quot;org.apache&quot;</span>, <span class="string">&quot;com.alibaba&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName());</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName().replace(<span class="string">&quot;org.apache&quot;</span>, <span class="string">&quot;com.alibaba&quot;</span>));</span><br><span class="line">    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName());</span><br><span class="line">    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName().replace(<span class="string">&quot;org.apache&quot;</span>, <span class="string">&quot;com.alibaba&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> extensionClasses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面获取 @SPI 扩展名，以及指定要加载的文件。从上面静态常量中，我们可以看到，Dubbo SPI 也是支持加载 Java SPI 的目录，同时还加载 META-INF&#x2F;dubbo&#x2F;internal (该目录为 Dubbo 的内部扩展类目录)，在 loadDirectory 加载目录配置文件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadDirectory</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir, String type, <span class="type">boolean</span> extensionLoaderClassLoaderFirst)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取文件在项目中的路径，如：META-INF/dubbo/top.ytao.demo.spi.AnimalService</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> dir + type;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;java.net.URL&gt; urls = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> findClassLoader();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载内部扩展类</span></span><br><span class="line">        <span class="keyword">if</span> (extensionLoaderClassLoaderFirst) &#123;</span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">extensionLoaderClassLoader</span> <span class="operator">=</span> ExtensionLoader.class.getClassLoader();</span><br><span class="line">            <span class="keyword">if</span> (ClassLoader.getSystemClassLoader() != extensionLoaderClassLoader) &#123;</span><br><span class="line">                urls = extensionLoaderClassLoader.getResources(fileName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载当前 fileName 文件</span></span><br><span class="line">        <span class="keyword">if</span>(urls == <span class="literal">null</span> || !urls.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">                urls = classLoader.getResources(fileName);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                urls = ClassLoader.getSystemResources(fileName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (urls != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 迭代加载同名文件的内容</span></span><br><span class="line">            <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">                java.net.<span class="type">URL</span> <span class="variable">resourceURL</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">                <span class="comment">// 加载文件内容</span></span><br><span class="line">                loadResource(extensionClasses, classLoader, resourceURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Exception occurred when loading extension class (interface: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;, description file: &quot;</span> + fileName + <span class="string">&quot;).&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里获取文件名后加载所有同名文件，然后迭代各个文件，逐个加载文件内容。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadResource</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, ClassLoader classLoader, java.net.URL resourceURL)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(resourceURL.openStream(), StandardCharsets.UTF_8))) &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="comment">// 整行读取文件内容</span></span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取当前行中第一个 &quot;#&quot; 的位置索引</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ci</span> <span class="operator">=</span> line.indexOf(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">                <span class="comment">// 如果当前行存在 &quot;#&quot;,则去除 &quot;#&quot; 后的内容</span></span><br><span class="line">                <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    line = line.substring(<span class="number">0</span>, ci);</span><br><span class="line">                &#125;</span><br><span class="line">                line = line.trim();</span><br><span class="line">                <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 获取当前行 &quot;=&quot; 的索引</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> line.indexOf(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">                        <span class="comment">// 如果当前行存在 &quot;=&quot;，将 &quot;=&quot; 左右的值分开复制给 name 和 line</span></span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            name = line.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">                            line = line.substring(i + <span class="number">1</span>).trim();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 加载扩展类</span></span><br><span class="line">                            loadClass(extensionClasses, resourceURL, Class.forName(line, <span class="literal">true</span>, classLoader), name);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        <span class="type">IllegalStateException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to load extension class (interface: &quot;</span> + type + <span class="string">&quot;, class line: &quot;</span> + line + <span class="string">&quot;) in &quot;</span> + resourceURL + <span class="string">&quot;, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">                        exceptions.put(line, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Exception occurred when loading extension class (interface: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;, class file: &quot;</span> + resourceURL + <span class="string">&quot;) in &quot;</span> + resourceURL, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码完成文件内容加载和解析，接下来通过 <code>loadClass</code> 加载扩展类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadClass</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">    <span class="comment">// 检查当前实现类是否实现了 type 接口</span></span><br><span class="line">    <span class="keyword">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Error occurred when loading extension class (interface: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;, class line: &quot;</span> + clazz.getName() + <span class="string">&quot;), class &quot;</span></span><br><span class="line">                + clazz.getName() + <span class="string">&quot; is not subtype of interface.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前实现类是否有 Adaptive 注解</span></span><br><span class="line">    <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">        cacheAdaptiveClass(clazz);</span><br><span class="line">    <span class="comment">// 当前类是否为 Wrapper 包装扩展类 </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">        cacheWrapperClass(clazz);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试当前类是否有无参构造方法</span></span><br><span class="line">        clazz.getConstructor();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">            <span class="comment">// 如果 name 为空，则获取 clazz 的 @Extension 注解的值，如果注解值也没有，则使用小写类名</span></span><br><span class="line">            name = findAnnotationName(clazz);</span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No such extension name for the class &quot;</span> + clazz.getName() + <span class="string">&quot; in the config &quot;</span> + resourceURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">        <span class="keyword">if</span> (ArrayUtils.isNotEmpty(names)) &#123;</span><br><span class="line">            <span class="comment">// 缓存 扩展名和@Activate的缓存</span></span><br><span class="line">            cacheActivateClass(clazz, names[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line">                <span class="comment">// 缓存 扩展类和扩展名的缓存</span></span><br><span class="line">                cacheName(clazz, n);</span><br><span class="line">                <span class="comment">// 将 扩展类和扩展名 保存到extensionClasses 扩展名-&gt;扩展类 关系映射中</span></span><br><span class="line">                saveInExtensionClass(extensionClasses, clazz, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，getExtensionClasses() 加载扩展类方法分析完成，接下分析注入依赖 injectExtension() 方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">injectExtension</span><span class="params">(T instance)</span> &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (objectFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">            <span class="comment">// 遍历当前扩展类的全部方法，如果当前方法不属于 setter 方法，</span></span><br><span class="line">            <span class="comment">// 即不是以 &#x27;set&#x27;开头的方法名，参数不是一个的，该方法访问级别不是 public 的，则不往下执行</span></span><br><span class="line">            <span class="keyword">if</span> (!isSetter(method)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当前方法是否添加了不要注入依赖的注解</span></span><br><span class="line">            <span class="keyword">if</span> (method.getAnnotation(DisableInject.class) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 判断当前参数是否属于 八个基本类型或void</span></span><br><span class="line">            <span class="keyword">if</span> (ReflectUtils.isPrimitives(pt)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通过属性 setter 方法获取属性名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> getSetterProperty(method);</span><br><span class="line">                <span class="comment">// 获取依赖对象</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> objectFactory.getExtension(pt, property);</span><br><span class="line">                <span class="keyword">if</span> (object != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 设置依赖</span></span><br><span class="line">                    method.invoke(instance, object);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Failed to inject via method &quot;</span> + method.getName()</span><br><span class="line">                        + <span class="string">&quot; of interface &quot;</span> + type.getName() + <span class="string">&quot;: &quot;</span> + e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过遍历扩展类所有方法，找到相对应的依赖，然后使用反射调用 settter 方法来进行设置依赖。<br>objectFactory 对象如图：</p>
<p><img src="https://images.ytao.top/dubbo-objectFactory.png"></p>
<p>其中找到相应依赖是在 SpiExtensionFactory 或 SpringExtensionFactory 中，同时，这两个 Factory 保存在 AdaptiveExtensionFactory 中进行维护。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdaptiveExtensionFactory</span> <span class="keyword">implements</span> <span class="title class_">ExtensionFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ExtensionFactory&gt; factories;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AdaptiveExtensionFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过遍历匹配到 type-&gt;name 的映射</span></span><br><span class="line">        <span class="keyword">for</span> (ExtensionFactory factory : factories) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">extension</span> <span class="operator">=</span> factory.getExtension(type, name);</span><br><span class="line">            <span class="keyword">if</span> (extension != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> extension;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是对 Dubbo SPI 扩展类简单加载过程分析完成。</p>
<h2 id="自适应加载机制"><a href="#自适应加载机制" class="headerlink" title="自适应加载机制"></a>自适应加载机制</h2><p>为 Dubbo 更加灵活的使一个接口不通过硬编码加载扩展机制，而是通过使用过程中进行加载，Dubbo 的另一加载机制——自适应加载。<br>自适应加载机制使用 @Adaptive 标注：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Adaptive &#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Adaptive 的值是一个数组，可以配置多个 key。初始化时，遍历所有 key 进行匹配，如果没有则匹配 @SPI 的值。<br>当 Adaptive 注解标注在类上时，则简单对应该实现。如果注解标注在接口方法上时，则会根据参数动态生成代码来获取扩展点的实现。<br>类上注解处理还是比较好理解，方法上的注解加载相对比较有研读性。通过调用<code>ExtensionLoader#getAdaptiveExtension</code>来进行获取扩展实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getAdaptiveExtension</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取实例化对象缓存</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> cachedAdaptiveInstance.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (createAdaptiveInstanceError != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to create adaptive instance: &quot;</span> +</span><br><span class="line">                    createAdaptiveInstanceError.toString(),</span><br><span class="line">                    createAdaptiveInstanceError);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 双重检查锁后创建自适应扩展</span></span><br><span class="line">        <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">            instance = cachedAdaptiveInstance.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 创建自适应扩展</span></span><br><span class="line">                    instance = createAdaptiveExtension();</span><br><span class="line">                    cachedAdaptiveInstance.set(instance);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    createAdaptiveInstanceError = t;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to create adaptive instance: &quot;</span> + t.toString(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">createAdaptiveExtension</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取自适应扩展后，注入依赖</span></span><br><span class="line">        <span class="keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Can&#x27;t create adaptive extension &quot;</span> + type + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码完成了扩展类对象是否存在缓存中，如果不存在，则通过创建自适应扩展，并将实例注入依赖后，设置在实例化后的自适应扩展对象中。<br>其中<code>getAdaptiveExtensionClass</code>是比较核心的流程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">    <span class="comment">// 加载全部扩展类</span></span><br><span class="line">    getExtensionClasses();</span><br><span class="line">    <span class="comment">// 加载全部扩展类后，如果有 @Adaptive 标注的类，cachedAdaptiveClass 则一定不会为空</span></span><br><span class="line">    <span class="keyword">if</span> (cachedAdaptiveClass != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedAdaptiveClass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建自适应扩展类</span></span><br><span class="line">    <span class="type">return</span> <span class="variable">cachedAdaptiveClass</span> <span class="operator">=</span> createAdaptiveExtensionClass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">    <span class="comment">// 生成自适应扩展代码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdaptiveClassCodeGenerator</span>(type, cachedDefaultName).generate();</span><br><span class="line">    <span class="comment">// 获取扩展类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> findClassLoader();</span><br><span class="line">    <span class="comment">// 获取编译器类型的实现类</span></span><br><span class="line">    org.apache.dubbo.common.compiler.<span class="type">Compiler</span> <span class="variable">compiler</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class="line">    <span class="comment">// 编译代码，返回该对象</span></span><br><span class="line">    <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里完成的工作主要是，加载全部扩展类，代表所有扩展接口类的实现类，在其加载过程中，如果有 @Adaptive 标注的类，会保存到 cachedAdaptiveClass 中。通过自动生成自适应扩展代码，并被编译后，获取扩展类实例化对象。<br>上面编译器类型是可以指定的，通过 compiler 进行指定，例如：<code>&lt;dubbo:application name=&quot;taomall-provider&quot; compiler=&quot;jdk&quot; /&gt;</code>，该编译器默认使用 javassist 编译器。</p>
<p>在 generate 方法中动态生成代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">generate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 检查当前扩展接口的方法上是否有 Adaptive 注解</span></span><br><span class="line">    <span class="keyword">if</span> (!hasAdaptiveMethod()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No adaptive method exist on extension &quot;</span> + type.getName() + <span class="string">&quot;, refuse to create the adaptive class!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成代码</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">// 生成类的包名</span></span><br><span class="line">    code.append(generatePackageInfo());</span><br><span class="line">    <span class="comment">// 生成类的依赖类</span></span><br><span class="line">    code.append(generateImports());</span><br><span class="line">    <span class="comment">// 生成类的声明信息</span></span><br><span class="line">    code.append(generateClassDeclaration());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成方法</span></span><br><span class="line">    Method[] methods = type.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        code.append(generateMethod(method));</span><br><span class="line">    &#125;</span><br><span class="line">    code.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(code.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> code.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是生成类信息的方法，生成设计原理是按照已设置好的模板，进行替换操作，生成类。具体信息不代码很多，但阅读还是比较简单。<br>自适应加载机制，已简单分析完，咋一眼看，非常复杂，但是了解整体结构和流程，再去细研的话，相对还是好理解。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从 Dubbo 设计来看，其良好的扩展性，比较重要的一点是得益于 Dubbo SPI 加载机制。在学习它的设计理念，对可扩展性方面的编码思考也有一定的启发。</p>
]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
        <tag>Java</tag>
        <tag>SPI</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis之启动分析（一）</title>
    <url>/2019/09/22/1_mybatis%E4%B9%8B%E5%90%AF%E5%8A%A8%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/banner1.jpeg" alt="ytao"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="">MyBatis</a> 作为目前最常用的持久层框架之一，分析其源码，对我们的使用过程中可更好的运用它。本系列基于<code>mybatis-3.4.6</code>进行分析。<br>MyBatis 的初始化工作就是解析主配置文件，映射配置文件以及注解信息。然后保存在<code>org.apache.ibatis.session.Configuration</code>，供后期执行数据请求的相关调用。<br><code>Configuration</code> 里有大量配置信息，在后面每涉及到一个相关配置，会进行详细的分析。</p>
<span id="more"></span>

<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 获取配置文件</span></span><br><span class="line">    <span class="type">Reader</span> <span class="variable">reader</span> <span class="operator">=</span> Resources.getResourceAsReader(<span class="string">&quot;mybatis-config.xml&quot;</span>);</span><br><span class="line">    <span class="comment">// 通过 SqlSessionFactoryBuilder 构建 sqlSession 工厂</span></span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(reader);</span><br><span class="line">    <span class="comment">// 获取 sqlSession 实例</span></span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">    reader.close();</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="SqlSessionFactoryBuilder-类"><a href="#SqlSessionFactoryBuilder-类" class="headerlink" title="SqlSessionFactoryBuilder 类"></a>SqlSessionFactoryBuilder 类</h3><p>SqlSessionFactoryBuilder 的<code>build()</code>是Mybatis启动的初始化入口，使用builder模式加载配置文件。<br>通过查看该类，使用方法重载，有以下9个方法：<br><img src="https://images.ytao.top/SqlSessionFactoryBuilde_201909.png" alt="SqlSessionFactoryBuilde类中的方法"></p>
<p>方法重载最终实现处理的方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Reader reader, String environment, Properties properties)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 实例化 XMLConfigBuilder，用于读取配置文件信息</span></span><br><span class="line">      <span class="type">XMLConfigBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLConfigBuilder</span>(reader, environment, properties);</span><br><span class="line">      <span class="comment">// 解析配置信息，保存到 Configuration</span></span><br><span class="line">      <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error building SqlSession.&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        reader.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>environment 是指定加载环境，默认值为 null。</li>
<li>properties 是属性配置文件，默认值为 null。<br>同时读取配置文件既可字符流读取，也支持字节流读取。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">XMLConfigBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLConfigBuilder</span>(inputStream, environment, properties);</span><br><span class="line">      <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error building SqlSession.&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        inputStream.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="实例化-XMLConfigBuilder-类"><a href="#实例化-XMLConfigBuilder-类" class="headerlink" title="实例化 XMLConfigBuilder 类"></a>实例化 XMLConfigBuilder 类</h3><p>通过 SqlSessionFactoryBuilder 中 <code>XMLConfigBuilder parser = new XMLConfigBuilder(reader, environment, properties)</code>, 分析 XMLConfigBuilder实例化过程。<br>该类中有四个变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> parsed;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> XPathParser parser;</span><br><span class="line"><span class="keyword">private</span> String environment;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReflectorFactory</span> <span class="variable">localReflectorFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultReflectorFactory</span>();</span><br></pre></td></tr></table></figure>
<ul>
<li>parsed 是否解析，一次解析即可。用于标志配置文件只解析一次，<code>true</code>为已解析过。</li>
<li>parser 解析配置的解析器</li>
<li>environment 加载环境，即 <code>SqlSessionFactoryBuilder</code> 中的 <code>environment</code></li>
<li>localReflectorFactory 用于创建和缓存<code>Reflector</code>对象，一个类对应一个<code>Reflector</code>。因为参数处理、结果映射等操作时，会涉及大量的反射操作。<code>DefaultReflectorFactory</code>实现类比较简单，这里不再进行讲解。</li>
</ul>
<p><strong>XMLConfigBuilder</strong>构建函数实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">XMLConfigBuilder</span><span class="params">(Reader reader, String environment, Properties props)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(<span class="keyword">new</span> <span class="title class_">XPathParser</span>(reader, <span class="literal">true</span>, props, <span class="keyword">new</span> <span class="title class_">XMLMapperEntityResolver</span>()), environment, props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="实例化-XPathParser-对象"><a href="#实例化-XPathParser-对象" class="headerlink" title="实例化 XPathParser 对象"></a>实例化 <code>XPathParser</code> 对象</h4><p>首先实例化 <code>XPathParser</code> 对象，里面定义了5个变量:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Document document;</span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> validation;</span><br><span class="line"><span class="keyword">private</span> EntityResolver entityResolver;</span><br><span class="line"><span class="keyword">private</span> Properties variables;</span><br><span class="line"><span class="keyword">private</span> XPath xpath;</span><br></pre></td></tr></table></figure>
<ul>
<li>document 保存document对象</li>
<li>validation xml解析时是否验证文档</li>
<li>entityResolver 加载dtd文件</li>
<li>variables 配置文件定义<properties>的值</li>
<li>xpath Xpath对象，用于对XML文件节点的操作</li>
</ul>
<p><code>XPathParser</code> 对象构造函数有：<br><img src="https://images.ytao.top/XPathParser%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png" alt="XPathParser构造方法"><br>函数里面都处理了两件事：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">XPathParser</span><span class="params">(Reader reader, <span class="type">boolean</span> validation, Properties variables, EntityResolver entityResolver)</span> &#123;</span><br><span class="line">    commonConstructor(validation, variables, entityResolver);</span><br><span class="line">    <span class="built_in">this</span>.document = createDocument(<span class="keyword">new</span> <span class="title class_">InputSource</span>(reader));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>初始化赋值，和创建<code>XPath</code>对象，用于对XML文件节点的操作。<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">commonConstructor</span><span class="params">(<span class="type">boolean</span> validation, Properties variables, EntityResolver entityResolver)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.validation = validation;</span><br><span class="line">    <span class="built_in">this</span>.entityResolver = entityResolver;</span><br><span class="line">    <span class="built_in">this</span>.variables = variables;</span><br><span class="line">    <span class="comment">// 创建Xpath对象，用于对XML文件节点的操作</span></span><br><span class="line">    <span class="type">XPathFactory</span> <span class="variable">factory</span> <span class="operator">=</span> XPathFactory.newInstance();</span><br><span class="line">    <span class="built_in">this</span>.xpath = factory.newXPath();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建<code>Document</code>对象并赋值到<code>document</code>变量, 这里属于Document创建的操作,不再详细讲述，不懂可以点击这里查看<a href="https://docs.oracle.com/javase/8/docs/api/org/w3c/dom/Document.html?is-external=true">API</a><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Document <span class="title function_">createDocument</span><span class="params">(InputSource inputSource)</span> &#123;</span><br><span class="line">    <span class="comment">// important: this must only be called AFTER common constructor</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 实例化 DocumentBuilderFactory 对象，用于创建 DocumentBuilder 对象</span></span><br><span class="line">      <span class="type">DocumentBuilderFactory</span> <span class="variable">factory</span> <span class="operator">=</span> DocumentBuilderFactory.newInstance();</span><br><span class="line">      <span class="comment">// 是否校验文档</span></span><br><span class="line">      factory.setValidating(validation);</span><br><span class="line">      <span class="comment">// 设置 DocumentBuilderFactory 的配置</span></span><br><span class="line">      factory.setNamespaceAware(<span class="literal">false</span>);</span><br><span class="line">      factory.setIgnoringComments(<span class="literal">true</span>);</span><br><span class="line">      factory.setIgnoringElementContentWhitespace(<span class="literal">false</span>);</span><br><span class="line">      factory.setCoalescing(<span class="literal">false</span>);</span><br><span class="line">      factory.setExpandEntityReferences(<span class="literal">true</span>);</span><br><span class="line">      <span class="comment">// 创建 DocumentBuilder</span></span><br><span class="line">      <span class="type">DocumentBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> factory.newDocumentBuilder();</span><br><span class="line">      builder.setEntityResolver(entityResolver);</span><br><span class="line">      builder.setErrorHandler(<span class="keyword">new</span> <span class="title class_">ErrorHandler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">error</span><span class="params">(SAXParseException exception)</span> <span class="keyword">throws</span> SAXException &#123;</span><br><span class="line">          <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fatalError</span><span class="params">(SAXParseException exception)</span> <span class="keyword">throws</span> SAXException &#123;</span><br><span class="line">          <span class="keyword">throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">warning</span><span class="params">(SAXParseException exception)</span> <span class="keyword">throws</span> SAXException &#123;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 加载文件</span></span><br><span class="line">      <span class="keyword">return</span> builder.parse(inputSource);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error creating document instance.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="XMLConfigBuilder构造函数赋值"><a href="#XMLConfigBuilder构造函数赋值" class="headerlink" title="XMLConfigBuilder构造函数赋值"></a><code>XMLConfigBuilder</code>构造函数赋值</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">XMLConfigBuilder</span><span class="params">(XPathParser parser, String environment, Properties props)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">Configuration</span>());</span><br><span class="line">    ErrorContext.instance().resource(<span class="string">&quot;SQL Mapper Configuration&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.configuration.setVariables(props);</span><br><span class="line">    <span class="built_in">this</span>.parsed = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.environment = environment;</span><br><span class="line">    <span class="built_in">this</span>.parser = parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>初始化父类<code>BaseBuilder</code>的值。</li>
<li>将外部值赋值给对象。</li>
<li>将实例化的<code>XPathParser</code>赋值给<code>parser</code>。</li>
</ol>
<p>最后返回<code>XMLConfigBuilder</code>对象。</p>
<h3 id="解析-XMLConfigBuilder-对象"><a href="#解析-XMLConfigBuilder-对象" class="headerlink" title="解析 XMLConfigBuilder 对象"></a>解析 XMLConfigBuilder 对象</h3><p>通过 <code>XMLConfigBuilder.parse()</code> 解析配置信息，保存至<code>Configuration</code>。解析详解在后面文章中进行分析。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Configuration <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 是否解析过配置文件</span></span><br><span class="line">    <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Each XMLConfigBuilder can only be used once.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标志解析过，定义为 true</span></span><br><span class="line">    parsed = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 解析 configuration 节点中的信息</span></span><br><span class="line">    parseConfiguration(parser.evalNode(<span class="string">&quot;/configuration&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建-SqlSessionFactory"><a href="#创建-SqlSessionFactory" class="headerlink" title="创建 SqlSessionFactory"></a>创建 SqlSessionFactory</h3><p><code>DefaultSqlSessionFactory</code>实现了<code>SqlSessionFactory</code>接口。<br>通过上面解析得到的<code>Configuration</code>，调用<code>SqlSessionFactoryBuilder.build(Configuration config)</code>创建一个 <code>DefaultSqlSessionFactory</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSessionFactory <span class="title function_">build</span><span class="params">(Configuration config)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSessionFactory</span>(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实例化<code>DefaultSqlSessionFactory</code>的过程，就是将<code>Configuration</code>传递给<code>DefaultSqlSessionFactory</code>成员变量<code>configuration</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">DefaultSqlSessionFactory</span><span class="params">(Configuration configuration)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.configuration = configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建-SqlSession"><a href="#创建-SqlSession" class="headerlink" title="创建 SqlSession"></a>创建 SqlSession</h3><p>通过调用<code>SqlSessionFactory.openSession()</code>创建<code>SqlSession</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SqlSessionFactory</span> &#123;</span><br><span class="line">  <span class="comment">// 默认创建</span></span><br><span class="line">  SqlSession <span class="title function_">openSession</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  SqlSession <span class="title function_">openSession</span><span class="params">(<span class="type">boolean</span> autoCommit)</span>;</span><br><span class="line">  SqlSession <span class="title function_">openSession</span><span class="params">(Connection connection)</span>;</span><br><span class="line">  SqlSession <span class="title function_">openSession</span><span class="params">(TransactionIsolationLevel level)</span>;</span><br><span class="line"></span><br><span class="line">  SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType)</span>;</span><br><span class="line">  SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, <span class="type">boolean</span> autoCommit)</span>;</span><br><span class="line">  SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level)</span>;</span><br><span class="line">  SqlSession <span class="title function_">openSession</span><span class="params">(ExecutorType execType, Connection connection)</span>;</span><br><span class="line"></span><br><span class="line">  Configuration <span class="title function_">getConfiguration</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>autoCommit 是否自动提交事务，</li>
<li>level 事务隔离级别（共5个级别）， 可查看相关源码</li>
<li>connection 连接</li>
<li>execType 执行器的类型：<code>SIMPLE</code>(不做特殊处理), <code>REUSE</code>（复用预处理语句）, <code>BATCH</code>（会批量执行）</li>
</ul>
<p>因为上面<code>DefaultSqlSessionFactory</code>实现了<code>SqlSessionFactory</code>接口，所以进入到<code>DefaultSqlSessionFactory</code>查看<code>openSession()</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> SqlSession <span class="title function_">openSession</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> openSessionFromDataSource(configuration.getDefaultExecutorType(), <span class="literal">null</span>, <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>openSession()</code>方法最终实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> SqlSession <span class="title function_">openSessionFromDataSource</span><span class="params">(ExecutorType execType, TransactionIsolationLevel level, <span class="type">boolean</span> autoCommit)</span> &#123;</span><br><span class="line">    <span class="type">Transaction</span> <span class="variable">tx</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取configuration中的加载环境</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> configuration.getEnvironment();</span><br><span class="line">      <span class="comment">// 获取事务工厂</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">TransactionFactory</span> <span class="variable">transactionFactory</span> <span class="operator">=</span> getTransactionFactoryFromEnvironment(environment);</span><br><span class="line">      <span class="comment">// 创建一个事务</span></span><br><span class="line">      tx = transactionFactory.newTransaction(environment.getDataSource(), level, autoCommit);</span><br><span class="line">      <span class="comment">// 生成一个处理器，事务保存在处理器 BaseExecutor 中</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">Executor</span> <span class="variable">executor</span> <span class="operator">=</span> configuration.newExecutor(tx, execType);</span><br><span class="line">      <span class="comment">// 实例化一个 DefaultSqlSession，DefaultSqlSession实现了SqlSession接口</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultSqlSession</span>(configuration, executor, autoCommit);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="comment">// 异常情况下关闭事务</span></span><br><span class="line">      closeTransaction(tx); <span class="comment">// may have fetched a connection so lets call close()</span></span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">&quot;Error opening session.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// 充值错误实例上下文</span></span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成处理器<code>Configuration.newExecutor(Transaction transaction, ExecutorType executorType)</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Executor <span class="title function_">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> &#123;</span><br><span class="line">    <span class="comment">// 默认为 ExecutorType.SIMPLE</span></span><br><span class="line">    executorType = executorType == <span class="literal">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="literal">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">BatchExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">ReuseExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">SimpleExecutor</span>(<span class="built_in">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">CachingExecutor</span>(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以<code>ExecutorType.SIMPLE</code>为例, <code>BatchExecutor</code>, <code>ReuseExecutor</code>同理：<br><img src="https://images.ytao.top/SimpleExecutor%E7%88%B6%E7%B1%BB%E5%9B%BE.png" alt="SimpleExecutor父类图"><br>至此，mybatis的启动流程大致简单的介绍到这里，对mybatis的启动初始化有个大致了解。接下将会针对单独模块进行详细分析。</p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>你必须会的 JDK 动态代理和 CGLIB 动态代理</title>
    <url>/2020/04/05/20-java-proxy/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/dynamic-prox.jpg"></p>
<p>我们在阅读一些 Java 框架的源码时，基本上常会看到使用动态代理机制，它可以无感的对既有代码进行方法的增强，使得代码拥有更好的拓展性。<br>通过从静态代理、JDK 动态代理、CGLIB 动态代理来进行本文的分析。</p>
<span id="more"></span>

<h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>静态代理就是在程序运行之前，代理类字节码<code>.class</code>就已编译好，通常一个静态代理类也只代理一个目标类，代理类和目标类都实现相同的接口。<br>接下来就先通过 demo 进行分析什么是静态代理，当前创建一个 Animal 接口，里面包含<code>call</code>函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建目标类 Cat，同时实现 Animal 接口，下面是 Cat 发出叫声的实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喵喵喵 ~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 Cat 叫之前是因为肚子饿了，所以我们需要在目标对象方法<code>Cat#call</code>之前说明是饥饿，这是使用静态代理实现猫饥饿然后发出叫声。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.proxy.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.ytao.demo.proxy.Animal;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxyAnimal</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Animal impl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StaticProxyAnimal</span><span class="params">(Animal impl)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫饥饿&quot;</span>);</span><br><span class="line">        impl.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过调用静态代理实现猫饥饿和叫行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">staticProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">staticProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticProxyAnimal</span>(<span class="keyword">new</span> <span class="title class_">Cat</span>());</span><br><span class="line">        staticProxy.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>


<p>执行结果</p>
<p><img src="https://images.ytao.top/java-proxy-static.png"></p>
<p>代理类、目标类、接口之间关系如图：</p>
<p><img src="https://images.ytao.top/java-proxy-static-class.png"></p>
<p>以上内容可以看到代理类中通过持有目标类对象，然后通过调用目标类的方法，实现静态代理。<br>静态代理虽然实现了代理，但在一些情况下存在比较明显不足之处：</p>
<ol>
<li>当我们在 Animal 接口中增加方法，这时不仅实现类 Cat 需要新增该方法的实现，同时，由于代理类实现了 Animal 接口，所以代理类也必须实现 Animal 新增的方法，这对项目规模较大时，在维护上就不太友好了。</li>
<li>代理类实现<code>Animal#call</code>是针对 Cat 目标类的对象进行设置的，如果再需要添加 Dog 目标类的代理，那就必须再针对 Dog 类实现一个对应的代理类，这样就使得代理类的重用型不友好，并且过多的代理类对维护上也是比较繁琐。</li>
</ol>
<p>上面问题，在 JDk 动态代理中就得到了较友好的解决。</p>
<h1 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h1><p>动态代理类与静态代理类最主要不同的是，代理类的字节码不是在程序运行前生成的，而是在程序运行时再虚拟机中程序自动创建的。<br>继续用上面 Cat 类和 Animal 接口实现 JDK 动态代理。</p>
<h2 id="实现-InvocationHandler-接口"><a href="#实现-InvocationHandler-接口" class="headerlink" title="实现 InvocationHandler 接口"></a>实现 InvocationHandler 接口</h2><p>JDK 动态代理类必须实现反射包中的 java.lang.reflect.InvocationHandler 接口，在此接口中只有一个 invoker 方法：</p>
<p><img src="https://images.ytao.top/java-proxy-invocationHandler.png"></p>
<p>在<code>InvocationHandler#invoker</code>中必须调用目标类被代理的方法，否则无法做到代理的实现。下面为实现 InvocationHandler 的代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetInvoker</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 代理中持有的目标类</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TargetInvoker</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;jdk 代理执行前&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;jdk 代理执行后&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实现<code>InvocationHandler#invoker</code>时，该方法里有三个参数：</p>
<ul>
<li>proxy 代理目标对象的代理对象，它是真实的代理对象。</li>
<li>method 执行目标类的方法</li>
<li>args 执行目标类的方法的参数</li>
</ul>
<h2 id="创建-JDK-动态代理类"><a href="#创建-JDK-动态代理类" class="headerlink" title="创建 JDK 动态代理类"></a>创建 JDK 动态代理类</h2><p>创建 JDK 动态代理类实例同样也是使用反射包中的 java.lang.reflect.Proxy 类进行创建。通过调用<code>Proxy#newProxyInstance</code>静态方法进行创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyAnimal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object target)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">// 指定目标类的类加载</span></span><br><span class="line">                target.getClass().getInterfaces(),  <span class="comment">// 代理需要实现的接口，可指定多个，这是一个数组</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TargetInvoker</span>(target)   <span class="comment">// 代理对象处理器</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Proxy#newProxyInstance</code>中的三个参数（ClassLoader loader、Class&lt;?&gt;[] interfaces、InvocationHandler h）：</p>
<ul>
<li>loader 加载代理对象的类加载器</li>
<li>interfaces 代理对象实现的接口，与目标对象实现同样的接口</li>
<li>h 处理代理对象逻辑的处理器，即上面的 InvocationHandler 实现类。</li>
</ul>
<p>最后实现执行 DynamicProxyAnimal 动态代理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dynamicProxy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">proxy</span> <span class="operator">=</span> (Animal) DynamicProxyAnimal.getProxy(cat);</span><br><span class="line">        proxy.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://images.ytao.top/java-proxy-jdk-test.png"></p>
<p>通过上面的代码，有两个问题：代理类是怎么创建的和代理类怎么调用方法的？</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从<code>Proxy#newProxyInstance</code>入口进行源码分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找或生成指定的代理类</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取代理的构造器</span></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">ih</span> <span class="operator">=</span> h;</span><br><span class="line">        <span class="comment">// 处理代理类修饰符，使得能被访问</span></span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建代理类实例化</span></span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>newProxyInstance 方法里面获取到代理类，如果类的作用不能访问，使其能被访问到，最后实例化代理类。这段代码中最为核心的是获取代理类的<code>getProxyClass0</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = <span class="keyword">new</span> <span class="title class_">WeakCache</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">KeyFactory</span>(), <span class="keyword">new</span> <span class="title class_">ProxyClassFactory</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="comment">// 实现类的接口不能超过 65535 个</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;interface limit exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取代理类</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 proxyClassCache 缓存中存在指定的代理类，则从缓存直接获取；如果不存在，则通过 ProxyClassFactory 创建代理类。<br>至于为什么接口最大为 65535，这个是由字节码文件结构和 Java 虚拟机规定的，具体可以通过研究字节码文件了解。</p>
<p>进入到<code>proxyClassCache#get</code>，获取代理类:</p>
<p><img src="https://images.ytao.top/java-proxy-jdk-getval.png"></p>
<p>继续进入<code>Factory#get</code>查看，</p>
<p><img src="https://images.ytao.top/java-proxy-jdk-getval2.png"></p>
<p>最后到<code>ProxyClassFactory#apply</code>，这里实现了代理类的创建。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ProxyClassFactory</span> <span class="keyword">implements</span> <span class="title class_">BiFunction</span>&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;&#123;</span><br><span class="line">    <span class="comment">// 所有代理类名称都已此前缀命名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">proxyClassNamePrefix</span> <span class="operator">=</span> <span class="string">&quot;$Proxy&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理类名的编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">nextUniqueNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> <span class="title class_">IdentityHashMap</span>&lt;&gt;(interfaces.length);</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 校验代理和目标对象是否实现同一接口</span></span><br><span class="line">            Class&lt;?&gt; interfaceClass = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                interfaceClass = Class.forName(intf.getName(), <span class="literal">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    intf + <span class="string">&quot; is not visible from class loader&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 校验 interfaceClass 是否为接口</span></span><br><span class="line">            <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    interfaceClass.getName() + <span class="string">&quot; is not an interface&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断当前 interfaceClass 是否被重复</span></span><br><span class="line">            <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;repeated interface: &quot;</span> + interfaceClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代理类的包名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">proxyPkg</span> <span class="operator">=</span> <span class="literal">null</span>;     </span><br><span class="line">        <span class="type">int</span> <span class="variable">accessFlags</span> <span class="operator">=</span> Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录非 public 修饰符代理接口的包，使生成的代理类与它在同一个包下</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">flags</span> <span class="operator">=</span> intf.getModifiers();</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                accessFlags = Modifier.FINAL;</span><br><span class="line">                <span class="comment">// 获取接口类名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> intf.getName();</span><br><span class="line">                <span class="comment">// 去掉接口的名称，获取所在包的包名</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">pkg</span> <span class="operator">=</span> ((n == -<span class="number">1</span>) ? <span class="string">&quot;&quot;</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (proxyPkg == <span class="literal">null</span>) &#123;</span><br><span class="line">                    proxyPkg = pkg;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                        <span class="string">&quot;non-public interfaces from different packages&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果接口类是 public 修饰，则用 com.sun.proxy 包名</span></span><br><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建代理类名称</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> nextUniqueNumber.getAndIncrement();</span><br><span class="line">        <span class="type">String</span> <span class="variable">proxyName</span> <span class="operator">=</span> proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成代理类字节码文件</span></span><br><span class="line">        <span class="type">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces, accessFlags);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加载字节码，生成指定代理对象</span></span><br><span class="line">            <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                                proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是创建字节码流程，通过检查接口的属性，决定代理类字节码文件生成的包名及名称规则，然后加载字节码获取代理实例。操作生成字节码文件在<code>ProxyGenerator#generateProxyClass</code>中生成具体的字节码文件，字节码操作这里不做详细讲解。<br>生成的字节码文件，我们可以通过保存本地进行反编译查看类信息，保存生成的字节码文件可以通过两种方式：设置jvm参数或将生成 byte[] 写入文件。</p>
<p><img src="https://images.ytao.top/java-proxy-jdk-saveGproxy.png"></p>
<p>上图的<code>ProxyGenerator#generateProxyClass</code>方法可知，是通过 saveGeneratedFiles 属性值控制，该属性的值来源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">saveGeneratedFiles</span> <span class="operator">=</span> ((Boolean)AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">GetBooleanAction</span>(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>))).booleanValue();</span><br></pre></td></tr></table></figure>

<p>所以通过设置将生成的代理类字节码保存到本地。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-Dsun.misc.ProxyGenerator.saveGeneratedFiles=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>反编译查看生成的代理类：</p>
<p><img src="https://images.ytao.top/java-proxy-jdk-proxy-class.png"></p>
<p>生成的代理类继承了 Proxy 和实现了 Animal 接口，调用<code>call</code>方法，是通过调用 Proxy 持有的 InvocationHandler 实现<code>TargetInvoker#invoker</code>的执行。</p>
<h1 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h1><p>CGLIB 动态代理的实现机制是生成目标类的子类，通过调用父类（目标类）的方法实现，在调用父类方法时再代理中进行增强。</p>
<h2 id="实现-MethodInterceptor-接口"><a href="#实现-MethodInterceptor-接口" class="headerlink" title="实现 MethodInterceptor 接口"></a>实现 MethodInterceptor 接口</h2><p>相比于 JDK 动态代理的实现，CGLIB 动态代理不需要实现与目标类一样的接口，而是通过方法拦截的方式实现代理，代码实现如下，首先方法拦截接口 net.sf.cglib.proxy.MethodInterceptor。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CGLIB 调用前&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;CGLIB 调用后&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过方法拦截接口调用目标类的方法，然后在该被拦截的方法进行增强处理，实现方法拦截器接口的 intercept 方法里面有四个参数：</p>
<ul>
<li>obj 代理类对象</li>
<li>method 当前被代理拦截的方法</li>
<li>args 拦截方法的参数</li>
<li>proxy 代理类对应目标类的代理方法</li>
</ul>
<h2 id="创建-CGLIB-动态代理类"><a href="#创建-CGLIB-动态代理类" class="headerlink" title="创建 CGLIB 动态代理类"></a>创建 CGLIB 动态代理类</h2><p>创建 CGLIB 动态代理类使用 net.sf.cglib.proxy.Enhancer 类进行创建，它是 CGLIB 动态代理中的核心类，首先创建个简单的代理类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span>&#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置类加载</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">TargetInterceptor</span>());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置被代理类的信息和代理类拦截的方法的回调执行逻辑，就可以实现一个代理类。<br>实现 CGLIB 动态代理调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dynamicProxy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> (Animal) CglibProxy.getProxy(Cat.class);</span><br><span class="line">        cat.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://images.ytao.top/java-proxy-cglib-test.png"></p>
<p>CGLIB 动态代理简单应用就这样实现，但是 Enhancer 在使用过程中，常用且有特色功能还有回调过滤器 CallbackFilter 的使用，它在拦截目标对象的方法时，可以有选择性的执行方法拦截，也就是选择被代理方法的增强处理。使用该功能需要实现 net.sf.cglib.proxy.CallbackFilter 接口。<br>现在增加一个方法拦截的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetInterceptor2</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CGLIB 调用前 TargetInterceptor2&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;CGLIB 调用后 TargetInterceptor2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在 Cat 中增加 hobby 方法，因为 CGLIB 代理无需实现接口，可以直接代理普通类，所以不需再 Animal 接口中增加方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喵喵喵 ~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hobby</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fish ~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现回调过滤器 CallbackFilter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetCallbackFilter</span> <span class="keyword">implements</span> <span class="title class_">CallbackFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">accept</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;hobby&quot;</span>.equals(method.getName()))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为演示调用不同的方法拦截器，在 Enhancer 设置中，使用<code>Enhancer#setCallbacks</code>设置多个方法拦截器，参数是一个数组，<code>TargetCallbackFilter#accept</code>返回的数字即为该数组的索引，决定调用的回调选择器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span>&#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        enhancer.setCallbacks(<span class="keyword">new</span> <span class="title class_">Callback</span>[]&#123;<span class="keyword">new</span> <span class="title class_">TargetInterceptor</span>(), <span class="keyword">new</span> <span class="title class_">TargetInterceptor2</span>()&#125;);</span><br><span class="line">        enhancer.setCallbackFilter(<span class="keyword">new</span> <span class="title class_">TargetCallbackFilter</span>());</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按代码实现逻辑，call 方法会调用 TargetInterceptor 类，hobby 类会调用 TargetInterceptor2 类，执行结果：</p>
<p><img src="https://images.ytao.top/java-proxy-cglib-test-2.png"></p>
<p>CGLIB 的实现原理是通过设置被代理的类信息到 Enhancer 中，然后利用配置信息在<code>Enhancer#create</code>生成代理类对象。生成类是使用 ASM 进行生成，本文不做重点分析。如果不关注 ASM 的操作原理，只看 CGLIB 的处理原理还是比较容易读懂。这里主要看生成后的代理类字节码文件，通过设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">&quot;F:\\xxx&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>可保存生成的字节到 F:\xxx 文件夹中</p>
<p><img src="https://images.ytao.top/java-proxy-cglib-jad.png"></p>
<p>通过反编译可看到</p>
<p><img src="https://images.ytao.top/java-proxy-cglib-class.jpg"></p>
<p>代理类继承了目标类 Cat，同时将两个方法拦截器加载到了代理类中，通过 Callbacks 下标作为变量名后缀进行区分，最后调用指定的方法拦截器中的 intercept 实现代理的最终的执行结果。<br>这里需要注意的是 CGLIB 动态代理不能代理 final 修饰的类和方法。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>通过反编译生成的 JDK 代理类和 CGLIB 代理类，我们可以看到它们两种不同机制的实现：<br>JDK 动态代理是通过实现目标类的接口，然后将目标类在构造动态代理时作为参数传入，使代理对象持有目标对象，再通过代理对象的 InvocationHandler 实现动态代理的操作。<br>CGLIB 动态代理是通过配置目标类信息，然后利用 ASM 字节码框架进行生成目标类的子类。当调用代理方法时，通过拦截方法的方式实现代理的操作。<br>总的来说，JDK 动态代理利用接口实现代理，CGLIB 动态代理利用继承的方式实现代理。</p>
<p>动态代理在 Java 开发中是非常常见的，在日志，监控，事务中都有着广泛的应用，同时在大多主流框架中的核心组件中也是少不了使用的，掌握其要点，不管是开发还是阅读其他框架源码时，都是必须的。 </p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JDK</tag>
        <tag>CGLIB</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo 路由机制的实现</title>
    <url>/2020/04/12/21-dubbo-router/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/dubbo.png"></p>
<p>Dubbo 路由机制是在服务间的调用时，通过将服务提供者按照设定的路由规则来决定调用哪一个具体的服务。</p>
<h1 id="路由服务结构"><a href="#路由服务结构" class="headerlink" title="路由服务结构"></a>路由服务结构</h1><p>Dubbo 实现路由都是通过实现 RouterFactory 接口。当前版本 dubbo-2.7.5 实现该接口类如下：</p>
<span id="more"></span>

<p><img src="https://images.ytao.top/dubbo-router-factory.png"></p>
<p>路由实现工厂类是在 router 包下</p>
<p><img src="https://images.ytao.top/dubbo-router-class.png"></p>
<p>由于 RouterFactory 是 SPI 接口，同时在获取路由 RouterFactory#getRouter 方法上有 @Adaptive(“protocol”) 注解，所以在获取路由的时候会动态调用需要的工厂类。</p>
<p><img src="https://images.ytao.top/dubbo-router-factory-interface.png"></p>
<p>可以看到 getRouter 方法返回的是一个 Router 接口，该接口信息如下</p>
<p><img src="https://images.ytao.top/dubbo-router-router-interface.png"></p>
<p>其中 Router#route 是服务路由的入口，对于不同类型的路由工厂，有特定的 Router 实现类。</p>
<p><img src="https://images.ytao.top/dubbo-router-router-class.png"></p>
<p>以上就是通过解析 URL，获取到具体的 Router，通过调用 Router#router 过滤出符合当前路由规则的 invokers。</p>
<h1 id="服务路由实现"><a href="#服务路由实现" class="headerlink" title="服务路由实现"></a>服务路由实现</h1><p>上面展示了路由实现类，这几个实现类型中，ConditionRouter 条件路由是最为常用的类型，由于文章篇幅有限，本文就不对全部的路由类型逐一分析，只对条件路由进行具体分析，只要弄懂这一个类型，其它类型的解析就能容易掌握。</p>
<h2 id="条件路由参数规则"><a href="#条件路由参数规则" class="headerlink" title="条件路由参数规则"></a>条件路由参数规则</h2><p>在分析条件路由前，先了解条件路由的参数配置，官方文档如下：</p>
<p><img src="https://images.ytao.top/dubbo-router-condition-config.png"></p>
<p>条件路由规则内容如下：</p>
<p><img src="https://images.ytao.top/dubbo-router-condition-rule.png"></p>
<h2 id="条件路由实现分析"><a href="#条件路由实现分析" class="headerlink" title="条件路由实现分析"></a>条件路由实现分析</h2><p>分析路由实现，主要分析工厂类的 xxxRouterFactory#getRouter 和 xxxRouter#route 方法。</p>
<h3 id="ConditionRouterFactory-getRouter"><a href="#ConditionRouterFactory-getRouter" class="headerlink" title="ConditionRouterFactory#getRouter"></a>ConditionRouterFactory#getRouter</h3><p>ConditionRouterFactory 中通过创建 ConditionRouter 对象来初始化解析相关参数配置。</p>
<p><img src="https://images.ytao.top/dubbo-router-new-conditionRouter.png"></p>
<p>在 ConditionRouter 构造函数中，从 URL 里获取 rule 的字符串格式的规则，解析规则在 ConditionRouter#init 初始化方法中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(String rule)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rule == <span class="literal">null</span> || rule.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal route rule!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去掉 consumer. 和 provider. 的标识</span></span><br><span class="line">        rule = rule.replace(<span class="string">&quot;consumer.&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;provider.&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取 消费者匹配条件 和 提供者地址匹配条件 的分隔符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> rule.indexOf(<span class="string">&quot;=&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">// 消费者匹配条件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">whenRule</span> <span class="operator">=</span> i &lt; <span class="number">0</span> ? <span class="literal">null</span> : rule.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">        <span class="comment">// 提供者地址匹配条件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">thenRule</span> <span class="operator">=</span> i &lt; <span class="number">0</span> ? rule.trim() : rule.substring(i + <span class="number">2</span>).trim();</span><br><span class="line">        <span class="comment">// 解析消费者路由规则</span></span><br><span class="line">        Map&lt;String, MatchPair&gt; when = StringUtils.isBlank(whenRule) || <span class="string">&quot;true&quot;</span>.equals(whenRule) ? <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, MatchPair&gt;() : parseRule(whenRule);</span><br><span class="line">        <span class="comment">// 解析提供者路由规则</span></span><br><span class="line">        Map&lt;String, MatchPair&gt; then = StringUtils.isBlank(thenRule) || <span class="string">&quot;false&quot;</span>.equals(thenRule) ? <span class="literal">null</span> : parseRule(thenRule);</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> It should be determined on the business level whether the `When condition` can be empty or not.</span></span><br><span class="line">        <span class="built_in">this</span>.whenCondition = when;</span><br><span class="line">        <span class="built_in">this</span>.thenCondition = then;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以路由规则字符串中的<code>=&gt;</code>为分隔符，将消费者匹配条件和提供者匹配条件分割，解析两个路由规则后，赋值给当前对象的变量。</p>
<p>调用 parseRule 方法来解析消费者和服务者路由规则。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正则验证路由规则</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">ROUTE_PATTERN</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;([&amp;!=,]*)\\s*([^&amp;!=,\\s]+)&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, MatchPair&gt; <span class="title function_">parseRule</span><span class="params">(String rule)</span></span><br><span class="line">        <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件变量和条件变量值的映射关系</span></span><br><span class="line"><span class="comment">     * 比如 host =&gt; 127.0.0.1 则保存着 host 和 127.0.0.1 的映射关系</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Map&lt;String, MatchPair&gt; condition = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, MatchPair&gt;();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(rule)) &#123;</span><br><span class="line">        <span class="keyword">return</span> condition;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Key-Value pair, stores both match and mismatch conditions</span></span><br><span class="line">    <span class="type">MatchPair</span> <span class="variable">pair</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// Multiple values</span></span><br><span class="line">    Set&lt;String&gt; values = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> ROUTE_PATTERN.matcher(rule);</span><br><span class="line">    <span class="keyword">while</span> (matcher.find()) &#123; </span><br><span class="line">        <span class="comment">// 获取正则前部分匹配（第一个括号）的内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">separator</span> <span class="operator">=</span> matcher.group(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获取正则后部分匹配（第二个括号）的内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> matcher.group(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 如果获取前部分为空，则表示规则开始位置，则当前 content 必为条件变量</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(separator)) &#123;</span><br><span class="line">            pair = <span class="keyword">new</span> <span class="title class_">MatchPair</span>();</span><br><span class="line">            condition.put(content, pair);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果分隔符是 &amp;,则 content 为条件变量</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;&amp;&quot;</span>.equals(separator)) &#123;</span><br><span class="line">            <span class="comment">// 当前 content 是条件变量，用来做映射集合的 key 的，如果没有则添加一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (condition.get(content) == <span class="literal">null</span>) &#123;</span><br><span class="line">                pair = <span class="keyword">new</span> <span class="title class_">MatchPair</span>();</span><br><span class="line">                condition.put(content, pair);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pair = condition.get(content);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前分割符是 = ，则当前 content 为条件变量值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;=&quot;</span>.equals(separator)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ParseException</span>(<span class="string">&quot;Illegal route rule \&quot;&quot;</span></span><br><span class="line">                        + rule + <span class="string">&quot;\&quot;, The error char &#x27;&quot;</span> + separator</span><br><span class="line">                        + <span class="string">&quot;&#x27; at index &quot;</span> + matcher.start() + <span class="string">&quot; before \&quot;&quot;</span></span><br><span class="line">                        + content + <span class="string">&quot;\&quot;.&quot;</span>, matcher.start());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 由于 pair 还没有被重新初始化，所以还是上一个条件变量的对象，所以可以将当前条件变量值在引用对象上赋值</span></span><br><span class="line">            values = pair.matches;</span><br><span class="line">            values.add(content);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前分割符是 = ，则当前 content 也是条件变量值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;!=&quot;</span>.equals(separator)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ParseException</span>(<span class="string">&quot;Illegal route rule \&quot;&quot;</span></span><br><span class="line">                        + rule + <span class="string">&quot;\&quot;, The error char &#x27;&quot;</span> + separator</span><br><span class="line">                        + <span class="string">&quot;&#x27; at index &quot;</span> + matcher.start() + <span class="string">&quot; before \&quot;&quot;</span></span><br><span class="line">                        + content + <span class="string">&quot;\&quot;.&quot;</span>, matcher.start());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 与 = 时同理</span></span><br><span class="line">            values = pair.mismatches;</span><br><span class="line">            values.add(content);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前分割符为 &#x27;,&#x27;，则当前 content 也为条件变量值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;,&quot;</span>.equals(separator)) &#123; <span class="comment">// Should be separated by &#x27;,&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> (values == <span class="literal">null</span> || values.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ParseException</span>(<span class="string">&quot;Illegal route rule \&quot;&quot;</span></span><br><span class="line">                        + rule + <span class="string">&quot;\&quot;, The error char &#x27;&quot;</span> + separator</span><br><span class="line">                        + <span class="string">&quot;&#x27; at index &quot;</span> + matcher.start() + <span class="string">&quot; before \&quot;&quot;</span></span><br><span class="line">                        + content + <span class="string">&quot;\&quot;.&quot;</span>, matcher.start());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 直接向条件变量值集合中添加数据</span></span><br><span class="line">            values.add(content);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ParseException</span>(<span class="string">&quot;Illegal route rule \&quot;&quot;</span> + rule</span><br><span class="line">                    + <span class="string">&quot;\&quot;, The error char &#x27;&quot;</span> + separator + <span class="string">&quot;&#x27; at index &quot;</span></span><br><span class="line">                    + matcher.start() + <span class="string">&quot; before \&quot;&quot;</span> + content + <span class="string">&quot;\&quot;.&quot;</span>, matcher.start());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> condition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就是解析条件路由规则的过程，条件变量的值都保存在 MatchPair 中的 matches、mismatches 属性中，<code>=</code>和<code>,</code>的条件变量值放在可以匹配的 matches 中，<code>!=</code>的条件变量值放在不可匹配路由规则的 mismatches 中。赋值过程中，代码还是比较优雅。</p>
<p><img src="https://images.ytao.top/dubbo-router-matchpair.png"></p>
<p>实际上 matches、mismatches 就是保存的是条件变量值。</p>
<h3 id="ConditionRouter-route"><a href="#ConditionRouter-route" class="headerlink" title="ConditionRouter#route"></a>ConditionRouter#route</h3><p><code>Router#route</code>的作用就是匹配出符合路由规则的 Invoker 集合。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在初始化中进行被复制的变量</span></span><br><span class="line"><span class="comment">// 消费者条件匹配规则</span></span><br><span class="line"><span class="keyword">protected</span> Map&lt;String, MatchPair&gt; whenCondition;</span><br><span class="line"><span class="comment">// 提供者条件匹配规则</span></span><br><span class="line"><span class="keyword">protected</span> Map&lt;String, MatchPair&gt; thenCondition;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; <span class="title function_">route</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span></span><br><span class="line">        <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="keyword">if</span> (!enabled) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 验证 invokers 是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 校验消费者是否有规则匹配，如果没有则返回传入的 Invoker</span></span><br><span class="line">        <span class="keyword">if</span> (!matchWhen(url, invocation)) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Invoker&lt;T&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (thenCondition == <span class="literal">null</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;The current consumer in the service blacklist. consumer: &quot;</span> + NetUtils.getLocalHost() + <span class="string">&quot;, service: &quot;</span> + url.getServiceKey());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历传入的 invokers，匹配提供者是否有规则匹配</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matchThen(invoker.getUrl(), url)) &#123;</span><br><span class="line">                result.add(invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 result 不为空，或当前对象 force=true 则返回 result 的 Invoker 列表 </span></span><br><span class="line">        <span class="keyword">if</span> (!result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (force) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;The route result is empty and force execute. consumer: &quot;</span> + NetUtils.getLocalHost() + <span class="string">&quot;, service: &quot;</span> + url.getServiceKey() + <span class="string">&quot;, router: &quot;</span> + url.getParameterAndDecoded(RULE_KEY));</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Failed to execute condition router rule: &quot;</span> + getUrl() + <span class="string">&quot;, invokers: &quot;</span> + invokers + <span class="string">&quot;, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> invokers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面代码可以看到，只要消费者没有匹配的规则或提供者没有匹配的规则及 force&#x3D;false 时，不会返回传入的参数的 Invoker。</p>
<p>匹配消费者路由规则和提供者路由规则方法是 matchWhen 和 matchThen</p>
<p><img src="https://images.ytao.top/dubbo-router-matchcondition.png"></p>
<p>这两个匹配方法都是调用同一个方法 matchCondition 实现的。将消费者或提供者 URL 转为 Map，然后与 whenCondition 或 thenCondition 进行匹配。</p>
<p>匹配过程中，如果 key （即 sampleValue 值）存在对应的值，则通过 MatchPair#isMatch 方法再进行匹配。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String value, URL param)</span> &#123;</span><br><span class="line">    <span class="comment">// 存在可匹配的规则，不存在不可匹配的规则</span></span><br><span class="line">    <span class="keyword">if</span> (!matches.isEmpty() &amp;&amp; mismatches.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 不可匹配的规则列表为空时，只要可匹配的规则匹配上，直接返回 true</span></span><br><span class="line">        <span class="keyword">for</span> (String match : matches) &#123;</span><br><span class="line">            <span class="keyword">if</span> (UrlUtils.isMatchGlobPattern(match, value, param)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存在不可匹配的规则，不存在可匹配的规则</span></span><br><span class="line">    <span class="keyword">if</span> (!mismatches.isEmpty() &amp;&amp; matches.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 不可匹配的规则列表中存在，则返回false</span></span><br><span class="line">        <span class="keyword">for</span> (String mismatch : mismatches) &#123;</span><br><span class="line">            <span class="keyword">if</span> (UrlUtils.isMatchGlobPattern(mismatch, value, param)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存在可匹配的规则，也存在不可匹配的规则</span></span><br><span class="line">    <span class="keyword">if</span> (!matches.isEmpty() &amp;&amp; !mismatches.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 都不为空时，不可匹配的规则列表中存在，则返回 false</span></span><br><span class="line">        <span class="keyword">for</span> (String mismatch : mismatches) &#123;</span><br><span class="line">            <span class="keyword">if</span> (UrlUtils.isMatchGlobPattern(mismatch, value, param)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String match : matches) &#123;</span><br><span class="line">            <span class="keyword">if</span> (UrlUtils.isMatchGlobPattern(match, value, param)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后剩下的是 可匹配规则和不可匹配规则都为空时</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匹配过程再调用 UrlUtils#isMatchGlobPattern 实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMatchGlobPattern</span><span class="params">(String pattern, String value, URL param)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果以 $ 开头，则获取 URL 中对应的值</span></span><br><span class="line">    <span class="keyword">if</span> (param != <span class="literal">null</span> &amp;&amp; pattern.startsWith(<span class="string">&quot;$&quot;</span>)) &#123;</span><br><span class="line">        pattern = param.getRawParameter(pattern.substring(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">return</span> isMatchGlobPattern(pattern, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMatchGlobPattern</span><span class="params">(String pattern, String value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(pattern)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(pattern) &amp;&amp; StringUtils.isEmpty(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(pattern) || StringUtils.isEmpty(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取通配符位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> pattern.lastIndexOf(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="comment">// 如果value中没有 &quot;*&quot; 通配符，则整个字符串值匹配</span></span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.equals(pattern);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 &quot;*&quot; 在最后面，则匹配字符串 &quot;*&quot; 之前的字符串即可</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == pattern.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.startsWith(pattern.substring(<span class="number">0</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 &quot;*&quot; 在最前面，则匹配字符串 &quot;*&quot; 之后的字符串即可</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.endsWith(pattern.substring(i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 &quot;*&quot; 不在字符串两端，则同时匹配字符串 &quot;*&quot; 左右两边的字符串</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> pattern.substring(<span class="number">0</span>, i);</span><br><span class="line">        <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> pattern.substring(i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> value.startsWith(prefix) &amp;&amp; value.endsWith(suffix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就这样完成全部的条件路由规则匹配，虽然看似代码较为繁杂，但是理清规则、思路，一步一步还是较好解析，前提是要熟悉相关参数的用法及形式，不然代码较难理解。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>单纯从逻辑上，如果能够掌握条件路由的实现，去研究其它方式的路由实现，相信不会有太大问题。只是例如像脚本路由的实现，你得先会使用脚本执行引擎为前提，不然就不理解它的代码。最后，在 dubbo-admin 上可以设置路由，大家可以尝试各种使用规则，通过实操才能更好掌握和理解路由机制的实现。</p>
]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 线程基础，从这篇开始</title>
    <url>/2020/04/19/22-thread-base/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/thread-base.png"></p>
<blockquote>
<p>线程作为操作系统中最少调度单位，在当前系统的运行环境中，一般都拥有多核处理器，为了更好的充分利用 CPU，掌握其正确使用方式，能更高效的使程序运行。同时，在 Java 面试中，也是极其重要的一个模块。</p>
</blockquote>
<span id="more"></span>

<h1 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h1><p>一个独立运行的程序是一个进程，一个进程中可以包含一个或多个线程，每个线程都有属于自己的一些属性，如堆栈，计数器等等。同时，一个线程在一个时间点上只能运行在一个 CPU 处理器核心上，不同线程之间也可以访问共享变量。线程在运行时，系统给每个线程分配一些 CPU 时间片，CPU 在时间片这段时间运行某个线程，当这个时间片运行完又跳转至下一段时间片线程，CPU 在这些线程中进行高速切换，使得程序像是在同时进行多个线程操作。</p>
<h1 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h1><p>实现线程常用的两种方式：继承 java.lang.Thread 类、实现 java.lang.Runnable 接口。</p>
<h2 id="继承-Thread-类方式"><a href="#继承-Thread-类方式" class="headerlink" title="继承 Thread 类方式"></a>继承 Thread 类方式</h2><p>通过实例化 java.lang.Thread 类获得线程。创建 Thread 对象，一般使用继承 Thread 类的方式，然后通过方法重写覆盖 Thread 的某些方法。</p>
<p>首先创建一个继承 Thread 的子类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 Thread 类中的 run 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// currentThread().getName() 获取当前线程名称</span></span><br><span class="line">        System.out.println(<span class="string">&quot;java.lang.Thread 创建的&quot;</span>+ currentThread().getName() +<span class="string">&quot;线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码 DemoThread 实例化的对象就代表一个线程，通过重写 run 方法，在 run 方法中实现该线程的逻辑实现。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化 DemoThread 得到新创建的线程实例</span></span><br><span class="line">        <span class="type">DemoThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoThread</span>();</span><br><span class="line">        <span class="comment">// 给创建的子线程命名</span></span><br><span class="line">        thread.setName(<span class="string">&quot;DemoThread 子线程&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过主线程打印信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在程序执行的主线程中创建子线程，并且命名为<code>DemoThread 子线程</code>，在程序的最后打印主线程打印的信息。调用线程必须调用<code>start()</code>方法，在调用此方法之前，子线程是不存在的，只有<code>start()</code>方法调用后，才是真正的创建了线程。</p>
<p>执行结果：</p>
<p><img src="https://images.ytao.top/thread-base-thread-result.png"></p>
<p>从结果可以看到，由于在主线程中创建了一个子线程，子线程相对于主线程就相当于是一个异步操作，所以打印结果就有可能main线程先于子线程执行打印操作。</p>
<h2 id="实现-Runnable-接口方式"><a href="#实现-Runnable-接口方式" class="headerlink" title="实现 Runnable 接口方式"></a>实现 Runnable 接口方式</h2><p>由于 Java 是单继承的特性，所以当创建线程的子类继承了其他的类，就无法实现继承操作。这时就可以通过实现 Runnable 接口，来实现线程创建的逻辑。</p>
<p>首先创建一个实现 Runnable 的类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现 Runnable 中的 run 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;java.lang.Runnable 创建的 &quot;</span>+ Thread.currentThread().getName() +<span class="string">&quot;线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Runnable 接口中定义有一个 run 方法，所以实现 Runnable 接口，就必须实现 run 方法。实际上 java.lang.Thread 类也实现了 Runnable 接口。</p>
<p><img src="https://images.ytao.top/thread-base-thread-impl.png"></p>
<p>创建线程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Thread 实例，并给将要创建的线程给命名</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DemoRunnable</span>(), <span class="string">&quot;DemoRunnable 子线程&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建一个线程</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<p><img src="https://images.ytao.top/thread-base-runnable-result.png"></p>
<p>同样也实现了与继承 Thread 方式一样的结果。</p>
<p>创建 Thread 实例时，向新创建的 Thread 实例中传入了一个实现 Runnable 接口的对象的参数。</p>
<p><img src="https://images.ytao.top/thread-base-new-thread.png"></p>
<p>Thread 中初始化 Thread#init 的具体实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">                  <span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params">                  <span class="type">boolean</span> inheritThreadLocals)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给当前创建的 thread 实例中赋值线程名</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="comment">// 将要创建的线程的父线程即当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">parent</span> <span class="operator">=</span> currentThread();</span><br><span class="line">    <span class="comment">// 添加到线程组操作</span></span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g == <span class="literal">null</span>) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g.checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程组中添加为启动的线程数</span></span><br><span class="line">    g.addUnstarted();</span><br><span class="line">    <span class="built_in">this</span>.group = g;</span><br><span class="line">    <span class="comment">// 设置父线程的一些属性到当前将要创建的线程</span></span><br><span class="line">    <span class="built_in">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="built_in">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">if</span> (security == <span class="literal">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="built_in">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="built_in">this</span>.inheritedAccessControlContext =</span><br><span class="line">            acc != <span class="literal">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将当前传入 target 的参数，赋值给当前 Thread 对象，使其持有 已实现 Runnable 接口的实例</span></span><br><span class="line">    <span class="built_in">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>)</span><br><span class="line">        <span class="built_in">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置线程的堆栈大小</span></span><br><span class="line">    <span class="built_in">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给创建的线程一个 id</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码创建 thread 对象时的 init 方法，通过传入 Runnable 的实例对象，thread 对象中就持有该对象。</p>
<p>创建 thread 对象后，调用 start() 方法，该线程就运行持有 Runnable 实现类对象的 run() 方法。</p>
<p><img src="https://images.ytao.top/thread-base-thread-run.png"></p>
<p>例如本文中案例，就会执行 DemoRunnable#run 方法的逻辑。</p>
<p>这两种方法创建线程的方式，具体使用哪种，根据自身需求选择。如果需要继承其他非 Thread 类，就需要使用 Runnable 接口。</p>
<h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p>Java 线程每个时间点都存在于6种状态中一种。</p>
<table>
<thead>
<tr>
<th align="center">状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">NEW</td>
<td>初始状态，thread 对象调用 start() 方法前</td>
</tr>
<tr>
<td align="center">RUNNABLE</td>
<td>运行状态，线程 start() 后的就绪或运行中</td>
</tr>
<tr>
<td align="center">BLOCKED</td>
<td>阻塞状态，线程获得锁后的锁定状态</td>
</tr>
<tr>
<td align="center">WAITING</td>
<td>等待状态，线程进入等待状态，不会被分配时间片，需要等待其他线程来唤醒</td>
</tr>
<tr>
<td align="center">TIME_WAITING</td>
<td>超时等待状态，同样不分配时间片，当时间达到设定的等待时间后自动唤醒</td>
</tr>
<tr>
<td align="center">TERMINATED</td>
<td>终止状态，表示当前线程执行完成</td>
</tr>
</tbody></table>
<p>其中 NEW、RUNNABLE、TERMINATED 比较好理解，现在主要针对 BLOCKED、WAITING 和 TIME_WAITING 进行案例讲解。</p>
<h2 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h2><p><strong>阻塞状态</strong> 是将两个线程之间处于竞争关系，同时在调用 run 时进行加锁。</p>
<p>首先还是使用上面 Runnable 实现的方式进行改造。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 通过对DemoRunnable加同步锁，进行无限循环不退出</span></span><br><span class="line">        <span class="keyword">synchronized</span> (DemoRunnable.class)&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;java.lang.Runnable 创建的 &quot;</span>+ Thread.currentThread().getName() +<span class="string">&quot;线程&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先竞争到 DemoRunnable 类的线程进入 run 会一直执行下去，未竞争到的线程则会一直处于阻塞状态。</p>
<p>创建两个线程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建两个线程测试</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DemoRunnable</span>(), <span class="string">&quot;test-blocked-1&quot;</span>)</span><br><span class="line">                .start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DemoRunnable</span>(), <span class="string">&quot;test-blocked-2&quot;</span>)</span><br><span class="line">                .start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过分析执行后的线程如图：</p>
<p><img src="https://images.ytao.top/thread-base-state-blocked.png"></p>
<p>可以得知线程<code>test-blocked-1</code>竞争到 DemoRunnable 类，一直都在运行 while 循环，所以状态为 RUNNABLE。由于 DemoRunnable#run 中加了同步锁锁住 DemoRunnable 类，所以<code>test-blocked-2</code>一直处于 BLOCKED 阻塞状态。</p>
<h2 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a>WAITING</h2><p><strong>等待状态</strong> 线程是不被分配 CPU 时间片，线程如果要重新被唤醒，必须显示被其它线程唤醒，否则会一直等待下去。</p>
<p>实现等待状态例子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 调用 wait 方法，使线程在当前实例上处于等待状态</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;java.lang.Runnable 创建的 &quot;</span>+ Thread.currentThread().getName() +<span class="string">&quot;线程&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DemoRunnable</span>(), <span class="string">&quot;test-waiting&quot;</span>)</span><br><span class="line">                .start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建该实例线程后，分析 test-waiting 线程，该线程处于 WAITING 状态。</p>
<p><img src="https://images.ytao.top/thread-base-state-waiting.png"></p>
<h2 id="TIME-WAITING"><a href="#TIME-WAITING" class="headerlink" title="TIME_WAITING"></a>TIME_WAITING</h2><p><strong>超时等待状态</strong> 线程也是不被分配 CPU 时间片，但是它通过设置的间隔时间后，可以自动唤醒当前线程。也就是说，将等待状态的线程加个时间限制就是超时等待状态。</p>
<p>只需对上面 WAITING 状态案例增加 wait 时间限制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 增加等待时长</span></span><br><span class="line">                    <span class="built_in">this</span>.wait(<span class="number">1000000</span>, <span class="number">999999</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;java.lang.Runnable 创建的 &quot;</span>+ Thread.currentThread().getName() +<span class="string">&quot;线程&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析线程结果，可以看到 test-time_waiting 线程处于超时等待状态，使用 sleep 睡眠时，线程也是属于超时等待状态。</p>
<p><img src="https://images.ytao.top/thread-base-state-time_waiting.png"></p>
<p>线程状态之间的转换，如图（来源网络）：</p>
<p><img src="https://images.ytao.top/thread-base-thread-state.jpg"></p>
<h1 id="Thread-常用方法"><a href="#Thread-常用方法" class="headerlink" title="Thread 常用方法"></a>Thread 常用方法</h1><h2 id="currentThread"><a href="#currentThread" class="headerlink" title="currentThread()"></a>currentThread()</h2><p>currentThread 是获取当前线程实例，返回 Thread 对象，这是一个静态方法，使用如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread.currentThread();</span><br></pre></td></tr></table></figure>

<h2 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h2><p>start 方法是启动线程的入口方法，这个就是上面实现创建线程例子中的 start 方法。</p>
<h2 id="run"><a href="#run" class="headerlink" title="run()"></a>run()</h2><p>run 方法是线程创建后，线程会主动调用 run 方法执行里面的逻辑。</p>
<h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>join 方法即线程同步，比如上继承 Thread 方法实现创建线程的例子中，如果在 thread.start() 后调用 thread.join() 方法，则 main 线程打印的信息一定在子线程打印的信息之后。这里的 main 线程会等待子线程执行完后，再继续执行。</p>
<h2 id="getName"><a href="#getName" class="headerlink" title="getName()"></a>getName()</h2><p>getName 返回线程名称。</p>
<h2 id="getId"><a href="#getId" class="headerlink" title="getId()"></a>getId()</h2><p>获取线程 Id，这是返回一个 long 类型的 Id 值。</p>
<h2 id="setDaemon"><a href="#setDaemon" class="headerlink" title="setDaemon()"></a>setDaemon()</h2><p>setDaemon(boolean on) 方法是设置线程类型，setDaemon 接受一个 boolean 类型参数。设置为 true 时，线程类型为守护线程，设置为 false 时，线程类型为用户线程。</p>
<h2 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h2><p>yield 方法是线程让步，让当前线程进入就绪状态，去执行其它相同优先级的线程，但不一定会执行其他线程，有可能让步后的线程再次被执行。</p>
<h2 id="setPriority"><a href="#setPriority" class="headerlink" title="setPriority()"></a>setPriority()</h2><p>setPriority(int newPriority) 是设置线程执行的优先级，数值为1~10，默认值为5，数值越大线程越先执行。</p>
<h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h2><p>interrupt 方法的作用是中断线程，但是它还是会继续运行。它只是表示其他线程给打了个中断标志。</p>
<h2 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h2><p>interrupted 方法是检查当前线程是否被中断。调用此方法时会清除该线程的中断标志。</p>
<h2 id="isInterrupted"><a href="#isInterrupted" class="headerlink" title="isInterrupted()"></a>isInterrupted()</h2><p>isInterrupted 方法检测当前线程是否被中断，如果被中断了，也不会清除中断标志。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>本文对线程的常用功能及概念进行了分析，主要是讲解单线程的一些操作，线程操作的使用在生产中是极容易出现问题的，所以在掌握概念和使用后，需要多研究，多思考应用的设计及实现。在掌握多线程操作时，必须对这些的基本使用和概念进行掌握，今后会出进一步对多线程分析的文章。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo 负载均衡的实现</title>
    <url>/2020/05/02/23-dubbo-loadbalance/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/dubbo.png"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>负载均衡是指在集群中，将多个数据请求分散在不同单元上进行执行，主要为了提高系统容错能力和加强系统对数据的处理能力。</p>
<blockquote>
<p>在 Dubbo 中，一次服务的调用就是对所有实体域 Invoker 的一次筛选过滤，最终选定具体调用的 Invoker。首先在 Directory 中获取全部 Invoker 列表，通过路由筛选出符合规则的 Invoker，最后再经过负载均衡选出具体的 Invoker。所以 Dubbo 负载均衡机制是决定一次服务调用使用哪个提供者的服务。</p>
</blockquote>
<span id="more"></span>

<h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><p>Dubbo 负载均衡的分析入口是 org.apache.dubbo.rpc.cluster.loadbalance.AbstractLoadBalance 抽象类，查看这个类继承关系。</p>
<p><img src="https://images.ytao.top/dubbo_loadbalance_abstractloadbalance.png"></p>
<p>这个被 RandomLoadBalance、LeastActiveLoadBalance、RoundRobinLoadBalance 及 ConsistentHashLoadBalance 类继承，这四个类是 Dubbo 中提供的四种负载均衡算法的实现。</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">RandomLoadBalance</td>
<td>随机算法，根据权重设置随机的概率</td>
</tr>
<tr>
<td align="center">LeastActiveLoadBalance</td>
<td>最少活跃数算法，指请求数和完成数之差，使执行效率高的服务接收更多请求</td>
</tr>
<tr>
<td align="center">RoundRobinLoadBalance</td>
<td>加权轮训算法，根据权重设置轮训比例</td>
</tr>
<tr>
<td align="center">ConsistentHashLoadBalance</td>
<td>Hash 一致性算法，相同请求参数分配到相同提供者</td>
</tr>
</tbody></table>
<p>以上则是 Dubbo 提供的四种负载均衡算法。</p>
<p>从上图中，看到 AbstractLoadBalance 实现了 LoadBalance 接口，同时是一个 SPI 接口，指定默认实现为 RandomLoadBalance 随机算法机制。</p>
<p><img src="https://images.ytao.top/dubbo_loadbalance_loadbalance.png"></p>
<p>抽象类 <strong>AbstractLoadBalance</strong> 中，实现了负载均衡通用的逻辑，同时给子类声明了一个抽象方法供子类实现其负载均衡的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractLoadBalance</span> <span class="keyword">implements</span> <span class="title class_">LoadBalance</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> 运行时间（毫秒）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> 预热时间（毫秒）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> 要计算的 Invoker 权重值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateWarmupWeight</span><span class="params">(<span class="type">int</span> uptime, <span class="type">int</span> warmup, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="comment">// 计算预热时期的权重</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ww</span> <span class="operator">=</span> (<span class="type">int</span>) ((<span class="type">float</span>) uptime / ((<span class="type">float</span>) warmup / (<span class="type">float</span>) weight));</span><br><span class="line">        <span class="comment">// 返回的权重值区间在: 1 ~ weight</span></span><br><span class="line">        <span class="keyword">return</span> ww &lt; <span class="number">1</span> ? <span class="number">1</span> : (ww &gt; weight ? weight : ww);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> &#123;</span><br><span class="line">        <span class="comment">// 校验 invokers 是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当到达负载均衡流程时，invokers 中只有一个 Invoker 时，直接返回该 Invoker</span></span><br><span class="line">        <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在不同负载均衡策略中完成具体的实现</span></span><br><span class="line">        <span class="keyword">return</span> doSelect(invokers, url, invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明抽象方法，在子类中具体实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前Invoker配置的权重值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> invoker.getUrl().getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);</span><br><span class="line">        <span class="keyword">if</span> (weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 服务启动时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> invoker.getUrl().getParameter(REMOTE_TIMESTAMP_KEY, <span class="number">0L</span>);</span><br><span class="line">            <span class="keyword">if</span> (timestamp &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="comment">// 服务已运行时长</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">uptime</span> <span class="operator">=</span> (<span class="type">int</span>) (System.currentTimeMillis() - timestamp);</span><br><span class="line">                <span class="comment">// 服务预热时间，默认 DEFAULT_WARMUP = 10 * 60 * 1000 ，预热十分钟</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">warmup</span> <span class="operator">=</span> invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);</span><br><span class="line">                <span class="comment">// 如果服务运行时长小于预热时长，重新计算出预热时期的权重</span></span><br><span class="line">                <span class="keyword">if</span> (uptime &gt; <span class="number">0</span> &amp;&amp; uptime &lt; warmup) &#123;</span><br><span class="line">                    weight = calculateWarmupWeight(uptime, warmup, weight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保证最后返回的权重值不小于0</span></span><br><span class="line">        <span class="keyword">return</span> weight &gt;= <span class="number">0</span> ? weight : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 AbstractLoadBalance 中，getWeight 和 calculateWarmupWeight 方法是获取和计算当前 Invoker 的权重值。</p>
<p>getWeight 中获取当前权重值，通过 URL 获取当前 Invoker 设置的权重，如果当前服务提供者启动时间小于预热时间，则会重新计算权重值，对服务进行降权处理，保证服务能在启动初期不分发设置比例的全部流量，健康运行下去。</p>
<p>calculateWarmupWeight 是重新计算权重值的方法，计算公式为：<code>服务运行时长 / (预热时长 / 设置的权重值)</code>，等价于<code>(服务运行时长 / 预热时长) * 设置的权重值</code>，同时条件<code>服务运行时长 &lt; 预热时长</code>。由该公式可知，预热时长和设置的权重值不变，服务运行时间越长，计算出的值越接近 weight，但不会等于 weight。<br>在返回计算后的权重结果中，对小于1和大于设置的权重值进行了处理，当重新计算后的权重小于1时返回1；处于1和设置的权重值之间时，直接返回计算后的结果；当权重大于设置的权重值时（因为条件限制，不会出现该类情况），返回设置的权重值。所以得出结论：<strong>重新计算后的权重值为 1 ~ 设置的权重值，运行时间越长，计算出的权重值越接近设置的权重值</strong>。</p>
<h1 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>通过 XML 配置方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- 服务级别配置 --&gt;</span><br><span class="line">&lt;dubbo:service <span class="built_in">id</span>=<span class="string">&quot;xXXXService&quot;</span> interface=<span class="string">&quot;top.ytao.service.XXXXService&quot;</span> class=<span class="string">&quot;top.ytao.service.impl.XXXXServiceImpl&quot;</span> loadbalance=<span class="string">&quot;负载策略&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 方法级别配置 --&gt;</span><br><span class="line">&lt;dubbo:service <span class="built_in">id</span>=<span class="string">&quot;xXXXService&quot;</span> interface=<span class="string">&quot;top.ytao.service.XXXXService&quot;</span> class=<span class="string">&quot;top.ytao.service.impl.XXXXServiceImpl&quot;</span>&gt;</span><br><span class="line">    &lt;dubbo:method name=<span class="string">&quot;方法名&quot;</span> loadbalance=<span class="string">&quot;负载策略&quot;</span>/&gt;</span><br><span class="line">&lt;/dubbo:service&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过 Properties 配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dubbo.service.loadbalance=负载策略</span><br></pre></td></tr></table></figure>

<p>通过注解方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(loadbalance = &quot;负载策略&quot;)</span></span><br></pre></td></tr></table></figure>


<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>通过 XML 配置方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- 服务级别配置 --&gt;</span><br><span class="line">&lt;dubbo:reference <span class="built_in">id</span>=<span class="string">&quot;xXXXService&quot;</span> interface=<span class="string">&quot;top.ytao.service.XXXXService&quot;</span> loadbalance=<span class="string">&quot;负载策略&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 方法级别配置 --&gt;</span><br><span class="line">&lt;dubbo:reference <span class="built_in">id</span>=<span class="string">&quot;xXXXService&quot;</span> interface=<span class="string">&quot;top.ytao.service.XXXXService&quot;</span>&gt;</span><br><span class="line">    &lt;dubbo:method name=<span class="string">&quot;方法名&quot;</span> loadbalance=<span class="string">&quot;负载策略&quot;</span>/&gt;</span><br><span class="line">&lt;/dubbo:reference&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过 Properties 配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dubbo.reference.loadbalance=负载策略</span><br></pre></td></tr></table></figure>

<p>通过注解配置方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Reference(loadbalance = &quot;负载策略&quot;)</span></span><br></pre></td></tr></table></figure>

<p>实现方式也可通过 Dubbo-Admin 管理后台进行配置，如图：</p>
<p><img src="https://images.ytao.top/dubbo_loadbalance_admin.png"></p>
<h1 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h1><p>加权随机算法负载均衡策略（RandomLoadBalance）是 dubbo 负载均衡的默认实现方式，根据权重分配各个 Invoker 随机选中的比例。这里的意思是：将到达负载均衡流程的 Invoker 列表中的 权重进行求和，然后求出单个 Invoker 权重在总权重中的占比，随机数就在总权重值的范围内生成。</p>
<p>如图，假如当前有<code>192.168.1.10</code>和<code>192.168.1.11</code>两个负载均衡的服务，权重分别为 4、6 ，则它们的被选中的比例为 2&#x2F;5、3&#x2F;5。</p>
<p><img src="https://images.ytao.top/dubbo_loadbalance_random.png"></p>
<p>当生成随机数为 6 时，就会选中<code>192.168.1.11</code>的服务。</p>
<p>dubbo 中 RandomLoadBalance 的 doSelect 实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomLoadBalance</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalance</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;random&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> &#123;</span><br><span class="line">        <span class="comment">// Invoker 数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> invokers.size();</span><br><span class="line">        <span class="comment">// 标识所有 Invoker 的权重是否都一样</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">sameWeight</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 用一个数组保存每个 Invoker 的权重</span></span><br><span class="line">        <span class="type">int</span>[] weights = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="comment">// 第一个 Invoker 的权重</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">firstWeight</span> <span class="operator">=</span> getWeight(invokers.get(<span class="number">0</span>), invocation);</span><br><span class="line">        weights[<span class="number">0</span>] = firstWeight;</span><br><span class="line">        <span class="comment">// 求和总权重</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalWeight</span> <span class="operator">=</span> firstWeight;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> getWeight(invokers.get(i), invocation);</span><br><span class="line">            <span class="comment">// 保存每个 Invoker 的权重到数组总</span></span><br><span class="line">            weights[i] = weight;</span><br><span class="line">            <span class="comment">// 累加求和总权重</span></span><br><span class="line">            totalWeight += weight;</span><br><span class="line">            <span class="comment">// 如果不是所有 Invoker 的权重都一样，就给标记上 sameWeight = false</span></span><br><span class="line">            <span class="keyword">if</span> (sameWeight &amp;&amp; weight != firstWeight) &#123;</span><br><span class="line">                sameWeight = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算随机数取到的 Invoker，条件是必须总权重大于0，并且每个 Invoker 的权重都不一样</span></span><br><span class="line">        <span class="keyword">if</span> (totalWeight &gt; <span class="number">0</span> &amp;&amp; !sameWeight) &#123;</span><br><span class="line">            <span class="comment">// 基于 0~总数 范围内生成随机数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line">            <span class="comment">// 计算随机数对应的 Invoker</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                offset -= weights[i];</span><br><span class="line">                <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果所有 Invoker 的权重都一样则随机从 Invoker 列表中返回一个</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(ThreadLocalRandom.current().nextInt(length));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上就是加权随机策略的实现，这里比较主要关注计算生成的随机数对应的 Invoker。通过遍历权重数组，生成的数累减当前权重值，当 offset 为 0 时，就表示 offset 对应当前的 Invoker 服务。</p>
<p>以生成的随机数为 6 为例，遍历 Invokers 长度：</p>
<ol>
<li><p>第一轮：offset &#x3D; 6 - 4 &#x3D; 2 不满足 offset &lt; 0，继续遍历。</p>
</li>
<li><p>第二轮：offset &#x3D; 2 - 6 &#x3D; -4 满足 offset &lt; 0，返回当前索引对应的 Invoker。因为 offset 返回负数，表示 offset 落在当前 Invoker 权重的区间里。</p>
</li>
</ol>
<p>加权随机策略并非一定按照比例被选到，理论上调用次数越多，分布的比例越接近权重所占的比例。</p>
<h1 id="最少活跃数算法"><a href="#最少活跃数算法" class="headerlink" title="最少活跃数算法"></a>最少活跃数算法</h1><p>最小活跃数负载均衡策略（LeastActiveLoadBalance）是从最小活跃数的 Invoker 中进行选择。什么是活跃数呢？活跃数是一个 Invoker 正在处理的请求的数量，当 Invoker 开始处理请求时，会将活跃数加 1，完成请求处理后，将相应 Invoker 的活跃数减 1。找出最小活跃数后，最后根据权重进行选择最终的 Invoker。如果最后找出的最小活跃数相同，则随机从中选中一个 Invoker。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeastActiveLoadBalance</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalance</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;leastactive&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> &#123;</span><br><span class="line">        <span class="comment">// Invoker 数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> invokers.size();</span><br><span class="line">        <span class="comment">// 所有 Invoker 中的最小活跃值都是 -1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leastActive</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 最小活跃值 Invoker 的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leastCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最小活跃值 Invoker 在 Invokers 列表中对应的下标位置</span></span><br><span class="line">        <span class="type">int</span>[] leastIndexes = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="comment">// 保存每个 Invoker 的权重</span></span><br><span class="line">        <span class="type">int</span>[] weights = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="comment">// 总权重</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalWeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第一个最小活跃数的权重</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">firstWeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最小活跃数 Invoker 列表的权重是否一样</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">sameWeight</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出最小活跃数 Invoker 的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            Invoker&lt;T&gt; invoker = invokers.get(i);</span><br><span class="line">            <span class="comment">// 获取最小活跃数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">active</span> <span class="operator">=</span> RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();</span><br><span class="line">            <span class="comment">// 获取权重</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">afterWarmup</span> <span class="operator">=</span> getWeight(invoker, invocation);</span><br><span class="line">            <span class="comment">// 保存权重</span></span><br><span class="line">            weights[i] = afterWarmup;</span><br><span class="line">            <span class="comment">// 如果当前最小活跃数为-1（-1为最小值）或小于leastActive</span></span><br><span class="line">            <span class="keyword">if</span> (leastActive == -<span class="number">1</span> || active &lt; leastActive) &#123;</span><br><span class="line">                <span class="comment">// 重置最小活跃数</span></span><br><span class="line">                leastActive = active;</span><br><span class="line">                <span class="comment">// 重置最小活跃数 Invoker 的数量</span></span><br><span class="line">                leastCount = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 保存当前 Invoker 在 Invokers 列表中的索引至leastIndexes数组中</span></span><br><span class="line">                leastIndexes[<span class="number">0</span>] = i;</span><br><span class="line">                <span class="comment">// 重置最小活跃数 invoker 的总权重值</span></span><br><span class="line">                totalWeight = afterWarmup;</span><br><span class="line">                <span class="comment">// 记录当前 Invoker 权重为第一个最小活跃数 Invoker 的权重</span></span><br><span class="line">                firstWeight = afterWarmup;</span><br><span class="line">                <span class="comment">// 因为当前 Invoker 重置为第一个最小活跃数 Invoker ，所以标识所有最小活跃数 Invoker 权重都一样的值为 true</span></span><br><span class="line">                sameWeight = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 如果当前最小活跃数和已声明的最小活跃数相等 </span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (active == leastActive) &#123;</span><br><span class="line">                <span class="comment">// 记录当前 Invoker 的位置</span></span><br><span class="line">                leastIndexes[leastCount++] = i;</span><br><span class="line">                <span class="comment">// 累加当前 Invoker 权重到总权重中</span></span><br><span class="line">                totalWeight += afterWarmup;</span><br><span class="line">                <span class="comment">// 如果当前权重与firstWeight不相等，则将 sameWeight 改为 false</span></span><br><span class="line">                <span class="keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; afterWarmup != firstWeight) &#123;</span><br><span class="line">                    sameWeight = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最小活跃数 Invoker 只有一个，直接返回该 Invoker</span></span><br><span class="line">        <span class="keyword">if</span> (leastCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers.get(leastIndexes[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据权重随机从最小活跃数 Invoker 列表中选择一个 </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">offsetWeight</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; leastCount; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">leastIndex</span> <span class="operator">=</span> leastIndexes[i];</span><br><span class="line">                offsetWeight -= weights[leastIndex];</span><br><span class="line">                <span class="keyword">if</span> (offsetWeight &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.get(leastIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果所有 Invoker 的权重都一样则随机从 Invoker 列表中返回一个</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(leastIndexes[ThreadLocalRandom.current().nextInt(leastCount)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的整个逻辑就是，从 Invokers 列表中筛选出最小活跃数的 Invoker，然后类似加权随机算法策略方式选择最终的 Invoker 服务。</p>
<h1 id="轮询算法"><a href="#轮询算法" class="headerlink" title="轮询算法"></a>轮询算法</h1><p>加权轮询负载均衡策略（RoundRobinLoadBalance）是基于权重来决定轮询的比例。普通轮询会将请求均匀的分布在每个节点，但不能很好调节不同性能服务器的请求处理，所以加权负载均衡来根据权重在轮询机制中分配相对应的请求比例给每台服务器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoundRobinLoadBalance</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalance</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;roundrobin&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RECYCLE_PERIOD</span> <span class="operator">=</span> <span class="number">60000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WeightedRoundRobin</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">current</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> lastUpdate;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">int</span> weight)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">            current.set(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">increaseCurrent</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> current.addAndGet(weight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sel</span><span class="params">(<span class="type">int</span> total)</span> &#123;</span><br><span class="line">            current.addAndGet(-<span class="number">1</span> * total);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLastUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lastUpdate;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastUpdate</span><span class="params">(<span class="type">long</span> lastUpdate)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.lastUpdate = lastUpdate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt; methodWeightMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">updateLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get invoker addr list cached for specified invocation</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;b&gt;for unit test only&lt;/b&gt;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; Collection&lt;String&gt; <span class="title function_">getInvokerAddrList</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, Invocation invocation)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">&quot;.&quot;</span> + invocation.getMethodName();</span><br><span class="line">        Map&lt;String, WeightedRoundRobin&gt; map = methodWeightMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.keySet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> &#123;</span><br><span class="line">        <span class="comment">// key 为 接口名+方法名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">&quot;.&quot;</span> + invocation.getMethodName();</span><br><span class="line">        <span class="comment">// 查看缓存中是否存在相应服务接口的信息，如果没有则新添加一个元素到缓存中</span></span><br><span class="line">        ConcurrentMap&lt;String, WeightedRoundRobin&gt; map = methodWeightMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (map == <span class="literal">null</span>) &#123;</span><br><span class="line">            methodWeightMap.putIfAbsent(key, <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, WeightedRoundRobin&gt;());</span><br><span class="line">            map = methodWeightMap.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 总权重</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalWeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">maxCurrent</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">        <span class="comment">// 当前时间戳</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 最大 current 的 Invoker</span></span><br><span class="line">        Invoker&lt;T&gt; selectedInvoker = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 保存选中的 WeightedRoundRobin 对象</span></span><br><span class="line">        <span class="type">WeightedRoundRobin</span> <span class="variable">selectedWRR</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 遍历 Invokers 列表</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="comment">// 从缓存中获取 WeightedRoundRobin 对象</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">identifyString</span> <span class="operator">=</span> invoker.getUrl().toIdentityString();</span><br><span class="line">            <span class="type">WeightedRoundRobin</span> <span class="variable">weightedRoundRobin</span> <span class="operator">=</span> map.get(identifyString);</span><br><span class="line">            <span class="comment">// 获取当前 Invoker 对象</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> getWeight(invoker, invocation);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前 Invoker 没有对应的 WeightedRoundRobin 对象，则新增一个</span></span><br><span class="line">            <span class="keyword">if</span> (weightedRoundRobin == <span class="literal">null</span>) &#123;</span><br><span class="line">                weightedRoundRobin = <span class="keyword">new</span> <span class="title class_">WeightedRoundRobin</span>();</span><br><span class="line">                weightedRoundRobin.setWeight(weight);</span><br><span class="line">                map.putIfAbsent(identifyString, weightedRoundRobin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前 Invoker 权重不等于对应的 WeightedRoundRobin 对象中的权重，则重新设置当前权重到对应的 WeightedRoundRobin 对象中</span></span><br><span class="line">            <span class="keyword">if</span> (weight != weightedRoundRobin.getWeight()) &#123;</span><br><span class="line">                weightedRoundRobin.setWeight(weight);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 累加权重到 current 中</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">cur</span> <span class="operator">=</span> weightedRoundRobin.increaseCurrent();</span><br><span class="line">            <span class="comment">// 设置 weightedRoundRobin 对象最后更新时间</span></span><br><span class="line">            weightedRoundRobin.setLastUpdate(now);</span><br><span class="line">            <span class="comment">// 最大 current 的 Invoker，并赋值给相应的变量</span></span><br><span class="line">            <span class="keyword">if</span> (cur &gt; maxCurrent) &#123;</span><br><span class="line">                maxCurrent = cur;</span><br><span class="line">                selectedInvoker = invoker;</span><br><span class="line">                selectedWRR = weightedRoundRobin;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 累加权重到总权重中</span></span><br><span class="line">            totalWeight += weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 Invokers 列表中的数量不等于缓存map中的数量</span></span><br><span class="line">        <span class="keyword">if</span> (!updateLock.get() &amp;&amp; invokers.size() != map.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (updateLock.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 拷贝 map 到 newMap 中</span></span><br><span class="line">                    ConcurrentMap&lt;String, WeightedRoundRobin&gt; newMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, WeightedRoundRobin&gt;();</span><br><span class="line">                    newMap.putAll(map);</span><br><span class="line">                    <span class="comment">// newMap 转化为 Iterator</span></span><br><span class="line">                    Iterator&lt;Entry&lt;String, WeightedRoundRobin&gt;&gt; it = newMap.entrySet().iterator();</span><br><span class="line">                    <span class="comment">// 循环删除超过设定时长没更新的缓存</span></span><br><span class="line">                    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                        Entry&lt;String, WeightedRoundRobin&gt; item = it.next();</span><br><span class="line">                        <span class="keyword">if</span> (now - item.getValue().getLastUpdate() &gt; RECYCLE_PERIOD) &#123;</span><br><span class="line">                            it.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将当前newMap服务缓存中</span></span><br><span class="line">                    methodWeightMap.put(key, newMap);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    updateLock.set(<span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果存在被选中的 Invoker</span></span><br><span class="line">        <span class="keyword">if</span> (selectedInvoker != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算 current = current - totalWeight</span></span><br><span class="line">            selectedWRR.sel(totalWeight);</span><br><span class="line">            <span class="keyword">return</span> selectedInvoker;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正常情况这里不会到达</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面选中 Invoker 逻辑为：每个 Invoker 都有一个 current 值，初始值为自身权重。在每个 Invoker 中<code>current = current + weight</code>。遍历完 Invoker 后，current 最大的那个 Invoker 就是本次选中的 Invoker。选中 Invoker 后，将本次 current 值计算<code>current = current - totalWeight</code>。 </p>
<p>以上面<code>192.168.1.10</code>和<code>192.168.1.11</code>两个负载均衡的服务，权重分别为 4、6 。基于选中前<code>current = current + weight</code>、选中后<code>current = current - totalWeight</code>计算公式得出如下</p>
<table>
<thead>
<tr>
<th align="center">请求次数</th>
<th align="center">选中前 current</th>
<th align="center">选中后 current</th>
<th align="center">被选中服务</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">[4, 6]</td>
<td align="center">[4, -4]</td>
<td align="center">192.168.1.11</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">[8, 2]</td>
<td align="center">[-2, 2]</td>
<td align="center">192.168.1.10</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">[2, 8]</td>
<td align="center">[2, -2]</td>
<td align="center">192.168.1.11</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">[6, 4]</td>
<td align="center">[-4, 4]</td>
<td align="center">192.168.1.10</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">[0, 10]</td>
<td align="center">[0, 0]</td>
<td align="center">192.168.1.11</td>
</tr>
</tbody></table>
<h1 id="一致性-Hash-算法"><a href="#一致性-Hash-算法" class="headerlink" title="一致性 Hash 算法"></a>一致性 Hash 算法</h1><p>一致性 Hash 负载均衡策略（ConsistentHashLoadBalance）是让参数相同的请求分配到同一机器上。把每个服务节点分布在一个环上，请求也分布在环形中。以请求在环上的位置，顺时针寻找换上第一个服务节点。如图所示：</p>
<p><img src="https://images.ytao.top/dubbo_loadbalance_hash.png"></p>
<p>同时，为避免请求散列不均匀，dubbo 中会将每个 Invoker 再虚拟多个节点出来，使得请求调用更加均匀。</p>
<p>一致性 Hash 修改配置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;!-- dubbo 默认只对第一个参数进行 <span class="built_in">hash</span> 标识，指定<span class="built_in">hash</span>参数 --&gt;</span><br><span class="line">&lt;dubbo:parameter key=<span class="string">&quot;hash.arguments&quot;</span> value=<span class="string">&quot;1&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 虚拟节点数量 --&gt;</span><br><span class="line">&lt;dubbo:parameter key=<span class="string">&quot;hash.nodes&quot;</span> value=<span class="string">&quot;200&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>一致性 Hash 实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsistentHashLoadBalance</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalance</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;consistenthash&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hash nodes name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HASH_NODES</span> <span class="operator">=</span> <span class="string">&quot;hash.nodes&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hash arguments name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HASH_ARGUMENTS</span> <span class="operator">=</span> <span class="string">&quot;hash.arguments&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt; selectors = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, ConsistentHashSelector&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取请求的方法名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> RpcUtils.getMethodName(invocation);</span><br><span class="line">        <span class="comment">// key = 接口名+方法名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">&quot;.&quot;</span> + methodName;</span><br><span class="line">        <span class="comment">// invokers 的 hashcode</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">identityHashCode</span> <span class="operator">=</span> System.identityHashCode(invokers);</span><br><span class="line">        <span class="comment">// 查看缓存中是否存在对应 key 的数据，或 Invokers 列表是否有过变动。如果没有，则新添加到缓存中，并且返回负载均衡得出的 Invoker</span></span><br><span class="line">        ConsistentHashSelector&lt;T&gt; selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class="line">        <span class="keyword">if</span> (selector == <span class="literal">null</span> || selector.identityHashCode != identityHashCode) &#123;</span><br><span class="line">            selectors.put(key, <span class="keyword">new</span> <span class="title class_">ConsistentHashSelector</span>&lt;T&gt;(invokers, methodName, identityHashCode));</span><br><span class="line">            selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> selector.select(invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ConsistentHashSelector class ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doSelect 中主要实现缓存检查和 Invokers 变动检查，一致性 hash 负载均衡的实现在这个内部类 ConsistentHashSelector 中实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConsistentHashSelector</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储虚拟节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> replicaNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// invoker 列表的 hashcode，用来判断 Invoker 列表是否变化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> identityHashCode;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 请求中用来作Hash映射的参数的索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] argumentIndex;</span><br><span class="line">    </span><br><span class="line">    ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, <span class="type">int</span> identityHashCode) &#123;</span><br><span class="line">        <span class="built_in">this</span>.virtualInvokers = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Long, Invoker&lt;T&gt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.identityHashCode = identityHashCode;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> invokers.get(<span class="number">0</span>).getUrl();</span><br><span class="line">        <span class="comment">// 获取节点数</span></span><br><span class="line">        <span class="built_in">this</span>.replicaNumber = url.getMethodParameter(methodName, HASH_NODES, <span class="number">160</span>);</span><br><span class="line">        <span class="comment">// 获取配置中的 参数索引</span></span><br><span class="line">        String[] index = COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, HASH_ARGUMENTS, <span class="string">&quot;0&quot;</span>));</span><br><span class="line">        argumentIndex = <span class="keyword">new</span> <span class="title class_">int</span>[index.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index.length; i++) &#123;</span><br><span class="line">            argumentIndex[i] = Integer.parseInt(index[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="comment">// 获取 Invoker 中的地址，包括端口号</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> invoker.getUrl().getAddress();</span><br><span class="line">            <span class="comment">// 创建虚拟节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; replicaNumber / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">byte</span>[] digest = md5(address + i);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>; h &lt; <span class="number">4</span>; h++) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> hash(digest, h);</span><br><span class="line">                    virtualInvokers.put(m, invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找出 Invoker</span></span><br><span class="line">    <span class="keyword">public</span> Invoker&lt;T&gt; <span class="title function_">select</span><span class="params">(Invocation invocation)</span> &#123;</span><br><span class="line">        <span class="comment">// 将参数转为字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> toKey(invocation.getArguments());</span><br><span class="line">        <span class="comment">// 字符串参数转换为 md5</span></span><br><span class="line">        <span class="type">byte</span>[] digest = md5(key);</span><br><span class="line">        <span class="comment">// 根据 md5 找出 Invoker</span></span><br><span class="line">        <span class="keyword">return</span> selectForKey(hash(digest, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将参数拼接成字符串</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">toKey</span><span class="params">(Object[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : argumentIndex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; args.length) &#123;</span><br><span class="line">                buf.append(args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buf.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用 md5 匹配到对应的 Invoker</span></span><br><span class="line">    <span class="keyword">private</span> Invoker&lt;T&gt; <span class="title function_">selectForKey</span><span class="params">(<span class="type">long</span> hash)</span> &#123;</span><br><span class="line">        <span class="comment">// 找到第一个大于当前 hash 的 Invoker</span></span><br><span class="line">        Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry = virtualInvokers.ceilingEntry(hash);</span><br><span class="line">        <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">            entry = virtualInvokers.firstEntry();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// hash 运算</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">hash</span><span class="params">(<span class="type">byte</span>[] digest, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (((<span class="type">long</span>) (digest[<span class="number">3</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">2</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">1</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                | (digest[number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>))</span><br><span class="line">                &amp; <span class="number">0xFFFFFFFFL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// md5 运算</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] md5(String value) &#123;</span><br><span class="line">        MessageDigest md5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.reset();</span><br><span class="line">        <span class="type">byte</span>[] bytes = value.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        md5.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> md5.digest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一致 hash 实现过程就是先创建好虚拟节点，虚拟节点保存在 TreeMap 中。TreeMap 的 key 为配置的参数先进行 md5 运算，然后将 md5 值进行 hash 运算。TreeMap 的 value 为被选中的 Invoker。</p>
<p>最后请求时，计算参数的 hash 值，去从 TreeMap 中获取 Invoker。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Dubbo 负载均衡的实现，技巧上还是比较优雅，可以多多学习其编码思维。在研究其代码时，需要仔细研究其实现原理，否则比较难懂其思想。</p>
]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>Dubbo</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 线程通信之 wait/notify 机制</title>
    <url>/2020/05/12/24-thread-wait-notify/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/uiower.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 线程通信是将多个独立的线程个体进行关联处理，使得线程与线程之间能进行相互通信。比如线程 A 修改了对象的值，然后通知给线程 B，使线程 B 能够知道线程 A 修改的值，这就是线程通信。</p>
<span id="more"></span>

<h1 id="wait-notify-机制"><a href="#wait-notify-机制" class="headerlink" title="wait&#x2F;notify 机制"></a>wait&#x2F;notify 机制</h1><p>一个线程调用 Object 的 wait() 方法，使其线程被阻塞；另一线程调用 Object 的 notify()&#x2F;notifyAll() 方法，wait() 阻塞的线程继续执行。</p>
<p>wai&#x2F;notify 方法</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">wait()</td>
<td>当前线程被阻塞，线程进入 WAITING 状态</td>
</tr>
<tr>
<td align="center">wait(long)</td>
<td>设置线程阻塞时长，线程会进入 TIMED_WAITING 状态。如果设置时间内（毫秒）没有通知，则超时返回</td>
</tr>
<tr>
<td align="center">wait(long, int)</td>
<td>纳秒级别的线程阻塞时长设置</td>
</tr>
<tr>
<td align="center">notify()</td>
<td>通知同一个对象上已执行 wait() 方法且获得对象锁的等待线程</td>
</tr>
<tr>
<td align="center">notifyAll()</td>
<td>通知同一对象上所有等待的线程</td>
</tr>
</tbody></table>
<p>实现 wait&#x2F;notify 机制的条件：</p>
<ul>
<li>调用 wait 线程和 notify 线程必须拥有相同对象锁。</li>
<li>wait() 方法和 notify()&#x2F;notifyAll() 方法必须在 Synchronized 方法或代码块中。</li>
</ul>
<p>由于 wait&#x2F;notify 方法是定义在<code>java.lang.Object</code>中，所以在任何 Java 对象上都可以使用。</p>
<h1 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait 方法"></a>wait 方法</h1><p>在执行 wait() 方法前，当前线程必须已获得对象锁。调用它时会阻塞当前线程，进入等待状态，在当前 wait() 处暂停线程。同时，wait() 方法执行后，会立即释放获得的对象锁。</p>
<p>下面通过案例来查看 wait() 释放锁。</p>
<p>首先查看不使用 wait() 方法时的代码执行情况：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.thread.waitnotify;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始线程 A&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;结束线程 A&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始线程 B&quot;</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;结束线程 B&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建 A、B 两个线程，。首先在 B 线程创建后 sleep ，保证 B 线程的打印后于 A 线程执行。在 A 线程中，获取到对象锁后，sleep 一段时间，且时间大于 B 线程的 sleep 时间。</p>
<p>执行结果为：</p>
<p><img src="https://images.ytao.top/thread-wait-notify-nowait.png"></p>
<p>从上图结果中，可以看到，B 线程一定等 A 线程执行完 synchronize 代码块释放对象锁后 A 线程再获取对象锁进入 synchronize 代码块中。在这过程中，Thread.sleep() 方法也不会释放锁。</p>
<p>当前在 A 线程 synchronize 代码块中执行 wait() 方法后，就会主动释放对象锁，A 线程代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始线程 A&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 object 对象的 wait 方法</span></span><br><span class="line">            object.wait();</span><br><span class="line">            Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束线程 A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;线程 A&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://images.ytao.top/thread-wait-notify-wait.png"></p>
<p>同时 A 线程一直处于阻塞状态，不会打印<code>结束线程 A</code>。</p>
<p>wait(long) 方法是设置超时时间，当等待时间大于设置的超时时间后，会继续往 wait(long) 方法后的代码执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始线程 A&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            object.wait(<span class="number">1000</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束线程 A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;线程 A&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>执行结果</p>
<p><img src="https://images.ytao.top/thread-wait-notify-wait-timeout.png"></p>
<p>同理，wait(long, int) 方法与 wait(long) 同样，只是多个纳秒级别的时间设置。</p>
<h1 id="notify-方法"><a href="#notify-方法" class="headerlink" title="notify 方法"></a>notify 方法</h1><p>同样，在执行 notify() 方法前，当前线程也必须已获得线程锁。调用 notify() 方法后，会通知一个执行了 wait() 方法的阻塞等待线程，使该等待线程重新获取到对象锁，然后继续执行 wait() 后面的代码。但是，与 wait() 方法不同，执行 notify() 后，不会立即释放对象锁，而需要执行完 synchronize 的代码块或方法才会释放锁，所以接收通知的线程也不会立即获得锁，也需要等待执行 notify() 方法的线程释放锁后再获取锁。</p>
<h2 id="notify"><a href="#notify" class="headerlink" title="notify()"></a>notify()</h2><p>下面是 notify() 方法的使用，实现一个完整的 wait&#x2F;notify 的例子，同时验证发出通知后，执行 notify() 方法的线程是否立即释放锁，执行 wait() 方法的线程是否立即获取锁。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.thread.waitnotify;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始线程 A&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    object.wait();</span><br><span class="line">                    System.out.println(<span class="string">&quot;A 线程重新获取到锁，继续进行&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;结束线程 A&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始线程 B&quot;</span>);</span><br><span class="line">                object.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 B 通知完线程 A&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 试验执行完 notify() 方法后，A 线程是否能立即获取到锁</span></span><br><span class="line">                    Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;结束线程 B&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上 A 线程执行 wait() 方法，B 线程执行 notify() 方法，执行结果为：</p>
<p><img src="https://images.ytao.top/thread-wait-notify-wait-notify.png"></p>
<p>执行结果中可以看到，B 线程执行 notify() 方法后，即使 sleep 了，A 线程也没有获取到锁，可知，notify() 方法并没有释放锁。</p>
<p>notify() 是通知到等待中的线程，但是调用一次 notify() 方法，只能通知到一个执行 wait() 方法的等待线程。如果有多个等待状态的线程，则需多次调用 notify() 方法，通知到线程顺序则根据执行 wait() 方法的先后顺序进行通知。</p>
<p>下面创建有两个执行 wait() 方法的线程的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.thread.waitnotify;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiWaitNotifyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始线程 A&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    object.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;结束线程 A&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始线程 B&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    object.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;结束线程 B&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始通知线程 C&quot;</span>);</span><br><span class="line">                object.notify();</span><br><span class="line">                object.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;结束通知线程 C&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先 A 线程执行 wait() 方法，然后 B 线程执行 wait() 方法，最后 C 线程调用两次 notify() 方法，执行结果：</p>
<p><img src="https://images.ytao.top/thread-wait-notify-multi-wait-notify.png"></p>
<h2 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll()"></a>notifyAll()</h2><p>通知多个等待状态的线程，通过多次调用 notify() 方法实现的方案，在实际应用过程中，实现过程不太友好，如果是想通知所有等待状态的线程，可使用 notifyAll() 方法，就能唤醒所有线程。</p>
<p>实现方式，只需将上面 C 线程的多次调用 notify() 方法部分改为调用一次 notifyAll() 方法即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始通知线程 C&quot;</span>);</span><br><span class="line">        object.notifyAll();</span><br><span class="line">        System.out.println(<span class="string">&quot;结束通知线程 C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;线程 C&quot;</span>).start();</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://images.ytao.top/thread-wait-notify-wait-notifyall.png"></p>
<p>根据不同 JVM 的实现，notifyAll() 的唤醒顺序会有所不同，当前测试环境中，以倒序顺序唤醒线程。</p>
<h1 id="实现生产者消费者模式"><a href="#实现生产者消费者模式" class="headerlink" title="实现生产者消费者模式"></a>实现生产者消费者模式</h1><p>生产消费者模式就是一个线程生产数据进行存储，另一线程进行数据提取消费。下面就以两个线程来模拟，生产者生成一个 UUID 存放到 List 对象中，消费者读取 List 对象中的数据，读取完成后进行清除。</p>
<p>实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.thread.waitnotify;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyModelTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储生产者产生的数据</span></span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">                    <span class="comment">// 判断 list 中是否有数据，如果有数据的话，就进入等待状态，等数据消费完</span></span><br><span class="line">                    <span class="keyword">if</span> (list.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            list.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// list 中没有数据时，产生数据添加到 list 中</span></span><br><span class="line">                    list.add(UUID.randomUUID().toString());</span><br><span class="line">                    list.notify();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;生产者线程 A &quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">                    <span class="comment">// 如果 list 中没有数据，则进入等待状态，等收到有数据通知后再继续运行</span></span><br><span class="line">                    <span class="keyword">if</span> (list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            list.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 有数据时，读取数据</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + list);</span><br><span class="line">                    list.notify();</span><br><span class="line">                    <span class="comment">// 读取完毕，将当前这条 UUID 数据进行清除</span></span><br><span class="line">                    list.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;消费者线程 B &quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://images.ytao.top/thread-wait-notify-wait-notify-model.png"></p>
<p>生产者线程运行时，如果已存在未消费的数据，则当前线程进入等待状态，收到通知后，表明数据已消费完，再继续向 list 中添加数据。</p>
<p>消费者线程运行时，如果不存在未消费的数据，则当前线程进入等待状态，收到通知后，表明 List 中已有新数据被添加，继续执行代码消费数据并清除。</p>
<p>不管是生产者还是消费者，基于对象锁，一次只能一个线程能获取到，如果生产者获取到锁就校验是否需要生成数据，如果消费者获取到锁就校验是否有数据可消费。</p>
<p>一个简单的生产者消费者模式就以完成。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>等待&#x2F;通知机制是实现 Java 线程间通信的一种方式，将多线程中，各个独立运行的线程通过相互通信来更高效的协作完成工作，更大效率利用 CPU 处理程序。这也是学习或研究 Java 线程的必学知识点。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 多线程中使用 JDK 自带工具类实现计数器</title>
    <url>/2020/05/17/25-thread-count/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/iupmg.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在实际开发过程中，经常遇到需要多线程并行的业务，最后需要进行将各个线程完成的任务进行汇总，但主线程一般会早于子线程结束，如果要想等各个子线程完成后再继续运行主线程，这时就需要对各个线程是否执行完成进行标识，JDK 并发包中就给开发者提供了几个不错的使用工具类。</p>
<p>接下来将通过 Thread#join 方法以及 CountDownLatch、CyclicBarrier 类进行上面案例方案的分析。</p>
<span id="more"></span>

<h1 id="Thread-join-方法"><a href="#Thread-join-方法" class="headerlink" title="Thread#join 方法"></a>Thread#join 方法</h1><p>使用 join() 方法的子线程对象正常执行 run() 中代码，但当前线程会被无超时阻塞，等待执行 join() 方法的线程销毁后，继续执行被阻塞的当前线程。join() 方法阻塞原理是该方法内使用 wait() 方法阻塞，源码如下所示：</p>
<p><img src="https://images.ytao.top/thread-count-join.png"></p>
<p>子线程 join() 完成时会调用 notifyAll() 来通知当前线程继续执行接下来的代码。</p>
<p>假如现在有两个线程产生数据结果，最后将两个线程结果进行相加，如果直接将两个线程执行并进行汇总，如下实现代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.thread.count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * htpps://ytao.top</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Created by YangTao on 2020/5/17 0017.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinTest</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            map.put(<span class="string">&quot;thread1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;run thread1&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            map.put(<span class="string">&quot;thread2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;run thread2&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;thread1&quot;</span>) + map.get(<span class="string">&quot;thread2&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end....&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://images.ytao.top/thread-count-nojoin.png"></p>
<p>由于主线程的汇总计算可能早于子线程完成，所以这时获取子线程结果为空指针异常。</p>
<p>通过增加 join() 方法实现阻塞主线程，等待子线程完成后再进行汇总：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.thread.count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * htpps://ytao.top</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Created by YangTao on 2020/5/17 0017.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinTest</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            map.put(<span class="string">&quot;thread1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;run thread1&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            map.put(<span class="string">&quot;thread2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;run thread2&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 两个线程分别调用 join() 方法，使主线程被阻塞</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;thread1&quot;</span>) + map.get(<span class="string">&quot;thread2&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end....&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果为：</p>
<p><img src="https://images.ytao.top/thread-count-hasjoin.png"></p>
<p>通过结果可以看到子线程汇总求和为 3。此时主线程在两个子线程销毁前都处于等待状态，直至两个销毁后主线程再执行汇总求和，所以两个线程产生的值都已存在。</p>
<p>同时，子线程 join() 方法可以使当前线程无期限等待，也可以设置最长等待时长 join(long) 方法，无论子线程是否执行完成，当前线程会继续执行后面代码。使用方法加入超时参数即可，其它与 join() 方法使用相同。</p>
<h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>CountDownLatch 可以使一个或多个线程等待其他线程完成操作后再继续执行当前线程后面代码。</p>
<p>CountDownLatch 的使用：首先创建 CountDownLatch 对象，通过传入参数 int 构造 CountDownLatch 对象。该参数是值将要等待的执行点的数量。</p>
<p>CountDownLatch 中有几个方法：</p>
<ul>
<li><strong>getCount()</strong> 返回当前计数器数，即当前剩余的等待数量。官方解释说该方法通常用于调试和测试目的。</li>
<li><strong>countDown</strong> 每调用一次，计数器便会进行减 1 操作，但计数器必须大于 0。</li>
<li><strong>await</strong> 该方法会阻塞当前线程，直至计数器为 0 时，就会不再阻塞当前线程。同时也提供 await(long timeout, TimeUnit unit) 方法，可设置超时时间。</li>
</ul>
<p>利用 CountDownLatch 实现汇总求和案例，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.thread.count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://ytao.top</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by YangTao on 2020/5/17 0017.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            map.put(<span class="string">&quot;thread1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;run thread1&quot;</span>);</span><br><span class="line">            count.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            map.put(<span class="string">&quot;thread2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;run thread2&quot;</span>);</span><br><span class="line">            count.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一直阻塞当前线程，直至计数器为 0</span></span><br><span class="line">        count.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;thread1&quot;</span>) + map.get(<span class="string">&quot;thread2&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end.... getCount: &quot;</span> + count.getCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<p><img src="https://images.ytao.top/thread-count-countdownlatch.png"></p>
<p>上图中求和结果为 3，同时计数器为 0。</p>
<p>通过查看 CountDownLatch 源码，主要是通过一个继承 AbstractQueuedSynchronizer 类的内部类 Sync 来实现的，可知其实现原理为 AQS，这里不进行展开讲述。</p>
<h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p>CyclicBarrier 是一个可循环使用的屏障。实现原理解释，就是在一个或多个线程运行中设置一个屏障，线程到达这个屏障时会被阻塞，直到最后一个线程到达时，被屏障阻塞的线程继续执行。</p>
<p>CyclicBarrier 构造方法有两个，<code>CyclicBarrier(int count)</code>和<code>CyclicBarrier(int count, Runnable barrierAction)</code>:</p>
<ul>
<li>单个<code>int</code>参数构造方法，表示构造到达屏障线程的数量。</li>
<li>一个<code>int</code>和一个<code>Runnable</code>参数构造方法，前者参数表示到达屏障线程的数量，后者参数表示所有线程到达屏障后接下来要执行的代码;</li>
</ul>
<p>CyclicBarrier 中方法：</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">await()</td>
<td>阻塞前线程，等待 trip.signal() 或 trip.signalAll() 方法唤醒</td>
</tr>
<tr>
<td align="center">await(long, TimeUnit)</td>
<td>在 await() 上增加两个参数，等待超时时间 timeout，单位为 unit</td>
</tr>
<tr>
<td align="center">breakBarrier()</td>
<td>放开屏障，设置标志，唤醒被屏障阻塞的线程</td>
</tr>
<tr>
<td align="center">isBroken()</td>
<td>阻塞的线程是否被中断</td>
</tr>
<tr>
<td align="center">reset()</td>
<td>重置 CyclicBarrier 对象</td>
</tr>
<tr>
<td align="center">getNumberWaiting()</td>
<td>当前被阻塞线程的数量</td>
</tr>
<tr>
<td align="center">getParties()</td>
<td>到达屏障的线程总数量，即创建时指定的数量</td>
</tr>
</tbody></table>
<p>使用 CyclicBarrier 实现上面汇总：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.thread.count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://ytao.top</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by YangTao on 2020/5/17 0017.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> BrokenBarrierException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="comment">// 所有线程到达屏障后，需要执行的代码</span></span><br><span class="line">            System.out.println(map.get(<span class="string">&quot;thread1&quot;</span>) + map.get(<span class="string">&quot;thread2&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;CyclicBarrier end.... &quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            map.put(<span class="string">&quot;thread1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;run thread1&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            map.put(<span class="string">&quot;thread2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;run thread2&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://images.ytao.top/thread-count-cyclicbarrier.png"></p>
<p>执行完两条子线程，并且在子线程里调用<code>barrier.await()</code>后，屏障被打开，最后执行 CyclicBarrier 的最后的代码逻辑。</p>
<p>通过上面 CyclicBarrier 的方法可知，CyclicBarrier 比 CountDownLatch 使用更加灵活，CyclicBarrier 的 reset() 方法可以重置计数器，而 CountDownLatch 则只能使用一次。同时，CyclicBarrier 拥有更多线程阻塞信息的方法提供使用，在使用过程中，提供更加灵活的使用方式。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面三种方式，均由 JDK 的并发包中提供的工具。在多线程协作任务中，对计数器场景问题的解决方案，实现 main 线程对 worker 线程的等待完成。在实际开发应用中，使用频率也是非常之高。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 安装及文档的基本操作</title>
    <url>/2020/05/31/26-mongodb-install-base/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/mongoDB.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MongoDB 是一个基于分布式文件存储的半结构化的非关系型数据库。在海量数据中，可以较高性能的处理存取操作。它是以 BSON 格式进行数据存储（类似 JSON 格式，但类型更为丰富），因此对于复杂的数据类型，可以较轻松的保存和处理。同时，在非关系型数据库阵容中，相比其他数据库产品，它拥有更丰富的功能，并且与关系型数据库类型，所以对于新手使用也能快速上手。</p>
<span id="more"></span>

<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote>
<p>环境：CentOS 7<br>版本号：4.2.6 企业版<br>版本：免安版（TGZ）</p>
</blockquote>
<h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><p>访问官网链接下载链接：<a href="https://www.mongodb.com/download-center/enterprise">https://www.mongodb.com/download-center/enterprise</a></p>
<p>我这里使用的是企业版，下载选项如图：</p>
<p><img src="https://images.ytao.top/mongoDB-download.png"></p>
<p>下载后得到压缩包 mongodb-linux-x86_64-enterprise-rhel70-4.2.6.tgz</p>
<p>将下载的压缩包上传至对应目录，然后进行解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; tar -zxvf mongodb-linux-x86_64-enterprise-rhel70-4.2.6.tgz</span><br></pre></td></tr></table></figure>

<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>当前使用的是免安版，所以 mongoDB 的配置文件需要自己手动创建。如果使用的是安装版，安装后配置文件会在 &#x2F;etc&#x2F;mongod.conf 中。</p>
<p>创建配置前，先创建 data、log、run 三个目录，分别对应的数据存储目录、日志目录、进程 ID 保存目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">mkdir</span> -p /var/mongodb/data</span><br><span class="line">&gt; <span class="built_in">mkdir</span> -p /var/mongodb/log</span><br><span class="line">&gt; <span class="built_in">mkdir</span> -p /var/mongodb/run</span><br></pre></td></tr></table></figure>

<p>创建 mongod.conf 在 &#x2F;var&#x2F;mongodb 目录中，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mongod.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for documentation of all options, see:</span></span><br><span class="line"><span class="comment">#   http://docs.mongodb.org/manual/reference/configuration-options/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># where to write logging data.</span></span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: <span class="literal">true</span></span><br><span class="line">  path: /var/mongodb/log/mongo.log <span class="comment"># 日志文件路径设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Where and how to store data.</span></span><br><span class="line">storage:</span><br><span class="line">  dbPath: /var/mongodb/data <span class="comment"># 数据存储路径</span></span><br><span class="line">  journal:</span><br><span class="line">    enabled: <span class="literal">true</span></span><br><span class="line"><span class="comment">#  engine:</span></span><br><span class="line"><span class="comment">#  wiredTiger:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># how the process runs</span></span><br><span class="line">processManagement:</span><br><span class="line">  fork: <span class="literal">true</span>  <span class="comment"># fork and run in background</span></span><br><span class="line">  pidFilePath: /var/mongodb/run/mongod.pid  <span class="comment"># location of pidfile  </span></span><br><span class="line">  timeZoneInfo: /usr/share/zoneinfo</span><br><span class="line"></span><br><span class="line"><span class="comment"># network interfaces</span></span><br><span class="line">net:</span><br><span class="line">  port: 27017 <span class="comment"># 端口号</span></span><br><span class="line">  bindIp: 127.0.0.1  <span class="comment"># 监听 IP ，即可访问 IP，默认是本机</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  authorization: enabled</span><br><span class="line">  </span><br><span class="line"><span class="comment">#operationProfiling:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#replication:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sharding:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Enterprise-Only Options</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#auditLog:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#snmp:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置文件常用基本属性：</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">systemLog#destination</td>
<td>日志输出位置，file 或 syslog，使用 file 时，必须指定 path</td>
</tr>
<tr>
<td align="center">systemLog#logAppend</td>
<td>当实例启动时日志是否追加写入到现有日志中</td>
</tr>
<tr>
<td align="center">systemLog#path</td>
<td>日志存放路径</td>
</tr>
<tr>
<td align="center">storage#dbPath</td>
<td>数据存储路径</td>
</tr>
<tr>
<td align="center">storage#journal#enabled</td>
<td>日志是否永久性，可以用来恢复数据</td>
</tr>
<tr>
<td align="center">processManagement#fork</td>
<td>是否后台运行服务</td>
</tr>
<tr>
<td align="center">processManagement#pidFilePath</td>
<td>pid 文件的存储路径</td>
</tr>
<tr>
<td align="center">processManagement#timeZoneInfo</td>
<td>数据库使用的时区路径</td>
</tr>
<tr>
<td align="center">net#port</td>
<td>数据使用的端口</td>
</tr>
<tr>
<td align="center">net#bindIp</td>
<td>监听客户端连接的 IP，即可访问的 IP</td>
</tr>
<tr>
<td align="center">security#authorization</td>
<td>是否启动权限管控</td>
</tr>
</tbody></table>
<h2 id="服务启停"><a href="#服务启停" class="headerlink" title="服务启停"></a>服务启停</h2><p>将解压后的安装包 bin 路径添加到环境变量 &#x2F;etc&#x2F;profile 中，在 PATH 上进行追加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mongoDB</span></span><br><span class="line">PATH=<span class="variable">$PATH</span>:/usr/local/software/mongoDB/mongodb-linux-x86_64-enterprise-rhel70-4.2.6/bin</span><br></pre></td></tr></table></figure>

<p>使用 &#x2F;var&#x2F;mongodb&#x2F;mongod.conf 配置文件启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; mongod -f /var/mongodb/mongodb.conf</span><br></pre></td></tr></table></figure>

<p>如图所示，则启动成功</p>
<p><img src="https://images.ytao.top/mongoDB-successfully.png"></p>
<p>启动完成后，验证是否正常运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; mongo</span><br></pre></td></tr></table></figure>

<p>如果正常运行，则进入登录页面</p>
<p><img src="https://images.ytao.top/mongoDB-login-ui.png"></p>
<p>创建账号，并设置角色为 root</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; use admin</span><br><span class="line">&gt; db.createUser(&#123;user:<span class="string">&quot;xxxx&quot;</span>,<span class="built_in">pwd</span>:<span class="string">&quot;xxxxxx&quot;</span>,roles:[<span class="string">&quot;root&quot;</span>]&#125;)</span><br></pre></td></tr></table></figure>

<p>设置账号后，重新登录，此时需要进行账号权限校验</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; mongo -u accont -p password</span><br></pre></td></tr></table></figure>

<p>停止 MongoDB 服务，必须切换到 admin 数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; use admin</span><br><span class="line">&gt; db.shutdownServer()</span><br></pre></td></tr></table></figure>

<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>在介绍几本操作之前，现将常用的 MongoDB 对象与关系型数据库进行类比，便于更好理解 MongoDB 对象。</p>
<table>
<thead>
<tr>
<th align="center">MongoDB</th>
<th>关系型数据库</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Database（数据库）</td>
<td>Database（数据库）</td>
</tr>
<tr>
<td align="center">Collection（集合）</td>
<td>Table（表）</td>
</tr>
<tr>
<td align="center">Document（文档）</td>
<td>Row（行）</td>
</tr>
<tr>
<td align="center">Field（字段）</td>
<td>Column（列）</td>
</tr>
</tbody></table>
<h2 id="Database-的操作"><a href="#Database-的操作" class="headerlink" title="Database 的操作"></a>Database 的操作</h2><p>数据创建和选择，都是使用<code>use db</code>命令</p>
<p>查看所有数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; show dbs</span><br></pre></td></tr></table></figure>

<p>删除数据库，先选择再删除</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; use db</span><br><span class="line">&gt; db.dropDatabase()</span><br></pre></td></tr></table></figure>

<h2 id="Collection-的操作"><a href="#Collection-的操作" class="headerlink" title="Collection 的操作"></a>Collection 的操作</h2><p>创建集合命令，同时，如果没有先创建集合，插入数据时会自动创建集合</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; db.createCollection(collectionName, [options])</span><br></pre></td></tr></table></figure>

<p>其中<code>options</code>为可选参数，主要是数据的校验规则，这里不展开分析。</p>
<p>查看数据库中所有集合</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; show collections</span><br></pre></td></tr></table></figure>

<p>选择集合</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; db.getCollection(collectionName)</span><br><span class="line">或</span><br><span class="line">&gt; db.collectionName</span><br></pre></td></tr></table></figure>

<p>删除集合</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; db.collectionName.drop()</span><br></pre></td></tr></table></figure>

<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>MongoDB 插入方法有 <strong>insertOne()、insertMany()、insert()、save()</strong> 。其中 insert() 功能就包括了 insertOne() 和 insertMany() 功能。</p>
<h3 id="insertOne"><a href="#insertOne" class="headerlink" title="insertOne"></a>insertOne</h3><p>insertOne() 是向数据库中插入一个文档，语法格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collect.insertOne(</span><br><span class="line">    &lt;document&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        writeConcern: &lt;document&gt;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>指令 insertOne() 中参数： </p>
<ul>
<li>document 参数为 插入的 BSON 数据</li>
<li>writeConcern 为写入策略，是可选参数</li>
</ul>
<p>向 MongoDB 的 ytao 数据库中，插入一条 article 集合的数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.article.insertOne(</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">&quot;Dubbo 负载均衡的实现&quot;</span>,</span><br><span class="line">        url: <span class="string">&quot;https://ytao.top/2020/05/02/23-dubbo-loadbalance/&quot;</span>,</span><br><span class="line">        author: <span class="string">&quot;ytao&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>数据库数据为：</p>
<p><img src="https://images.ytao.top/mongoDB-insertOne-data.png"></p>
<p><strong>注意：</strong> 如果插入数据时，没指定 _id ，则会自动生成 _id ；如果指定 _id ，则必须 _id 在数据库中存在，否则会报错插入失败。</p>
<h3 id="insertMany"><a href="#insertMany" class="headerlink" title="insertMany"></a>insertMany</h3><p>insertMany() 方法是一次插入多个文档，语法格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collect.insertMany(</span><br><span class="line">    [&lt;document 1&gt;, &lt;document 2&gt;],</span><br><span class="line">    &#123;</span><br><span class="line">        writeConcern: &lt;document&gt;,</span><br><span class="line">        ordered: &lt;boolean&gt;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>参数<code>ordered</code>为是否有序插入文档，可选参数，默认 true。</p>
<p>向 MongoDB 的 ytao 数据库中，插入了两条 article 集合的数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.article.insertMany(</span><br><span class="line">    [</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">&quot;Netty中粘包/拆包处理&quot;</span>,</span><br><span class="line">        url: <span class="string">&quot;https://ytao.top/2019/12/09/10-netty/&quot;</span>,</span><br><span class="line">        author: <span class="string">&quot;ytao&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">&quot;WebSocket实现Web端即时通信&quot;</span>,</span><br><span class="line">        url: <span class="string">&quot;https://ytao.top/2019/11/17/7_websocket/&quot;</span>,</span><br><span class="line">        author: <span class="string">&quot;ytao&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>插入后的数据</p>
<p><img src="https://images.ytao.top/mongoDB-insertMany-data.png"></p>
<p>同理，与 insertOne() 相同，插入重复插入已存在的 _id ，否则报错。</p>
<h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>insert() 可以插入单个或多个文档，<strong>这个也是最较为常用的方法</strong>，其语法为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collect.insert(</span><br><span class="line">    &lt;document&gt; or [&lt;document 1&gt;, &lt;document 2&gt;],</span><br><span class="line">    &#123;</span><br><span class="line">        writeConcern: &lt;document&gt;,</span><br><span class="line">        ordered: &lt;boolean&gt;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>插入的文档如果是单个，则类似 insertOne() 的插入方式；如果插入的文档是多个，则类似 insertMany() 的插入方式。其中参数 writeConcern 和 ordered 都是一样。</p>
<h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><p>save() 也可以进行数据插入，当新插入的 _id 存在时，会将已存在的文档进行覆盖，如果 _id 不存在时，则类似 insertOne() 的方式插入。其操作语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collect.save(</span><br><span class="line">    &lt;document&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        writeConcern: &lt;document&gt;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>进行更新的方法有 ** updateOne()、updateMany()、update()、replaceOne() 以及 save() **。其中 update() 包括 updateOne() 和 updateMany() 的功能。</p>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>通过 update() 可以更新一个或多个文档，其语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">    &lt;query&gt;,</span><br><span class="line">    &lt;update&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        upsert: &lt;boolean&gt;,</span><br><span class="line">        multi: &lt;boolean&gt;,</span><br><span class="line">        writeConcern &lt;document&gt;,</span><br><span class="line">        collation: &lt;document&gt;,</span><br><span class="line">        arrayFilters: [&lt;filter1&gt;,&lt;filter2&gt;]</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>update 的参数：</p>
<ul>
<li>query：要更新文档的查询条件</li>
<li>update：要更新的字段</li>
<li>upsert：默认为 false。当设置 true 时，如果更新的条件没有匹配到数据时，则插入此更新条件。反之，设为 false 时，则不插入。</li>
<li>multi：默认为 false。当查询条件匹配到多条数据时，如果设置为 true，则会更新所有匹配的数据；如果设置为 false，则更新匹配出的第一条数据。</li>
<li>writeConcern：和上面 insert 的参数一样。</li>
<li>collation：更新数据的排序规则。</li>
<li>arrayFilters：更新数据中数组格式数据的某个特定元素。</li>
</ul>
<p>接下来就演示两个例子，一个普通更新，一个带使用 arrayFilters 数据的更新，这个比较难说明，但通过例子就容易理解。</p>
<p>更新前数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5ed299cee89845fb9ec805e4&quot;</span>),</span><br><span class="line">    <span class="string">&quot;title&quot;</span> : <span class="string">&quot;WebSocket实现Web端即时通信&quot;</span>,</span><br><span class="line">    <span class="string">&quot;url&quot;</span> : <span class="string">&quot;https://ytao.top/2019/11/17/7_websocket/&quot;</span>,</span><br><span class="line">    <span class="string">&quot;author&quot;</span> : <span class="string">&quot;ytao&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>案例一</strong> 将<code>author</code>数据更新为<code>[&quot;杨滔&quot;, &quot;ytao&quot;]</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.article.update(</span><br><span class="line">    &#123;title: <span class="string">&quot;WebSocket实现Web端即时通信&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="variable">$set</span>: &#123;author: [<span class="string">&quot;杨滔&quot;</span>, <span class="string">&quot;ytao&quot;</span>]&#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>案例二</strong> 将<code>author</code>数据<code>[&quot;杨滔&quot;, &quot;ytao&quot;]</code>的<code>杨滔</code>更新为<code>YangTao</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.article.update(</span><br><span class="line">    &#123;title: <span class="string">&quot;WebSocket实现Web端即时通信&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="variable">$set</span>: &#123;<span class="string">&quot;author.$[idx]&quot;</span>: <span class="string">&quot;YangTao&quot;</span>&#125;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        arrayFilters:[</span><br><span class="line">            &#123;<span class="string">&quot;idx&quot;</span>: &#123;<span class="variable">$eq</span>: <span class="string">&quot;杨滔&quot;</span>&#125;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面<code>idx</code>表示数组中元素的位置。</p>
<p>更新后的数据</p>
<p><img src="https://images.ytao.top/mongoDB-update-arrayfilters.png"></p>
<h3 id="updateOne"><a href="#updateOne" class="headerlink" title="updateOne"></a>updateOne</h3><p>updateOne() 只能更新一个文档，和 update() 使用类似，将<code>multi</code>参数值为 false 一样，这里不再使用案例演示。</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection.updateOne(</span><br><span class="line">   &lt;filter&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;,</span><br><span class="line">     collation: &lt;document&gt;,</span><br><span class="line">     arrayFilters: [ &lt;filterdocument1&gt;, ... ],</span><br><span class="line">     hint:  &lt;document|string&gt; </span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>hint</code>是<code>4.2.1</code>版本中新增的参数，用于指定更新文档的索引。</p>
<h3 id="updateMany"><a href="#updateMany" class="headerlink" title="updateMany"></a>updateMany</h3><p>updateMany() 同样和 update() 更新多个文档使用一样。</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection.updateMany(</span><br><span class="line">   &lt;filter&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;,</span><br><span class="line">     collation: &lt;document&gt;,</span><br><span class="line">     arrayFilters: [ &lt;filterdocument1&gt;, ... ],</span><br><span class="line">     hint:  &lt;document|string&gt; </span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="replaceOne"><a href="#replaceOne" class="headerlink" title="replaceOne"></a>replaceOne</h3><p>replaceOne 将一个文档完全覆盖，并且不需要指定 _id。只能覆盖一个文档。</p>
<p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection.replaceOne(</span><br><span class="line">   &lt;filter&gt;,</span><br><span class="line">   &lt;replacement&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;,</span><br><span class="line">     collation: &lt;document&gt;,</span><br><span class="line">     hint: &lt;document|string&gt; </span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="save-1"><a href="#save-1" class="headerlink" title="save"></a>save</h3><p>save() 在更新中是指定 _id 的方式进行文档覆盖。即上文插入中的 save() 用法。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除文档的方法有 <strong>deleteOne()、deleteMany()、remove()</strong></p>
<h3 id="deleteOne"><a href="#deleteOne" class="headerlink" title="deleteOne"></a>deleteOne</h3><p>deleteOne() 一次只能删除一个文档，其语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection.deleteOne(</span><br><span class="line">   &lt;filter&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">      writeConcern: &lt;document&gt;,</span><br><span class="line">      collation: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>filter</code>为删除文档的过滤条件。</p>
<h3 id="deleteMany"><a href="#deleteMany" class="headerlink" title="deleteMany"></a>deleteMany</h3><p>deleteMany() 一次可删除多个匹配到的文档，其语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection.deleteMany(</span><br><span class="line">   &lt;filter&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">      writeConcern: &lt;document&gt;,</span><br><span class="line">      collation: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>remove() 是删除查询出的文档，其语法有两个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;justOne&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     justOne: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;,</span><br><span class="line">     collation: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>justOne</code>参数默认为 false，表示删除全部匹配到的数据；true 表示只删除第一个文档</p>
<h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>MongoDB 中常用的基本查询有 ** findOne() ** 和 ** find() **。</p>
<h3 id="findOne"><a href="#findOne" class="headerlink" title="findOne"></a>findOne</h3><p>findOne() 只返回匹配到的第一个文档，语法为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection.findOne(</span><br><span class="line">    &lt;query&gt;, </span><br><span class="line">    &lt;projection&gt;</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>query 表示查询条件。</li>
<li>projection 表示返回的字段（Field）。</li>
</ul>
<p>下面查询一个文档，并且只返回<code>title</code>和<code>url</code></p>
<p><img src="https://images.ytao.top/mongoDB-findOne.png"></p>
<p>通过指定字段的 value 为 1，即表示查询后返回的字段。</p>
<h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>find() 是返回所有匹配到的集合，语法为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection.find(</span><br><span class="line">    &lt;query&gt;, </span><br><span class="line">    &lt;projection&gt;</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>下面案例查询查询结果：</p>
<p><img src="https://images.ytao.top/mongoDB-find.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>本文对 MongoDB 的入门和基本操作进行了简单的了解，在这使用过程中，有点类似关系型数据库操作的影子，所以对有关系型数据库使用经验的人，上手是较为简单的。</p>
</blockquote>
<p>更多使用操作，官方文档：<a href="https://docs.mongodb.com/manual/reference/">https://docs.mongodb.com/manual/reference/</a></p>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB 常用查询操作</title>
    <url>/2020/06/14/27-mongodb-query/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/mongoDB.jpg"></p>
<blockquote>
<p>MongoDB 查询操作可实现大部分关系型数据库的常用查询操作，本文对 MongoDB 常用查询进行讲解。</p>
</blockquote>
<span id="more"></span>

<p>在阅读本文前，推荐先阅读<a href="https://ytao.top/2020/05/31/26-mongodb-install-base/">《MongoDB 安装及文档的基本操作》</a></p>
<p>在进行操作讲解前，先展示当前 MongoDB 中已存在的文档，集合名称<code>article</code><br><img src="https://images.ytao.top/mongodb-query.png"></p>
<h1 id="条件大小比较操作"><a href="#条件大小比较操作" class="headerlink" title="条件大小比较操作"></a>条件大小比较操作</h1><p>查询文档时，对条件的大小、范围进行过滤查询，以下是常用比较操作符</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$eq</td>
<td>查询与条件值相等的文档，类似关系型数据库的 &#x3D;</td>
</tr>
<tr>
<td align="center">$ne</td>
<td>查询与条件值不相等或不存在的文档，类似关系型数据库的 !&#x3D;</td>
</tr>
<tr>
<td align="center">$gt</td>
<td>查询大于条件值的文档，类似关系型数据库的 &gt;</td>
</tr>
<tr>
<td align="center">$gte</td>
<td>查询大于或等于条件值的文档，类似关系型数据库的 &gt;&#x3D;</td>
</tr>
<tr>
<td align="center">$lt</td>
<td>查询小于条件值的文档，类似关系型数据库的 &lt;</td>
</tr>
<tr>
<td align="center">$lte</td>
<td>查询小于或等于条件值的文档，类似关系型数据库的 &lt;&#x3D;</td>
</tr>
<tr>
<td align="center">$in</td>
<td>查询 $in 数据里值的文档，类似关系型数据库的 in</td>
</tr>
<tr>
<td align="center">$nin</td>
<td>与 $in 查询相反，类似关系型数据库的 not in</td>
</tr>
</tbody></table>
<p>由于使用大于、小于、等于关系都差不多，比较好理解，这里就举一个例子说明，使用<code>$gte</code>来获取大于或等于<code>150</code>的 visitor</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.article.find(&#123;<span class="string">&quot;visitor&quot;</span>: &#123;<span class="variable">$gte</span>:150&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://images.ytao.top/mongodb-query-gte.png"></p>
<p>使用<code>$in</code>时，必须用数组来设置条件值，比如获取 visitor 为<code>70</code>和<code>150</code>的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.article.find(&#123;<span class="string">&quot;visitor&quot;</span>: &#123;<span class="variable">$in</span>:[70, 150]&#125;&#125;)</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://images.ytao.top/mongodb-query-in.png"></p>
<h1 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h1><p>多条件查询中，条件与条件连接符号叫做逻辑操作符。常用操作符：</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$and</td>
<td>表示所有条件同时满足时成立</td>
</tr>
<tr>
<td align="center">$nor</td>
<td>与<code>$and</code>相反，所有条件都不满足时成立</td>
</tr>
<tr>
<td align="center">$or</td>
<td>只要有一个条件满足则成立</td>
</tr>
<tr>
<td align="center">$not</td>
<td>表示字段存在并且不符合条件</td>
</tr>
</tbody></table>
<p><code>$and</code> 查询<code>author=ytao</code>且<code>visitor=150</code>的文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.article.find(</span><br><span class="line">    &#123;<span class="variable">$and</span>:[</span><br><span class="line">      &#123;<span class="string">&quot;author&quot;</span>:&#123;<span class="variable">$eq</span>:<span class="string">&quot;ytao&quot;</span>&#125;&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;visitor&quot;</span>:&#123;<span class="variable">$eq</span>:150&#125;&#125;</span><br><span class="line">    ]&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>$nor</code>查询不是<code>author=ytao</code>和不是<code>visitor=170</code>的文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.article.find(</span><br><span class="line">    &#123;<span class="variable">$nor</span>:[</span><br><span class="line">      &#123;<span class="string">&quot;author&quot;</span>:&#123;<span class="variable">$eq</span>:<span class="string">&quot;ytao&quot;</span>&#125;&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;visitor&quot;</span>:&#123;<span class="variable">$eq</span>:170&#125;&#125;</span><br><span class="line">    ]&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>$or</code>查询<code>author=ytao</code>或<code>visitor=170</code>的文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.article.find(</span><br><span class="line">    &#123;<span class="variable">$or</span>:[</span><br><span class="line">      &#123;<span class="string">&quot;author&quot;</span>:&#123;<span class="variable">$eq</span>:<span class="string">&quot;ytao&quot;</span>&#125;&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;visitor&quot;</span>:&#123;<span class="variable">$eq</span>:170&#125;&#125;</span><br><span class="line">    ]&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>$not</code>查询不是<code>author=ytao</code>的文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.article.find(</span><br><span class="line">    &#123;<span class="string">&quot;author&quot;</span>:&#123;<span class="variable">$not</span>:&#123;<span class="variable">$eq</span>:<span class="string">&quot;ytao&quot;</span>&#125;&#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="元素操作符"><a href="#元素操作符" class="headerlink" title="元素操作符"></a>元素操作符</h1><p>对字段元素上的操作符叫做元素操作符</p>
<table>
<thead>
<tr>
<th align="center">操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$exists</td>
<td>判断文档中字段是否存在，<code>true</code>为存在，<code>false</code>为不存在</td>
</tr>
<tr>
<td align="center">$type</td>
<td>筛选指定字段类型的文档</td>
</tr>
</tbody></table>
<p><code>$exists</code>查询<code>author</code>字段存在的文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.article.find(</span><br><span class="line">    &#123;<span class="string">&quot;author&quot;</span>:&#123;<span class="variable">$exists</span>:<span class="literal">true</span>&#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>$type</code>查询<code>author</code>字段为数组的文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.article.find(</span><br><span class="line">    &#123;<span class="string">&quot;author&quot;</span>:&#123;<span class="variable">$type</span>:<span class="string">&quot;array&quot;</span>&#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>MongoDB 支持正则表达式匹配文档，通过正则表达我们可以实现关系型数据库的模糊查询，以及更加强大匹配规则，其使用语法有三种：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123; &lt; field &gt;: &#123; <span class="variable">$regex</span>: /pattern/, $ options ： <span class="string">&#x27;&lt;options&gt;&#x27;</span> &#125; &#125;</span><br><span class="line">&#123; &lt; field &gt;: &#123; <span class="variable">$regex</span>: <span class="string">&#x27;pattern&#x27;</span>, $ options ： <span class="string">&#x27;&lt;options&gt;&#x27;</span> &#125; &#125;</span><br><span class="line">&#123; &lt; field &gt;: &#123; <span class="variable">$regex</span>: /pattern/&lt;options&gt; &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>参数<code>/pattern/</code>和<code>&#39;pattern&#39;</code>都是表示正则表达式，直接添加字符串可用来模糊查询。<br>参数<code>$options</code>为可选参数，有四个固定值选择</p>
<table>
<thead>
<tr>
<th align="center">options 选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">i</td>
<td>匹配过程忽略大小写</td>
</tr>
<tr>
<td align="center">x</td>
<td>匹配过程忽略空格</td>
</tr>
<tr>
<td align="center">m</td>
<td>匹配多行数据，但都是从每行的起点和结尾匹配</td>
</tr>
<tr>
<td align="center">s</td>
<td>将多行转换成一行后进行匹配，可匹配换行符<code>\n</code>字符串</td>
</tr>
</tbody></table>
<p>模糊查询<code>author</code>为<code>Tao</code>的示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.article.find(</span><br><span class="line">    &#123;<span class="string">&quot;author&quot;</span>:&#123;<span class="variable">$regex</span>:/Tao/, <span class="variable">$options</span>:<span class="string">&#x27;i&#x27;</span>&#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>查询结果</p>
<p><img src="https://images.ytao.top/mongodb-query-regex.png"></p>
<p>从上面查询结果中可以看到，数据格式也可以进行匹配到。</p>
<h1 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h1><p>聚合操作可以实现分组、排序、分页、多集合关联查询等，使用语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection.aggregate([</span><br><span class="line">    &#123;聚合操作一&#125;,</span><br><span class="line">    &#123;聚合操作二&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h2 id="条件筛选"><a href="#条件筛选" class="headerlink" title="条件筛选"></a>条件筛选</h2><p><strong>$match</strong> 用来进行条件筛选，可以使用一些条件限制来进行查询。</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.article.aggregate([</span><br><span class="line">    &#123; <span class="variable">$match</span>: &lt;条件&gt; &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>查询<code>author = ytao</code>且<code>visitor &gt; 100</code>的文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.article.aggregate([</span><br><span class="line">    &#123; <span class="variable">$match</span>: &#123;</span><br><span class="line">        <span class="variable">$and</span>: [</span><br><span class="line">            &#123;<span class="string">&quot;author&quot;</span>: &#123;<span class="variable">$eq</span>: <span class="string">&quot;ytao&quot;</span>&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;visitor&quot;</span>: &#123;<span class="variable">$gt</span>: 100&#125;&#125;</span><br><span class="line">        ]&#125; </span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<h2 id="分组操作"><a href="#分组操作" class="headerlink" title="分组操作"></a>分组操作</h2><p><strong>$group</strong> 是分组操作符，类似于关系型数据库中的<code>group by</code>操作。其语法格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$group</span>:&#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;$&lt;分组字段名&gt;&quot;</span>, </span><br><span class="line">            &lt;显示结果的字段名称&gt;:&#123;&lt;运算符&gt;:<span class="string">&quot;$&lt;运算符计算的字段名&gt;&quot;</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>其中运算符如下：</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$avg</td>
<td>当前组的平均数</td>
</tr>
<tr>
<td align="center">$sum</td>
<td>当前组的总和</td>
</tr>
<tr>
<td align="center">$min</td>
<td>当前组的最小值</td>
</tr>
<tr>
<td align="center">$max</td>
<td>当前组的最大值</td>
</tr>
<tr>
<td align="center">$first</td>
<td>当前组的第一个的值</td>
</tr>
<tr>
<td align="center">$last</td>
<td>当前组的最后一个的值</td>
</tr>
<tr>
<td align="center">$push</td>
<td>数组形式展示指定的当前组字段值</td>
</tr>
<tr>
<td align="center">$addToSet</td>
<td>数组形式展示指定的当前组字段不重复值</td>
</tr>
</tbody></table>
<p>分组求出每个<code>author</code>的<code>visitor</code>平均数的例子</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.article.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$group</span>:&#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;<span class="variable">$author</span>&quot;</span>, </span><br><span class="line">            <span class="string">&quot;avg_visitor&quot;</span>:&#123;<span class="variable">$sum</span>:<span class="string">&quot;<span class="variable">$visitor</span>&quot;</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>


<h2 id="字段显示"><a href="#字段显示" class="headerlink" title="字段显示"></a>字段显示</h2><p>指定查询后返回的字段使用**$project**，字段指定默认值为<code>0</code>，但是<code>_id</code>默认为<code>1</code>，显示指定字段语法为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$project</span>:&#123;</span><br><span class="line">            <span class="string">&quot;&lt;字段名&gt;&quot;</span>: &lt;0或1&gt;, </span><br><span class="line">            <span class="string">&quot;&lt;字段名&gt;&quot;</span>:&lt;0或1&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>展示<code>title</code>和<code>visitor</code>字段示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.article.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$project</span>:&#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span>: 0, </span><br><span class="line">            <span class="string">&quot;title&quot;</span>: 1,</span><br><span class="line">            <span class="string">&quot;visitor&quot;</span>: 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>同时，<code>$project</code>还以搭配<code>$split</code>(字符串拆分)、<code>$substr</code>(截取字符串)、<code>$concat</code>(合并字符串)、<code>$switch</code>(条件判断)、<code>$toLower</code>(转换成小写)、<code>$toUpper</code>(转换成大写)、时间格式处理等等操作符进行操作，语法为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$project</span>:&#123;</span><br><span class="line">            <span class="string">&quot;&lt;字段名&gt;&quot;</span>: &#123;&lt;操作符&gt;: &lt;条件&gt;&#125;, </span><br><span class="line">            <span class="string">&quot;&lt;字段名&gt;&quot;</span>: &#123;&lt;操作符&gt;: &lt;条件&gt;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>例如将<code>title</code>中的字母都转换成大写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.article.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$project</span>:&#123;</span><br><span class="line">            <span class="string">&quot;titleField&quot;</span>:&#123; <span class="variable">$toUpper</span>:<span class="string">&quot;<span class="variable">$title</span>&quot;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>返回结果</p>
<p><img src="https://images.ytao.top/mongodb-query-project.png"></p>
<h2 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h2><p><strong>$sort</strong>是文档排序操作符，类似关系型数据中的<code>order by</code>指令。<code>$sort</code>排序用<code>1</code>和<code>-1</code>表示正序和倒序。</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$sort</span>:&#123;</span><br><span class="line">            <span class="string">&quot;&lt;排序字段名&gt;&quot;</span>: &lt;1 或 -1&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>按<code>visitor</code>字段名进行倒序排序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.article.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$sort</span>:&#123;</span><br><span class="line">            <span class="string">&quot;visitor&quot;</span>: -1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>排序结果</p>
<p><img src="https://images.ytao.top/mongodb-query-sort.png"></p>
<h2 id="分页操作"><a href="#分页操作" class="headerlink" title="分页操作"></a>分页操作</h2><p>分页使用 <strong>$skip</strong> 和 <strong>$limit</strong> 进行分页操作。<code>$skip</code>表示跳过文档的数量，<code>$limit</code>表示返回的文档数量，这两个指令使用，类似于关系型数据中的<code>limit &lt;start&gt;, &lt;size&gt;</code>分页操作。</p>
<p>语法格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection.aggregate([</span><br><span class="line">    &#123;<span class="variable">$skip</span>: &lt;跳过的文档数量&gt;&#125;,</span><br><span class="line">    &#123;<span class="variable">$limit</span>: &lt;返回的文档数量&gt;&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>查询第二页的两条数据示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.article.aggregate([</span><br><span class="line">    &#123;<span class="variable">$skip</span>: 2&#125;,</span><br><span class="line">    &#123;<span class="variable">$limit</span>: 2&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>返回结果</p>
<p><img src="https://images.ytao.top/mongodb-query-page.png"></p>
<h2 id="统计文档数量"><a href="#统计文档数量" class="headerlink" title="统计文档数量"></a>统计文档数量</h2><p><strong>$count</strong>用来统计文档数量，进行条件筛选时。</p>
<p>语法格式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection.aggregate([</span><br><span class="line">    &#123; <span class="variable">$count</span>: <span class="string">&quot;&lt;显示数量的字段的名称&gt;&quot;</span> &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>统计全部文档数量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.article.aggregate([</span><br><span class="line">    &#123; <span class="variable">$count</span>: <span class="string">&quot;数量&quot;</span> &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>统计结果：</p>
<p><img src="https://images.ytao.top/mongodb-query-count.png"></p>
<h2 id="多集合关联查询"><a href="#多集合关联查询" class="headerlink" title="多集合关联查询"></a>多集合关联查询</h2><p><strong>$lookup</strong> 是用来多集合关联查询时使用的，类似于关系型数据库中的联表查询。</p>
<p>使用语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.collection.aggregate([</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="variable">$lookup</span>: &#123;</span><br><span class="line">            from: &lt;关联的表名&gt;,</span><br><span class="line">            localField: &lt;当前表的关联字段&gt;,</span><br><span class="line">            foreignField: &lt;关联表的关联字段&gt;,</span><br><span class="line">            as: &lt;另一集合嵌入的字段名&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>在进行多集合关联查询演示前，先添加一个集合<code>person</code>，里面添加一条数据：</p>
<p><img src="https://images.ytao.top/mongodb-query-person-collection.png"></p>
<p>查询<code>age = 18</code>的集合：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.article.aggregate([</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="variable">$lookup</span>: &#123;</span><br><span class="line">            from: <span class="string">&quot;person&quot;</span>,</span><br><span class="line">            localField: <span class="string">&quot;author&quot;</span>,</span><br><span class="line">            foreignField: <span class="string">&quot;author&quot;</span>,</span><br><span class="line">            as: <span class="string">&quot;person_info&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="variable">$match</span>:&#123;</span><br><span class="line">           <span class="string">&quot;person_info.age&quot;</span>: &#123;<span class="variable">$eq</span>: 18&#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>返回结果：</p>
<p><img src="https://images.ytao.top/mongodb-query-lookup.png"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对 MongoDB 的常用查询操作进行了解后，可以发现它和关系型数据操作有很多类似的操作思想。对于这些操作的使用，相对也是较为灵活，提供的 API 也是较为强大，几乎能满足大部分使用场景的检索要求。掌握这些查询操作，可以更高效的获取 MongoDB 中的文档。</p>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS 原理剖析</title>
    <url>/2020/08/25/29-AQS/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/20200627230025.jpg"></p>
<p><code>AQS</code>即<code>AbstractQueuedSynchronizer</code>类称作队列同步器，是构建其他同步器的一个重要的基础框架，同步器自身是没有实现任何同步接口。它是通过控制一个<code>int</code>类型的<code>state</code>变量来表示同步状态，使用一个内置的<code>FIFO</code>（先进先出）队列来构建工作队列操作。</p>
<p>同步器定义有两种资源共享方式：<code>Exclusive</code>（独占式）和<code>Share</code>（共享式）的获取同步状态。</p>
<p>独占式：一个时间点只能执行一个线程。<br>共享式：一个时间点可多个线程同时执行。</p>
<span id="more"></span>

<h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>同步器的设计采用模板模式，要实现一个同步组件得先继承<code>AbstractQueuedSynchronizer</code>类，通过调用同步器提供的方法和重写同步器的方法来实现。</p>
<p>调用同步器中的方法就是调用前面提到的通过<code>state</code>变量值的操作来表示同步操作，<code>state</code>是被<code>volatile</code>修饰来保证线程可见性。</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">getState()</td>
<td align="center">获取当前线程同步状态值。</td>
</tr>
<tr>
<td align="center">setState(int newState)</td>
<td align="center">设置当前同步状态值。</td>
</tr>
<tr>
<td align="center">compareAndSetState(int expect, int update)</td>
<td align="center">通过<code>CAS</code>设置<code>state</code>的值。</td>
</tr>
</tbody></table>
<p>为了避免被重写，以上方法都被<code>final</code>修饰了。</p>
<p>实现同步组件，需要自己根据自己定制化的需求进行处理，所以需要自己重写同步器提供的方法，要重写的方法主要是独占式获取与释放同步状态、共享式获取与释放同步状态。</p>
<p><strong>tryAcquire(int arg)</strong> 独占式获取同步状态，返回值为<code>boolean</code>类型，获取成返回<code>true</code>，获取失败返回<code>false</code>。</p>
<p><strong>tryRelease(int arg)</strong> 独占式释放同步状态，返回值为<code>boolean</code>类型，释放成返回<code>true</code>，释放失败返回<code>false</code>。</p>
<p><strong>tryAcquireShared(int arg)</strong> 共享式获取同步状态，返回值为<code>int</code>类型，获取成功返回大于 0 的值。</p>
<p><strong>tryReleaseShared(int arg)</strong> 共享式释放同步状态，返回值为<code>boolean</code>类型，释放成返回<code>true</code>，释放失败返回<code>false</code>。</p>
<p><strong>isHeldExclusively()</strong> 独占模式下是否被当前前程独占，返回值为<code>boolean</code>类型，已被当前线程所独占返回<code>true</code>，反之为<code>false</code>。</p>
<h1 id="同步器队列"><a href="#同步器队列" class="headerlink" title="同步器队列"></a>同步器队列</h1><p>一个同步器里面拥有<strong>一个同步队列</strong>和<strong>多个等待队列</strong>。</p>
<h2 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2><p>在<code>AbstractQueuedSynchronizer</code>类中，有一个内部类<code>Node</code>，通过该类构造一个内部的同步队列，这是一个<strong>FIFO 双向队列</strong>。<br>当前运行线程回去同步状态时，如果获取失败，则将当前线程信息创建一个<code>Node</code>追加到同步队列尾部，然后阻塞当前线程，直到队列的上一个节点的同步状态释放，再唤醒当前线程尝试重新获取同步状态。这个重新获取同步状态操作的节点，一定要是同步队列中第一节点。</p>
<p>Node 源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 共享模式下等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="comment">// 独占模式下等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 等待状态常量值，以下四个常量都是</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待状态</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点的前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点的后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取同步状态的线程（引用）</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待队列中的后继节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否共享模式</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取前驱节点</span></span><br><span class="line">    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上代码，可以看到节点中保存了节点模式、等待状态、线程引用、前驱和后继节点，构造节点。</p>
<p>同步队列中被阻塞的线程的等待状态包含有四个常量值：CANCELLED、SIGNAL、CONDITION、PROPAGATE ，它们对应的被阻塞原因如下：</p>
<ul>
<li><code>CANCELLED</code> 同步队列中当前节点的线程等待超时或被中断，需要从同步队列中取消等待。</li>
<li><code>SIGNAL</code> 当前节点释放同步状态或被取消后，通知后继节点的线程运行。</li>
<li><code>CONDITION</code> 当前节点在 Condition 上等待，当其他线程对 Condition 调用了 signal() 方法后，该节点将添加到同步队列中。</li>
<li><code>PROPAGATE</code> 该状态存在共享模式的首节点中，当前节点唤醒后将传播唤醒其他节点。</li>
</ul>
<p>同步器中持有同步队列的首节点和尾节点的引用，在<code>AbstractQueuedSynchronizer</code>中分别对应<code>head</code>和<code>tail</code>字段。</p>
<p><img src="https://images.ytao.top/aqs-aqs-fields.png"></p>
<p>所以同步队列的基本结构如图：</p>
<p><img src="https://images.ytao.top/aqs-fifo-struct.png"></p>
<h2 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h2><p><code>AbstractQueuedSynchronizer</code>类中包含一个内部类<code>ConditionObject</code>，该类实现了<code>Condition</code>的接口。一个<code>Condition</code>对象包含一个等待队列，同时<code>Condition</code>对象可以实现等待&#x2F;通知功能。</p>
<p><code>Condition</code>持有等待队列中的首节点（firstWaiter）和尾节点（lastWaiter），如下图代码所示：</p>
<p><img src="https://images.ytao.top/aqs-ConditionObject-code.png"></p>
<p>如果当前线程调用<code>Condition.await()</code>时，会将当前线程信息构建一个 Node 节点，因为<code>Condition</code>持有等待队列中的首尾节点，所以将当前等待队列中的尾节点的<code>nextWaiter</code>指向当前线程构建的节点，同时更新<code>lastWaiter</code>的引用节点。</p>
<p>上述过程中的节点、队列的操作，是获取到锁的线程来调用<code>Condition.await()</code>的，所以整个执行过程在没有基于 CAS 的情况下，也是线程安全的。</p>
<p>通过以上的描述，可以知道一个同步器中同步队列、等待队列构成的示意图：</p>
<p><img src="https://images.ytao.top/aqs-syncQueue-waitQueue.png"></p>
<p>当调用<code>Condition.await()</code>时，同步队列中的首节点，也就是当前线程所创建的节点，会加入到等待队列中的尾部，释放当前线程的同步状态并且唤醒同步队列的后继节点，当前线程也就进入等待状态，这个先后顺序不能颠倒。<strong>这个过程相当于同步队列的首节点的线程构造新的节点加入到等待队列的尾部。</strong></p>
<p><img src="https://images.ytao.top/aqs-syncQueue-waitQueue-wait.png"></p>
<p>当调用<code>Condition.signal()</code>方法时，会先将等待队列中首节点转移到同步队列尾部，然后唤醒该同步队列中的线程，该线程从<code>Condition.await()</code>中自旋退出，接着在在同步器的<code>acquireQueued()</code>中自旋获取同步状态。</p>
<p><img src="https://images.ytao.top/aqs-syncQueue-waitQueue-signal.png"></p>
<p>当调用<code>Condition.wait()</code>方法，同步队列首节点转移到等待队列方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 如果线程已中断，则抛出中断异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 添加节点到等待队列中</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="comment">// 修改 state 来达到释放同步状态，避免死锁</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断当前节点是否在同步队列中</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 继续获取同步状态竞争</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// 清除已取消的节点</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>) <span class="comment">// 被中断时的处理</span></span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面<code>addc</code>方法是向等待队列中添加一个新的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取等待队列中尾节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">    <span class="comment">// 如果最后一个节点已取消，则清除取消节点</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用当前线程信息创建等待队列的节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>) <span class="comment">// 如果最后尾节点为空，当前节点则为等待队列的首节点</span></span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 否则将当前尾节点的下一个节点指向当前线程信息所构造的节点</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;  <span class="comment">// 更新 Condition 的尾节点引用</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用<code>Condition.signal()</code>方法，等待队列首节点转移到同步队列方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 是否被当前线程所独占</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="comment">// 获取等待队列中首节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 转移到同步队列，然后唤醒该节点</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转移同步队列首节点到同步队列，并唤醒该节点方法<code>doSignal()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">          lastWaiter = <span class="literal">null</span>;</span><br><span class="line">          <span class="comment">// 去除首节点</span></span><br><span class="line">          first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp; <span class="comment">// 从等待队列中转移到同步队列</span></span><br><span class="line">              (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转移等待队列到同步队列方法<code>transferForSignal(Node node)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 验证节点是否被取消</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 转移节点至同步队列</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等待队列中的头结点线程安全移动到同步队列方法<code>enq(final Node node)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">// 同步队列中如果为空，则初始化同步器</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则新节点的前驱节点为当前同步队列的尾节点</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// 设置当前新节点为同步队列的尾节点，并更新先前同步队列的尾节点的后继节点指向当前新节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="独占式同步状态"><a href="#独占式同步状态" class="headerlink" title="独占式同步状态"></a>独占式同步状态</h1><p>独占式同步状态获取和释放是线程安全的操作，一个时间点确保只有一个线程获取到同步状态。</p>
<h2 id="独占式同步状态获取"><a href="#独占式同步状态获取" class="headerlink" title="独占式同步状态获取"></a>独占式同步状态获取</h2><p><code>acquire(int arg)</code>方法是获取独占式同步状态的方法，当线程获取同步失败时，会加入到同步队列中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码中，当执行<code>tryAcquire(int arg)</code>方法获取同步状态失败时，接着通过<code>addWaiter(Node.EXCLUSIVE)</code>构造当前线程信息的节点，随后将新构造的节点通过<code>acquireQueued(final Node node, int arg)</code>方法加入到同步队列中，节点在同步队列中自旋等待获取同步状态。</p>
<p><code>tryAcquire(int arg)</code>是自定义同步器实现的，实现该方法需要保证线程安全获取同步状态，前面讲到<code>AQS</code>提供的<code>compareAndSetState(int expect, int update)</code>方法通过<code>CAS</code>设置<code>state</code>值来保证线程安全。</p>
<p>上面获取独占式同步状态时，主要分析<code>acquireQueued(final Node node, int arg)</code>方法，节点加入队列并自旋等待。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 是否中断标识</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// 如果前驱节点是首节点，并且当前节点获取到同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 将当前节点设置为首节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// 将原首节点（即当前节点的前驱节点）引用清空，利于 GC 回收</span></span><br><span class="line">                p.next = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 成功获取到同步状态标志</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断前驱节点是否超时或取消，以及当前线程是否被中断</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果被中断，则节点出队</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在首节点释放同步状态后，同时唤醒后继节点。后继节点通过自旋的方式（这里利用死循环方式）也会检查自己的前驱节点是否为首节点，如果是前驱节点则会尝试获取同步状态。获取成功则返回，否则判断是否被中断或者继续自旋上述获取同步状态操作。</p>
<h2 id="独占式同步状态释放"><a href="#独占式同步状态释放" class="headerlink" title="独占式同步状态释放"></a>独占式同步状态释放</h2><p><code>release(int arg)</code>方法是释放同步状态，当释放同步状态后会唤醒后继节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tryRelease(int arg)</code>方法同样也是自定义同步器实现。当首节点不为空且处于等待状态时，那么调用<code>unparkSuccessor(Node node)</code>方法唤醒后继节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// CAS 设置等待状态为初始状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="comment">// 如果当前释放同步状态的节点不存在后继节点或后继节点超时/被中断</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 从尾节点中开始寻找等待状态的节点作为新首节点，这里已排除当前节点（t != node）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放同步状态的整个过程就是：释放同步状态，唤醒后继节点。这个后继节点必须满足，非空、非当前节点、等待状态小于或等于 0 ，即<code>SIGNAL</code>、<code>CONDITION</code>、<code>PROPAGATE</code>和初始化状态。</p>
<p>独占式资源共享方式除了上面的同步状态获取，还有<strong>独占式超时获取</strong>使用的方法是<code>doAcquireNanos(int arg, long nanosTimeout)</code>、<strong>独占式可中断获取</strong>使用的方法是<code>acquireInterruptibly(int arg)</code>。</p>
<h1 id="共享式同步状态"><a href="#共享式同步状态" class="headerlink" title="共享式同步状态"></a>共享式同步状态</h1><p>共享式同步状态同一时间点可以有多个线程获取到同步状态。</p>
<h2 id="共享式同步状态获取"><a href="#共享式同步状态获取" class="headerlink" title="共享式同步状态获取"></a>共享式同步状态获取</h2><p><code>acquireShared(int arg)</code>方法是共享式同步状态获取的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 获取同步状态失败后调用的方法</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>tryAcquireShared(int arg)</code>方法是自定义同步器实现的，返回大于或等于 0 时，表示获取成功。如果小于 0 时，获取同步状态失败后会调用<code>doAcquireShared(int arg)</code>方法进行再次尝试获取。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;、</span><br><span class="line">    <span class="comment">// 构造一个当前线程信息的新节点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 自旋式获取同步状态</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// 判断新节点的前驱节点是否为首节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 再次尝试获取同步状态</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 获取成功后退出自旋</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，当获取同步状态失败后，则创建一个共享模式类型的节点，然后自旋式获取同步状态，如果前驱节点为首节点时则尝试再次获取同步状态，获取同步状态成功后退出当前自旋。</p>
<h2 id="共享式释放同步状态"><a href="#共享式释放同步状态" class="headerlink" title="共享式释放同步状态"></a>共享式释放同步状态</h2><p><code>releaseShared(int arg)</code>方法来释放共享式同步状态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 同步状态释放成功后，唤醒后面等待状态的节点</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面<code>tryReleaseShared(int arg)</code>释放同步状态方法必须保证线程安全，因为它多个线程获取到同步状态时会引发并发操作，可以通过循环操作和 CAS 来确保安前行。</p>
<p><code>doReleaseShared()</code>方法唤醒后续等待状态的节点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="comment">// 验证后继节点的线程处于等待状态</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 再次检查后继节点的线程是否处于等待状态</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;   </span><br><span class="line">                <span class="comment">// 唤醒后继节点，这时每唤醒一次就更新一次首节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                      !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>共享同步状态释放后，自旋式依次唤醒队列中节点。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>从 AQS 中可以借鉴它利用循环和 CAS 来确保并发的安全性的思路，同时它采用模板设计模式定义一个处理逻辑，将具体的特定处理逻辑交由子类自定义实现。在 ReentrantLock、ReentrantReadWriteLock、Semaphore、CountDownLatch 以及 Tomncat 的 LimitLatch 都有用其作为同步器。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>AQS</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java诊断利器Arthas优雅排查生产环境</title>
    <url>/2019/10/18/3_Java%E8%AF%8A%E6%96%AD%E5%88%A9%E5%99%A8Arthas%E4%BC%98%E9%9B%85%E6%8E%92%E6%9F%A5%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/arthas.png" alt="arthas"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p><code>Arthas</code> 是Alibaba开源的Java诊断工具。在线排查问题，无需重启；动态跟踪Java代码；实时监控JVM状态。对分秒必争的线上异常，<code>Arthas</code>可帮助我们快速诊断相关问题。</p>
</blockquote>
<span id="more"></span>

<h1 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h1><p>下载<code>Arthas</code>的<code>arthas-boot.jar</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://alibaba.github.io/arthas/arthas-boot.jar</span><br></pre></td></tr></table></figure>

<p>下载<code>arthas</code>之后，先来了解帮助信息，可以通过<code>java -jar arthas-boot.jar -h</code>命令查看，这里给出了一些例子和参数说明</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@izwz94a0v1sz0gk4rezdcbz arthas]<span class="comment"># java -jar arthas-boot.jar -h</span></span><br><span class="line">[INFO] arthas-boot version: 3.1.4</span><br><span class="line">Usage: arthas-boot [-h] [--target-ip &lt;value&gt;] [--telnet-port &lt;value&gt;]</span><br><span class="line">       [--http-port &lt;value&gt;] [--session-timeout &lt;value&gt;] [--arthas-home &lt;value&gt;]</span><br><span class="line">       [--use-version &lt;value&gt;] [--repo-mirror &lt;value&gt;] [--versions] [--use-http]</span><br><span class="line">       [--attach-only] [-c &lt;value&gt;] [-f &lt;value&gt;] [--height &lt;value&gt;] [--width</span><br><span class="line">       &lt;value&gt;] [-v] [--tunnel-server &lt;value&gt;] [--agent-id &lt;value&gt;] [--stat-url</span><br><span class="line">       &lt;value&gt;] [pid]</span><br><span class="line"></span><br><span class="line">Bootstrap Arthas</span><br><span class="line"></span><br><span class="line">EXAMPLES:</span><br><span class="line">  java -jar arthas-boot.jar &lt;pid&gt;</span><br><span class="line">  java -jar arthas-boot.jar --target-ip 0.0.0.0</span><br><span class="line">  java -jar arthas-boot.jar --telnet-port 9999 --http-port -1</span><br><span class="line">  java -jar arthas-boot.jar --tunnel-server <span class="string">&#x27;ws://192.168.10.11:7777/ws&#x27;</span></span><br><span class="line">  java -jar arthas-boot.jar --tunnel-server <span class="string">&#x27;ws://192.168.10.11:7777/ws&#x27;</span></span><br><span class="line">--agent-id bvDOe8XbTM2pQWjF4cfw</span><br><span class="line">  java -jar arthas-boot.jar --stat-url <span class="string">&#x27;http://192.168.10.11:8080/api/stat&#x27;</span></span><br><span class="line">  java -jar arthas-boot.jar -c <span class="string">&#x27;sysprop; thread&#x27;</span> &lt;pid&gt;</span><br><span class="line">  java -jar arthas-boot.jar -f batch.as &lt;pid&gt;</span><br><span class="line">  java -jar arthas-boot.jar --use-version 3.1.4</span><br><span class="line">  java -jar arthas-boot.jar --versions</span><br><span class="line">  java -jar arthas-boot.jar --session-timeout 3600</span><br><span class="line">  java -jar arthas-boot.jar --attach-only</span><br><span class="line">  java -jar arthas-boot.jar --repo-mirror aliyun --use-http</span><br><span class="line">WIKI:</span><br><span class="line">  https://alibaba.github.io/arthas</span><br><span class="line"></span><br><span class="line">Options and Arguments:</span><br><span class="line"> -h,--<span class="built_in">help</span>                      Print usage</span><br><span class="line">    --target-ip &lt;value&gt;         The target jvm listen ip, default 127.0.0.1</span><br><span class="line">    --telnet-port &lt;value&gt;       The target jvm listen telnet port, default 3658</span><br><span class="line">    --http-port &lt;value&gt;         The target jvm listen http port, default 8563</span><br><span class="line">    --session-timeout &lt;value&gt;   The session <span class="built_in">timeout</span> seconds, default 1800</span><br><span class="line">                                (30min)</span><br><span class="line">    --arthas-home &lt;value&gt;       The arthas home</span><br><span class="line">    --use-version &lt;value&gt;       Use special version arthas</span><br><span class="line">    --repo-mirror &lt;value&gt;       Use special maven repository mirror, value is</span><br><span class="line">                                center/aliyun or http repo url.</span><br><span class="line">    --versions                  List <span class="built_in">local</span> and remote arthas versions</span><br><span class="line">    --use-http                  Enforce use http to download, default use https</span><br><span class="line">    --attach-only               Attach target process only, <span class="keyword">do</span> not connect</span><br><span class="line"> -c,--<span class="built_in">command</span> &lt;value&gt;           Command to execute, multiple commands separated</span><br><span class="line">                                by ;</span><br><span class="line"> -f,--batch-file &lt;value&gt;        The batch file to execute</span><br><span class="line">    --height &lt;value&gt;            arthas-client terminal height</span><br><span class="line">    --width &lt;value&gt;             arthas-client terminal width</span><br><span class="line"> -v,--verbose                   Verbose, <span class="built_in">print</span> debug info.</span><br><span class="line">    --tunnel-server &lt;value&gt;     The tunnel server url</span><br><span class="line">    --agent-id &lt;value&gt;          The agent <span class="built_in">id</span> register to tunnel server</span><br><span class="line">    --stat-url &lt;value&gt;          The report <span class="built_in">stat</span> url</span><br><span class="line"> &lt;pid&gt;                          Target pid</span><br></pre></td></tr></table></figure>

<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>启动<code>arthas</code>之前，先启动一个<code>springboot</code>的应用。该<code>demo</code>在地址<a href="https://github.com/yangtao9502/ytao-springboot-demo">https://github.com/yangtao...</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar ytao-springboot-demo.jar</span><br></pre></td></tr></table></figure>
<p>启动<code>arthas-boot.jar</code>命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure>
<p>这里注意需要启动<code>demo</code>和<code>arthas</code>使用同一权限用户，否则使用attach机制获取不到进程信息（这里刚使用时没注意，遇到过这个问题）。<br>例：<code>root</code>用户启动 <code>demo</code>，<code>u1</code>用户启动<code>arthas</code>时，打印信息<code> Can not find java process. Try to pass &lt;pid&gt; in command line.</code><br><img src="https://images.ytao.top/%E4%BD%BF%E7%94%A8%E5%8F%A6%E4%B8%80user%E5%90%AF%E5%8A%A8.png" alt="使用另一user启动"><br>查看源码，在获取进程之后，添加日志输出。结果为空，返回<code>-1</code>，判断结果小于<code>0</code>时，直接退出。<br><img src="https://images.ytao.top/%E6%89%93%E5%8D%B0%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%97%A5%E5%BF%97.jpg" alt="日志输出"><br>启动类<code>Bootstrap#main</code>的代码<br><img src="https://images.ytao.top/%E6%B2%A1%E6%9C%89%E8%BF%9B%E7%A8%8B%E9%80%80%E5%87%BA.png" alt="Bootstrap#main"><br>进程工具类<code>ProcessUtils#select</code>的代码<br><img src="https://images.ytao.top/ProcessUtils%E7%9A%84select.png" alt="ProcessUtils#select"><br>通过上面也分析到，我们启动<code>arthas</code>之前，必须要先启动我们的目标进程，否则<code>arthas</code>可能无法启动。</p>
<p>使用<code>root</code>用户启动成功界面<br><img src="https://images.ytao.top/arthas%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.png" alt="arthas启动成功"><br>选择java进程，这里我们的<code>ytao-springboot-demo</code>是 1,选择后会有连接信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[INFO] arthas home: /root/.arthas/lib/3.1.4/arthas</span><br><span class="line">[INFO] Try to attach process 22005</span><br><span class="line">[INFO] Attach process 22005 success.</span><br><span class="line">[INFO] arthas-client connect 127.0.0.1 3658</span><br><span class="line">  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.                           </span><br><span class="line"> /  O  \ |  .--. <span class="string">&#x27;&#x27;</span>--.  .--<span class="string">&#x27;|  &#x27;</span>--<span class="string">&#x27;  | /  O  \ &#x27;</span>   .-<span class="string">&#x27;                          </span></span><br><span class="line"><span class="string">|  .-.  ||  &#x27;</span>--<span class="string">&#x27;.&#x27;</span>   |  |   |  .--.  ||  .-.  |`.  `-.                          </span><br><span class="line">|  | |  ||  |\  \    |  |   |  |  |  ||  | |  |.-<span class="string">&#x27;    |                         </span></span><br><span class="line"><span class="string">`--&#x27;</span> `--<span class="string">&#x27;`--&#x27;</span> <span class="string">&#x27;--&#x27;</span>   `--<span class="string">&#x27;   `--&#x27;</span>  `--<span class="string">&#x27;`--&#x27;</span> `--<span class="string">&#x27;`-----&#x27;</span>                          </span><br><span class="line">                                                                                </span><br><span class="line"></span><br><span class="line">wiki      https://alibaba.github.io/arthas                                      </span><br><span class="line">tutorials https://alibaba.github.io/arthas/arthas-tutorials                     </span><br><span class="line">version   3.1.4                                                                 </span><br><span class="line">pid       17339  </span><br><span class="line">time      2019-10-17 02:29:06</span><br></pre></td></tr></table></figure>

<h1 id="dashboard-数据面板"><a href="#dashboard-数据面板" class="headerlink" title="dashboard 数据面板"></a>dashboard 数据面板</h1><p>使用<code>dashboard</code>命令，可以查看线程，内存，GC，以及Runtime信息<br><img src="https://images.ytao.top/arthas%E7%9A%84%E6%95%B0%E6%8D%AE%E9%9D%A2%E6%9D%BF.png" alt="dashboard"></p>
<h1 id="jad-反编译"><a href="#jad-反编译" class="headerlink" title="jad 反编译"></a>jad 反编译</h1><p>有时我们会遇到线上代码运行结果不是我们期望的结果，有种情况就是线上代码不是我们想要的版本，但是要查看的话，需要下载后再进行反编译。<br>这时<code>arthas</code>的<code>jad</code>可以帮助我们线上进行即时反编译，确认代码是否符合我们的版本。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jad com.ytao.service.UserServiceImpl</span><br></pre></td></tr></table></figure>
<p><img src="https://images.ytao.top/jad%E5%8F%8D%E7%BC%96%E8%AF%91.png" alt="jad反编译"></p>
<h1 id="watch-函数执行信息"><a href="#watch-函数执行信息" class="headerlink" title="watch 函数执行信息"></a>watch 函数执行信息</h1><p>使用<code>watch</code>命令可以查看函数的执行信息。<code>watch</code>的参数列表（来自官网）</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">class-pattern</td>
<td align="left">类名表达式匹配</td>
</tr>
<tr>
<td align="left">method-pattern</td>
<td align="left">方法名表达式匹配</td>
</tr>
<tr>
<td align="left">express</td>
<td align="left">观察表达式</td>
</tr>
<tr>
<td align="left">condition-express</td>
<td align="left">条件表达式</td>
</tr>
<tr>
<td align="left">[b]</td>
<td align="left">在方法调用之前观察</td>
</tr>
<tr>
<td align="left">[e]</td>
<td align="left">在方法异常之后观察</td>
</tr>
<tr>
<td align="left">[s]</td>
<td align="left">在方法返回之后观察</td>
</tr>
<tr>
<td align="left">[f]</td>
<td align="left">在方法结束之后(正常返回和异常返回)观察</td>
</tr>
<tr>
<td align="left">[E]</td>
<td align="left">开启正则表达式匹配，默认为通配符匹配</td>
</tr>
<tr>
<td align="left">[x:]</td>
<td align="left">指定输出结果的属性遍历深度，默认为 1</td>
</tr>
</tbody></table>
<p>当我们遇到线上数据<code>bug</code>时，我们一般处理的手段就是开发环境模拟线上数据，从生产日志中查找线索，再或者远程<code>debug</code>。以上不管哪种排查手段，相对都是比较麻烦。<br>这时Arthas的<code>watch</code>可以帮助我们查看实时的代码执行情况。使用观察表达式可以查看函数的<code>参数</code>,<code>返回值</code>,<code>异常信息</code>。观察表达式主要由<code>OGNL</code>表达式组成，所以可以编写<code>OGNL</code>表达式来执行。</p>
<p>观察表达式的变量</p>
<table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">变量说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">params</td>
<td align="left">函数的入参</td>
</tr>
<tr>
<td align="left">returnObj</td>
<td align="left">函数的返回值</td>
</tr>
<tr>
<td align="left">throwExp</td>
<td align="left">异常信息</td>
</tr>
<tr>
<td align="left">target</td>
<td align="left">当前对象</td>
</tr>
</tbody></table>
<p>查看一个函数的入参和返回值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">watch com.ytao.service.UserServiceImpl getUser <span class="string">&quot;&#123;params,returnObj&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://images.ytao.top/watch%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC.png" alt="watch命令的参数和返回值信息"></p>
<p>打印信息<code>isEmpty=false;size=1</code>可以看到参数为非空，参数数量为一个。查看具体入参信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">watch com.ytao.service.UserServiceImpl getUser <span class="string">&quot;&#123;params[0],returnObj&#125;&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://images.ytao.top/watch%E5%91%BD%E4%BB%A4%E7%9A%84%E5%85%B7%E4%BD%93%E7%9A%84%E5%85%A5%E5%8F%82.png" alt="watch命令的具体的入参信息"></p>
<p>查看异常信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">watch com.ytao.service.UserServiceImpl getUser <span class="string">&quot;throwExp&quot;</span></span><br></pre></td></tr></table></figure>
<p>当我们传入一个参数为<code>-1</code>时,打印出我们定义的非法参数异常<br><img src="https://images.ytao.top/watch%E6%9F%A5%E7%9C%8B%E5%BC%82%E5%B8%B8%E4%BF%A1%E6%81%AF.png" alt="watch查看异常信息"></p>
<p><code>watch</code>除了观察表达式外，还能使用<code>条件表达式</code>，以及<code>观察事件点</code>。<br><strong>注意</strong>使用观察事件点时，有些观察表达式的变量不一定存在，比如使用<code>-b</code>时，返回值和异常信息都为空。<br><img src="https://images.ytao.top/watch%E7%9A%84-b.png" alt="watch的-b参数"></p>
<p>有时我们排查某个函数，不能马上获取到函数的信息，<code>arthas</code>给提供的<code>后台异步任务</code>可以帮助我们记录日志。使用方式和Linux的类似。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">watch com.ytao.service.UserServiceImpl getUser <span class="string">&quot;&#123;params,returnObj&#125;&quot;</span> &gt; /log/w.log &amp;</span><br></pre></td></tr></table></figure>
<p>查看异步保存的日志<br><img src="https://images.ytao.top/watch%E5%BC%82%E6%AD%A5%E6%97%A5%E5%BF%97.png" alt="日志"></p>
<h1 id="tt-定位异常调用"><a href="#tt-定位异常调用" class="headerlink" title="tt 定位异常调用"></a>tt 定位异常调用</h1><p>上面所介绍的<code>watch</code>可以排查函数的调用情况，比较适用在已知当次调用可能存在的情况后，查看信息。如果一个函数调用n次后，有几次为执行异常，我们要去找出这些异常的调用，在<code>watch</code>中排查就不怎么方便了。<br>使用<code>tt</code>命令可以较方便查看异常的调用及信息。对<code>com.ytao.service.UserServiceImpl#getUser</code>的函数查看,<code>-t</code>是每次调用该函数都会记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tt -t com.ytao.service.UserServiceImpl getUser</span><br></pre></td></tr></table></figure>
<p>记录信息<br><img src="https://images.ytao.top/tt%E8%BE%93%E5%87%BA%E4%BF%A1%E6%81%AF.png" alt="tt信息输出"><br>查看所有记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tt -l</span><br></pre></td></tr></table></figure>
<p>查看指定函数记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tt -s <span class="string">&#x27;method.name==&quot;getUser&quot;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>输出信息说明</p>
<table>
<thead>
<tr>
<th align="left">表格字段</th>
<th align="left">字段解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">INDEX</td>
<td align="left">时间片段记录编号，每一个编号代表着一次调用，后续tt还有很多命令都是基于此编号指定记录操作，非常重要。</td>
</tr>
<tr>
<td align="left">TIMESTAMP</td>
<td align="left">方法执行的本机时间，记录了这个时间片段所发生的本机时间</td>
</tr>
<tr>
<td align="left">COST(ms)</td>
<td align="left">方法执行的耗时</td>
</tr>
<tr>
<td align="left">IS-RET</td>
<td align="left">方法是否以正常返回的形式结束</td>
</tr>
<tr>
<td align="left">IS-EXP</td>
<td align="left">方法是否以抛异常的形式结束</td>
</tr>
<tr>
<td align="left">OBJECT</td>
<td align="left">执行对象的hashCode()，注意，曾经有人误认为是对象在JVM中的内存地址，但很遗憾他不是。但他能帮助你简单的标记当前执行方法的类实体</td>
</tr>
<tr>
<td align="left">CLASS</td>
<td align="left">执行的类名</td>
</tr>
<tr>
<td align="left">METHOD</td>
<td align="left">执行的方法名</td>
</tr>
</tbody></table>
<p>从上面参数中我们看到<code>1003</code>调用是以抛异常的形式结束，因为<code>tt</code>会记录每次调用的信息，所以我们可以查看<code>1003</code>的详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tt -i 1003</span><br></pre></td></tr></table></figure>
<p><img src="https://images.ytao.top/tt%E8%B0%83%E7%94%A8%E8%AF%A6%E7%BB%86.png" alt="tt调用详细"></p>
<h1 id="trace-查看调用链路"><a href="#trace-查看调用链路" class="headerlink" title="trace 查看调用链路"></a>trace 查看调用链路</h1><p>我们常会遇到调用某个api时rt过长，我们就要找出调用链上的某个或几个函数进行优化，我们通常定位几个可能的锚点，打印各个锚点间的rt。或者从日志中找出日志打印的时间点计算出时间差，不管使用哪种方法都比较繁琐。当使用<code>arthas</code>的<code>trace</code>命令可以轻松的完成我们的需求。<br><code>trace</code>参数说明</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">参数说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">class-pattern</td>
<td align="left">类名表达式匹配</td>
</tr>
<tr>
<td align="left">method-pattern</td>
<td align="left">方法名表达式匹配</td>
</tr>
<tr>
<td align="left">condition-express</td>
<td align="left">条件表达式</td>
</tr>
<tr>
<td align="left">[E]</td>
<td align="left">开启正则表达式匹配，默认为通配符匹配</td>
</tr>
<tr>
<td align="left">[n:]</td>
<td align="left">命令执行次数</td>
</tr>
<tr>
<td align="left">#cost</td>
<td align="left">方法执行耗时</td>
</tr>
</tbody></table>
<p>使用<code>trace</code>输出<code>com.ytao.controller.UserController#getUser</code>的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">trace com.ytao.service.UserServiceImpl getUser</span><br></pre></td></tr></table></figure>
<p>输出结果<br><img src="https://images.ytao.top/trace%E8%BE%93%E5%87%BA%E4%BF%A1%E6%81%AF.png" alt="trace输出信息"></p>
<p>在实际使用使用排查过程中，为了减少无用信息的输出，我们一般会使用<code>#cost</code>过滤耗时不长和jdk自带的函数，可以忽略的调用，减少信息的输出。例如：过滤掉小于<code>1ms</code>的调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">trace com.ytao.service.UserServiceImpl getUser  <span class="string">&#x27;#cost &gt; 1&#x27;</span></span><br></pre></td></tr></table></figure>

<h1 id="redefine-实现热部署"><a href="#redefine-实现热部署" class="headerlink" title="redefine 实现热部署"></a>redefine 实现热部署</h1><p>当我们查找出bug，想要快速上线拯救苍生的时候，<code>Arthas</code>为我们准备了<code>redefine</code>命令来实现热更新。<br>尽管现在都在大赞<code>jad</code>&#x2F;<code>mc</code>&#x2F;<code>redefine</code>热更一条龙，但是线上代码建议本地编译好后再进行替换，避免手误操作。<br>首先先在<code>UserServiceImpl</code>中添加一行代码<br><img src="https://images.ytao.top/%E6%96%B0%E5%A2%9E%E4%BB%A3%E7%A0%81.png" alt="新增代码"></p>
<p>获取<code>classLoaderHash</code>，通过<code>sc</code>命令获取类的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sc -d *UserServiceImpl</span><br></pre></td></tr></table></figure>
<p><img src="https://images.ytao.top/classLoaderHash.png" alt="classLoaderHash"></p>
<p>执行<code>redefine</code>修改的类</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redefine -c 1d56ce6a /usr/local/jar/UserServiceImpl.class</span><br></pre></td></tr></table></figure>

<p>通过打印的信息验证是否更新<code>UserServiceImpl</code>类<br><img src="https://images.ytao.top/%E7%83%AD%E6%9B%B4%E9%AA%8C%E8%AF%81.png"></p>
<blockquote>
<p><code>Arthas</code>的使用，除了上文中所讲解到的，还有一些其他的诊断功能，这只是我个人使用的方法。但是使用该类工具一定要有套组合拳，对排查问题过程中，遇到问题有对应的排查手段，并非盲目排查。</p>
</blockquote>
]]></content>
      <categories>
        <category>Arthas</category>
      </categories>
      <tags>
        <tag>Arthas</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Docker实现MySQL主从复制</title>
    <url>/2019/10/27/4_%E5%9F%BA%E4%BA%8EDocker%E5%AE%9E%E7%8E%B0MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/mysql.jpg" alt="MySQL"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p><code>MySQL</code>的主从复制是实现应用的高性能，高可用的基础。对于数据库读操作较密集的应用，通过使数据库请求负载均衡分配到不同<code>MySQL</code>服务器，可有效减轻数据库压力。当遇到<code>MySQL</code>单点故障中，也能在短时间内实现故障切换。本文就<code>MySQL</code>的内建的复制功能进行阐述。</p>
</blockquote>
<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><ul>
<li><strong>MySQl</strong>: <code>5.7.17</code></li>
<li><strong>CentOS</strong>: <code>7.4.1708</code></li>
<li><strong>Docker</strong>: <code>1.13.1</code></li>
</ul>
<span id="more"></span>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><code>MySQL</code>复制数据流程：</p>
<ol>
<li>主库在数据更新提交事务之前，将事件异步记录到binlog二进制日志文件中，日志记录完成后存储引擎提交本次事务</li>
<li>从库启动一个I&#x2F;O线程与主库建立连接，用来请求主库中要更新的binlog。这时主库创建的binlog dump线程，这是二进制转储线程，如果有新更新的事件，就通知I&#x2F;O线程；当该线程转储二进制日志完成，没有新的日志时，该线程进入sleep状态。</li>
<li>从库的I&#x2F;O线程接收到新的事件日志后，保存到自己的relay log（中继日志）中</li>
<li>从库的SQL线程读取中继日志中的事件，并执行更新保存。<br><img src="https://images.ytao.top/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E6%B5%81%E7%A8%8B.png" alt="主从复制流程"></li>
</ol>
<h1 id="配置主从库"><a href="#配置主从库" class="headerlink" title="配置主从库"></a>配置主从库</h1><h2 id="主库my-cnf配置"><a href="#主库my-cnf配置" class="headerlink" title="主库my.cnf配置"></a>主库<code>my.cnf</code>配置</h2><p>在主库的<code>my.cnf</code>中打开二进制日志，并设置服务Id。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">log-bin = mysql-bin</span><br><span class="line">server-id = 1</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong><code>server-id</code>必须是一个唯一的数字，必须主从不一致, 且主从库必须设置项。</p>
<h2 id="从库my-cnf配置"><a href="#从库my-cnf配置" class="headerlink" title="从库my.cnf配置"></a>从库<code>my.cnf</code>配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">log-bin = mysql-bin</span><br><span class="line">server-id = 2</span><br><span class="line">log-slave-updates = 1</span><br><span class="line">read-only = 1</span><br></pre></td></tr></table></figure>
<p>从库也开启<code>log-bin</code>，<code>log-slave-updates</code>设置为从库重放中继日志时，记录到自己的二进制日志中，可以让从库作为其他服务器的主库，将二进制日志转发给其他从库，在做一主多从方案时可考虑该种方案。</p>
<h1 id="Dockerfile构建MySQL镜像"><a href="#Dockerfile构建MySQL镜像" class="headerlink" title="Dockerfile构建MySQL镜像"></a>Dockerfile构建MySQL镜像</h1><h2 id="构建所需文件"><a href="#构建所需文件" class="headerlink" title="构建所需文件"></a>构建所需文件</h2><p>这里<code>master</code>和<code>slave</code>文件各自保存不共用，先创建文件夹 <code>/usr/local/mysql</code> 然后在目录创建<code>master</code>和<code>slave</code>两个目录，再各自创建<code>data</code>文件夹<br><img src="https://images.ytao.top/%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95.png" alt="文件目录"></p>
<ul>
<li>data 目录用来保存数据文件的目录</li>
<li>Dockerfile 保存Dockerfile内容</li>
<li>init.sql 初始化数据库的SQL</li>
<li>my.cnf 数据库配置文件，配置方式上面已提到</li>
<li>start.sh Dockerfile构建MySQL时的脚本</li>
</ul>
<h3 id="Dockerfile-内容"><a href="#Dockerfile-内容" class="headerlink" title="Dockerfile 内容"></a>Dockerfile 内容</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 利用 mysql 镜像创建新的镜像</span></span><br><span class="line">FROM mysql:5.7.17</span><br><span class="line"></span><br><span class="line">ENV MYSQL_ROOT_PASSWORD ytao</span><br><span class="line"></span><br><span class="line">COPY start.sh /mysql/start.sh</span><br><span class="line">COPY my.cnf /etc/mysql/my.cnf  </span><br><span class="line">COPY init.sql /mysql/init.sql</span><br><span class="line"></span><br><span class="line">EXPOSE 3306</span><br><span class="line">CMD [<span class="string">&quot;sh&quot;</span>, <span class="string">&quot;/mysql/start.sh&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>这里的<code>master</code>和<code>slave</code>都是基于同一个镜像构建，使用的存储引擎和其他的组件最好是同一中，不然在复制过程中可能会出现异常。</p>
<h3 id="init-sql-初始化数据"><a href="#init-sql-初始化数据" class="headerlink" title="init.sql 初始化数据"></a>init.sql 初始化数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-- 创建 data_copy 数据库</span><br><span class="line">DROP DATABASE IF EXISTS `data_copy`;</span><br><span class="line">CREATE DATABASE `data_copy` /*!40100 DEFAULT CHARACTER SET utf8mb4 collate utf8mb4_general_ci */;</span><br><span class="line"></span><br><span class="line">-- 创建 person 表</span><br><span class="line">USE `data_copy`;</span><br><span class="line">DROP TABLE IF EXISTS `person`;</span><br><span class="line">CREATE TABLE `person` (</span><br><span class="line">  `<span class="built_in">id</span>` int(32) NOT NULL,</span><br><span class="line">  `name` varchar(255) DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`<span class="built_in">id</span>`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;</span><br></pre></td></tr></table></figure>
<p>创建<code>data_copy</code>数据库和<code>person</code>表。</p>
<h3 id="start-sh-脚本"><a href="#start-sh-脚本" class="headerlink" title="start.sh 脚本"></a>start.sh 脚本</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;启动mysql&#x27;</span></span><br><span class="line">service mysql start</span><br><span class="line"><span class="built_in">sleep</span> 5</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;初始化数据库&#x27;</span></span><br><span class="line">mysql -uroot -pytao &lt; /mysql/init.sql</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;初始化完成！&#x27;</span></span><br><span class="line"><span class="built_in">tail</span> -f /dev/null</span><br></pre></td></tr></table></figure>

<h2 id="构建master和slave镜像并运行容器"><a href="#构建master和slave镜像并运行容器" class="headerlink" title="构建master和slave镜像并运行容器"></a>构建<code>master</code>和<code>slave</code>镜像并运行容器</h2><p>构建<code>master</code>镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t master/mysql .</span><br></pre></td></tr></table></figure>
<p>构建<code>slave</code>镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t slave/mysql .</span><br></pre></td></tr></table></figure>
<p>构建成功会返回 <code>Successfuly</code>，或通过<code>docker images</code>命令查看镜像<br><img src="https://images.ytao.top/Dockerfile%E6%9E%84%E5%BB%BA%E6%88%90%E5%8A%9F.png" alt="Dockerfile构建成功"></p>
<p>使用刚构建的镜像来运行容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># master 容器</span></span><br><span class="line">docker run --name master -p 3306:3306 -v /usr/local/mysql/master/data/:/var/lib/mysql -d master/mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># slave 容器</span></span><br><span class="line">docker run --name slave -p 3307:3306 -v /usr/local/mysql/slave/data/:/var/lib/mysql -d slave/mysql</span><br></pre></td></tr></table></figure>
<p>指定<code>master</code>端口为<code>3306</code>,<code>slave</code>端口为<code>3307</code>，挂载data目录为保存数据的目录。</p>
<p>连接到数据库后验证数据库是否初始化成功<br><img src="https://images.ytao.top/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E8%A1%A8.png" alt="数据库初始化的表"></p>
<p>查看 <code>log-bin</code> 是否开启<br><img src="https://images.ytao.top/log-bin%E6%98%AF%E5%90%A6%E5%BC%80%E5%90%AF.png" alt="log-bin是否开启"></p>
<h1 id="创建复制账号"><a href="#创建复制账号" class="headerlink" title="创建复制账号"></a>创建复制账号</h1><p>前面有提到从库I&#x2F;O线程要与主库建立连接，所以需要用到账号进行验证。账号除了要有连接权限（REPLICATION CLIENT），同时还要有复制权限（REPLICATION SLAVE）。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GRANT REPLICATION CLIENT, REPLICATION SLAVE ON *.* TO muser@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;ytao&#x27;</span>;   </span><br></pre></td></tr></table></figure>
<p>这里设置的访问地址是开放的，实际使用过程中安全起见一定要指定访问地址。</p>
<h1 id="从库启动复制"><a href="#从库启动复制" class="headerlink" title="从库启动复制"></a>从库启动复制</h1><p>从库连接到主库，获取到二进制日志后重放。这里首先要配置上面创建的账号进行连接，使用命令进行相应的设置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO </span><br><span class="line">MASTER_HOST = &#x27;47.107.xx.xxx&#x27;,</span><br><span class="line">MASTER_PORT = 3306,</span><br><span class="line">MASTER_USER = &#x27;muser&#x27;,</span><br><span class="line">MASTER_PASSWORD = &#x27;ytao&#x27;,</span><br><span class="line">MASTER_LOG_FILE = &#x27;mysql-bin.000006&#x27;;</span><br></pre></td></tr></table></figure>

<p>到这里复制还没有启动，需要再从库中启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">START SLAVE;</span><br></pre></td></tr></table></figure>
<p>使用<code>SHOW SLAVE STATUS\G;</code>命令查看启动后的情况<br><img src="https://images.ytao.top/%E5%A4%8D%E5%88%B6%E5%90%AF%E5%8A%A8%E4%BF%A1%E6%81%AF.png" alt="复制启动信息"></p>
<p>上面标记的输出信息<code>Slave_IO_Running: Yes</code>和<code>Slave_SQL_Running: Yes</code>可以看到I&#x2F;O线程和SQL线程已启动运行中。</p>
<h1 id="测试同步数据"><a href="#测试同步数据" class="headerlink" title="测试同步数据"></a>测试同步数据</h1><p>如果在主库中添加，更新或删除一个数据，那么从库中应该也有与主库对应的数据变化。<br>向主库添加一条数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO `data_copy`.`person` (`id`, `name`) VALUES (&#x27;1&#x27;, &#x27;ytao&#x27;);</span><br></pre></td></tr></table></figure>
<p>查询从库数据，数据已被同步过来。<br><img src="https://images.ytao.top/%E6%9F%A5%E8%AF%A2%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE.png" alt="查询从库数据"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>上述是最简单最基本的配置，但是理解上面的配置过程，就可以根据自身情况定制不同方案，实现一主多从，主主复制（主动-主动或主动-被动模式）等等来满足自身需求。<br><code>MySQL</code>的复制虽然使用简单方便，但也伴随着一些问题需要我们在使用中进行解决，比如：不能从服务器异常停止中恢复，数据同步的延迟等等，还好现在遇到的大部分问题在行业中已得到相应的解决。对这方面感兴趣的可以去了解下现在解决这些问题的中间件实现方案。</p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据复制</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis启动之XMLConfigBuilder解析配置文件（二）</title>
    <url>/2019/10/10/2_myBatis%E5%90%AF%E5%8A%A8%E4%B9%8BXMLConfigBuilder%E8%A7%A3%E6%9E%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/401280w_1l_2o_100sh.jpg" alt="ytao"></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><img src="https://images.ytao.top/BaseBuilder%E6%89%80%E6%9C%89%E5%AD%90%E7%B1%BB.png" alt="BaseBuilder所有子类"></p>
<blockquote>
<p><code>XMLConfigBuilder</code> 是<code>BaseBuilder</code>（解析中会涉及到讲解）的其中一个子类，它的作用是把MyBatis的XML及相关配置解析出来，然后保存到<code>Configuration</code>中。本文就解析过程按照执行顺序进行分析，掌握常用配置的解析原理。</p>
</blockquote>
<span id="more"></span>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>调用<code>XMLConfigBuilder</code>进行解析，要进行两步操作，上篇文章中【MyBatis之启动分析（一）】有提到。</p>
<h3 id="实例化XMLConfigBuilder对象。"><a href="#实例化XMLConfigBuilder对象。" class="headerlink" title="实例化XMLConfigBuilder对象。"></a>实例化<code>XMLConfigBuilder</code>对象。</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="title function_">XMLConfigBuilder</span><span class="params">(XPathParser parser, String environment, Properties props)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用父类的构造方法</span></span><br><span class="line">    <span class="built_in">super</span>(<span class="keyword">new</span> <span class="title class_">Configuration</span>());</span><br><span class="line">    ErrorContext.instance().resource(<span class="string">&quot;SQL Mapper Configuration&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.configuration.setVariables(props);</span><br><span class="line">    <span class="built_in">this</span>.parsed = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">this</span>.environment = environment;</span><br><span class="line">    <span class="built_in">this</span>.parser = parser;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h4 id="实例化Configuration"><a href="#实例化Configuration" class="headerlink" title="实例化Configuration"></a>实例化<code>Configuration</code></h4><p>通过<code>new Configuration()</code>的方式实例化：<br><img src="https://images.ytao.top/new_configuration.png" alt="new Configuration()"><br><code>typeAliasRegistry</code>是一个类型别名注册器，实现原理就是维护一份<code>HashMap</code>，别名作为<code>key</code>，类的全限定名作为<code>value</code>。这里将框架中使用的类注册到类型别名注册器中。<br><code>TypeAliasRegistry.registerAlias</code>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerAlias</span><span class="params">(String alias, Class&lt;?&gt; value)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (alias == <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeException</span>(<span class="string">&quot;The parameter alias cannot be null&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// issue #748</span></span><br><span class="line"><span class="comment">//  在验证是否存在key和保存kv前，统一将key转换成小写</span></span><br><span class="line"><span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> alias.toLowerCase(Locale.ENGLISH);</span><br><span class="line"><span class="keyword">if</span> (TYPE_ALIASES.containsKey(key) &amp;&amp; TYPE_ALIASES.get(key) != <span class="literal">null</span> &amp;&amp; !TYPE_ALIASES.get(key).equals(value)) &#123;</span><br><span class="line">  <span class="comment">// 当注册的类型已存在时，抛出异常</span></span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeException</span>(<span class="string">&quot;The alias &#x27;&quot;</span> + alias + <span class="string">&quot;&#x27; is already mapped to the value &#x27;&quot;</span> + TYPE_ALIASES.get(key).getName() + <span class="string">&quot;&#x27;.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// TYPE_ALIASES 为定义的一个HashMap</span></span><br><span class="line">TYPE_ALIASES.put(key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实例化<code>Configuration</code>类过程中，在该类里除了实例化了<code>TypeAliasRegistry</code>还实例化了另外一个下面用到的的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型处理器注册器</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">TypeAliasRegistry</span> <span class="variable">typeAliasRegistry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TypeAliasRegistry</span>();</span><br></pre></td></tr></table></figure>
<p><code>TypeHandlerRegistry</code>和<code>TypeAliasRegistry</code>实例化逻辑相似，里面注册了一些常用类型和处理器，代码易懂。<br><code>TypeHandlerRegistry</code>的属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// jdbc类型和TypeHandler的映射关系，key必须是JdbcType的枚举类型，读取结果集数据时，将jdbc类型转换成java类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; JDBC_TYPE_HANDLER_MAP = <span class="keyword">new</span> <span class="title class_">EnumMap</span>&lt;JdbcType, TypeHandler&lt;?&gt;&gt;(JdbcType.class);</span><br><span class="line"><span class="comment">// Java类型与JdbcType类型的键值对，存在一对多的映射关系</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; TYPE_HANDLER_MAP = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt;();</span><br><span class="line"><span class="comment">// 没有相应的类型处理器时，使用的处理器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> TypeHandler&lt;Object&gt; UNKNOWN_TYPE_HANDLER = <span class="keyword">new</span> <span class="title class_">UnknownTypeHandler</span>(<span class="built_in">this</span>);</span><br><span class="line"><span class="comment">// 类型处理器类类型和类型处理器的映射关系</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt; ALL_TYPE_HANDLERS_MAP = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Class&lt;?&gt;, TypeHandler&lt;?&gt;&gt;();</span><br><span class="line"><span class="comment">// 空处理器的值，用来做校验</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; NULL_TYPE_HANDLER_MAP = Collections.emptyMap();</span><br><span class="line"><span class="comment">// 默认枚举类型处理器</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">TypeHandler</span>&gt; defaultEnumTypeHandler = EnumTypeHandler.class;</span><br></pre></td></tr></table></figure>
<p><code>TypeHandlerRegistry</code>构造函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TypeHandlerRegistry</span><span class="params">()</span> &#123;</span><br><span class="line">    register(Boolean.class, <span class="keyword">new</span> <span class="title class_">BooleanTypeHandler</span>());</span><br><span class="line">    register(<span class="type">boolean</span>.class, <span class="keyword">new</span> <span class="title class_">BooleanTypeHandler</span>());</span><br><span class="line">    register(JdbcType.BOOLEAN, <span class="keyword">new</span> <span class="title class_">BooleanTypeHandler</span>());</span><br><span class="line">    register(JdbcType.BIT, <span class="keyword">new</span> <span class="title class_">BooleanTypeHandler</span>());</span><br><span class="line"></span><br><span class="line">    register(Byte.class, <span class="keyword">new</span> <span class="title class_">ByteTypeHandler</span>());</span><br><span class="line">    register(<span class="type">byte</span>.class, <span class="keyword">new</span> <span class="title class_">ByteTypeHandler</span>());</span><br><span class="line">    register(JdbcType.TINYINT, <span class="keyword">new</span> <span class="title class_">ByteTypeHandler</span>());</span><br><span class="line"></span><br><span class="line">    register(Short.class, <span class="keyword">new</span> <span class="title class_">ShortTypeHandler</span>());</span><br><span class="line">    register(<span class="type">short</span>.class, <span class="keyword">new</span> <span class="title class_">ShortTypeHandler</span>());</span><br><span class="line">    register(JdbcType.SMALLINT, <span class="keyword">new</span> <span class="title class_">ShortTypeHandler</span>());</span><br><span class="line"></span><br><span class="line">    register(Integer.class, <span class="keyword">new</span> <span class="title class_">IntegerTypeHandler</span>());</span><br><span class="line">    register(<span class="type">int</span>.class, <span class="keyword">new</span> <span class="title class_">IntegerTypeHandler</span>());</span><br><span class="line">    register(JdbcType.INTEGER, <span class="keyword">new</span> <span class="title class_">IntegerTypeHandler</span>());</span><br><span class="line"></span><br><span class="line">    register(Long.class, <span class="keyword">new</span> <span class="title class_">LongTypeHandler</span>());</span><br><span class="line">    register(<span class="type">long</span>.class, <span class="keyword">new</span> <span class="title class_">LongTypeHandler</span>());</span><br><span class="line"></span><br><span class="line">    register(Float.class, <span class="keyword">new</span> <span class="title class_">FloatTypeHandler</span>());</span><br><span class="line">    register(<span class="type">float</span>.class, <span class="keyword">new</span> <span class="title class_">FloatTypeHandler</span>());</span><br><span class="line">    register(JdbcType.FLOAT, <span class="keyword">new</span> <span class="title class_">FloatTypeHandler</span>());</span><br><span class="line"></span><br><span class="line">    register(Double.class, <span class="keyword">new</span> <span class="title class_">DoubleTypeHandler</span>());</span><br><span class="line">    register(<span class="type">double</span>.class, <span class="keyword">new</span> <span class="title class_">DoubleTypeHandler</span>());</span><br><span class="line">    register(JdbcType.DOUBLE, <span class="keyword">new</span> <span class="title class_">DoubleTypeHandler</span>());</span><br><span class="line"></span><br><span class="line">    register(Reader.class, <span class="keyword">new</span> <span class="title class_">ClobReaderTypeHandler</span>());</span><br><span class="line">    register(String.class, <span class="keyword">new</span> <span class="title class_">StringTypeHandler</span>());</span><br><span class="line">    register(String.class, JdbcType.CHAR, <span class="keyword">new</span> <span class="title class_">StringTypeHandler</span>());</span><br><span class="line">    register(String.class, JdbcType.CLOB, <span class="keyword">new</span> <span class="title class_">ClobTypeHandler</span>());</span><br><span class="line">    register(String.class, JdbcType.VARCHAR, <span class="keyword">new</span> <span class="title class_">StringTypeHandler</span>());</span><br><span class="line">    register(String.class, JdbcType.LONGVARCHAR, <span class="keyword">new</span> <span class="title class_">ClobTypeHandler</span>());</span><br><span class="line">    register(String.class, JdbcType.NVARCHAR, <span class="keyword">new</span> <span class="title class_">NStringTypeHandler</span>());</span><br><span class="line">    register(String.class, JdbcType.NCHAR, <span class="keyword">new</span> <span class="title class_">NStringTypeHandler</span>());</span><br><span class="line">    register(String.class, JdbcType.NCLOB, <span class="keyword">new</span> <span class="title class_">NClobTypeHandler</span>());</span><br><span class="line">    register(JdbcType.CHAR, <span class="keyword">new</span> <span class="title class_">StringTypeHandler</span>());</span><br><span class="line">    register(JdbcType.VARCHAR, <span class="keyword">new</span> <span class="title class_">StringTypeHandler</span>());</span><br><span class="line">    register(JdbcType.CLOB, <span class="keyword">new</span> <span class="title class_">ClobTypeHandler</span>());</span><br><span class="line">    register(JdbcType.LONGVARCHAR, <span class="keyword">new</span> <span class="title class_">ClobTypeHandler</span>());</span><br><span class="line">    register(JdbcType.NVARCHAR, <span class="keyword">new</span> <span class="title class_">NStringTypeHandler</span>());</span><br><span class="line">    register(JdbcType.NCHAR, <span class="keyword">new</span> <span class="title class_">NStringTypeHandler</span>());</span><br><span class="line">    register(JdbcType.NCLOB, <span class="keyword">new</span> <span class="title class_">NClobTypeHandler</span>());</span><br><span class="line"></span><br><span class="line">    register(Object.class, JdbcType.ARRAY, <span class="keyword">new</span> <span class="title class_">ArrayTypeHandler</span>());</span><br><span class="line">    register(JdbcType.ARRAY, <span class="keyword">new</span> <span class="title class_">ArrayTypeHandler</span>());</span><br><span class="line"></span><br><span class="line">    register(BigInteger.class, <span class="keyword">new</span> <span class="title class_">BigIntegerTypeHandler</span>());</span><br><span class="line">    register(JdbcType.BIGINT, <span class="keyword">new</span> <span class="title class_">LongTypeHandler</span>());</span><br><span class="line"></span><br><span class="line">    register(BigDecimal.class, <span class="keyword">new</span> <span class="title class_">BigDecimalTypeHandler</span>());</span><br><span class="line">    register(JdbcType.REAL, <span class="keyword">new</span> <span class="title class_">BigDecimalTypeHandler</span>());</span><br><span class="line">    register(JdbcType.DECIMAL, <span class="keyword">new</span> <span class="title class_">BigDecimalTypeHandler</span>());</span><br><span class="line">    register(JdbcType.NUMERIC, <span class="keyword">new</span> <span class="title class_">BigDecimalTypeHandler</span>());</span><br><span class="line"></span><br><span class="line">    register(InputStream.class, <span class="keyword">new</span> <span class="title class_">BlobInputStreamTypeHandler</span>());</span><br><span class="line">    register(Byte[].class, <span class="keyword">new</span> <span class="title class_">ByteObjectArrayTypeHandler</span>());</span><br><span class="line">    register(Byte[].class, JdbcType.BLOB, <span class="keyword">new</span> <span class="title class_">BlobByteObjectArrayTypeHandler</span>());</span><br><span class="line">    register(Byte[].class, JdbcType.LONGVARBINARY, <span class="keyword">new</span> <span class="title class_">BlobByteObjectArrayTypeHandler</span>());</span><br><span class="line">    register(<span class="type">byte</span>[].class, <span class="keyword">new</span> <span class="title class_">ByteArrayTypeHandler</span>());</span><br><span class="line">    register(<span class="type">byte</span>[].class, JdbcType.BLOB, <span class="keyword">new</span> <span class="title class_">BlobTypeHandler</span>());</span><br><span class="line">    register(<span class="type">byte</span>[].class, JdbcType.LONGVARBINARY, <span class="keyword">new</span> <span class="title class_">BlobTypeHandler</span>());</span><br><span class="line">    register(JdbcType.LONGVARBINARY, <span class="keyword">new</span> <span class="title class_">BlobTypeHandler</span>());</span><br><span class="line">    register(JdbcType.BLOB, <span class="keyword">new</span> <span class="title class_">BlobTypeHandler</span>());</span><br><span class="line"></span><br><span class="line">    register(Object.class, UNKNOWN_TYPE_HANDLER);</span><br><span class="line">    register(Object.class, JdbcType.OTHER, UNKNOWN_TYPE_HANDLER);</span><br><span class="line">    register(JdbcType.OTHER, UNKNOWN_TYPE_HANDLER);</span><br><span class="line"></span><br><span class="line">    register(Date.class, <span class="keyword">new</span> <span class="title class_">DateTypeHandler</span>());</span><br><span class="line">    register(Date.class, JdbcType.DATE, <span class="keyword">new</span> <span class="title class_">DateOnlyTypeHandler</span>());</span><br><span class="line">    register(Date.class, JdbcType.TIME, <span class="keyword">new</span> <span class="title class_">TimeOnlyTypeHandler</span>());</span><br><span class="line">    register(JdbcType.TIMESTAMP, <span class="keyword">new</span> <span class="title class_">DateTypeHandler</span>());</span><br><span class="line">    register(JdbcType.DATE, <span class="keyword">new</span> <span class="title class_">DateOnlyTypeHandler</span>());</span><br><span class="line">    register(JdbcType.TIME, <span class="keyword">new</span> <span class="title class_">TimeOnlyTypeHandler</span>());</span><br><span class="line"></span><br><span class="line">    register(java.sql.Date.class, <span class="keyword">new</span> <span class="title class_">SqlDateTypeHandler</span>());</span><br><span class="line">    register(java.sql.Time.class, <span class="keyword">new</span> <span class="title class_">SqlTimeTypeHandler</span>());</span><br><span class="line">    register(java.sql.Timestamp.class, <span class="keyword">new</span> <span class="title class_">SqlTimestampTypeHandler</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mybatis-typehandlers-jsr310</span></span><br><span class="line">    <span class="comment">// 是否包含日期，时间相关的Api，通过判断是否加载java.time.Clock作为依据</span></span><br><span class="line">    <span class="keyword">if</span> (Jdk.dateAndTimeApiExists) &#123;</span><br><span class="line">      <span class="built_in">this</span>.register(Instant.class, InstantTypeHandler.class);</span><br><span class="line">      <span class="built_in">this</span>.register(LocalDateTime.class, LocalDateTimeTypeHandler.class);</span><br><span class="line">      <span class="built_in">this</span>.register(LocalDate.class, LocalDateTypeHandler.class);</span><br><span class="line">      <span class="built_in">this</span>.register(LocalTime.class, LocalTimeTypeHandler.class);</span><br><span class="line">      <span class="built_in">this</span>.register(OffsetDateTime.class, OffsetDateTimeTypeHandler.class);</span><br><span class="line">      <span class="built_in">this</span>.register(OffsetTime.class, OffsetTimeTypeHandler.class);</span><br><span class="line">      <span class="built_in">this</span>.register(ZonedDateTime.class, ZonedDateTimeTypeHandler.class);</span><br><span class="line">      <span class="built_in">this</span>.register(Month.class, MonthTypeHandler.class);</span><br><span class="line">      <span class="built_in">this</span>.register(Year.class, YearTypeHandler.class);</span><br><span class="line">      <span class="built_in">this</span>.register(YearMonth.class, YearMonthTypeHandler.class);</span><br><span class="line">      <span class="built_in">this</span>.register(JapaneseDate.class, JapaneseDateTypeHandler.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// issue #273</span></span><br><span class="line">    register(Character.class, <span class="keyword">new</span> <span class="title class_">CharacterTypeHandler</span>());</span><br><span class="line">    register(<span class="type">char</span>.class, <span class="keyword">new</span> <span class="title class_">CharacterTypeHandler</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面调用了两个<code>register()</code>重载方法, <code>type + handler</code> 参的<code>TypeHandlerRegistry.register(Class&lt;T&gt; javaType, TypeHandler&lt;? extends T&gt; typeHandler)</code>和 <code>type + jdbc type + handler</code> 参的<code>TypeHandlerRegistry.register(Class&lt;T&gt; type, JdbcType jdbcType, TypeHandler&lt;? extends T&gt; handler)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// java type + handler</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;T&gt; javaType, TypeHandler&lt;? extends T&gt; typeHandler)</span> &#123;</span><br><span class="line">    register((Type) javaType, typeHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Type javaType, TypeHandler&lt;? extends T&gt; typeHandler)</span> &#123;</span><br><span class="line">    <span class="type">MappedJdbcTypes</span> <span class="variable">mappedJdbcTypes</span> <span class="operator">=</span> typeHandler.getClass().getAnnotation(MappedJdbcTypes.class);</span><br><span class="line">    <span class="keyword">if</span> (mappedJdbcTypes != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (JdbcType handledJdbcType : mappedJdbcTypes.value()) &#123;</span><br><span class="line">        register(javaType, handledJdbcType, typeHandler);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (mappedJdbcTypes.includeNullJdbcType()) &#123;</span><br><span class="line">        register(javaType, <span class="literal">null</span>, typeHandler);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      register(javaType, <span class="literal">null</span>, typeHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java type + jdbc type + handler</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;T&gt; type, JdbcType jdbcType, TypeHandler&lt;? extends T&gt; handler)</span> &#123;</span><br><span class="line">    register((Type) type, jdbcType, handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// type + handler 和 type + jdbc type + handler 最终都调用此方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Type javaType, JdbcType jdbcType, TypeHandler&lt;?&gt; handler)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (javaType != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 当 javaType 不为空时， 获取 java 类型的的映射</span></span><br><span class="line">      Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; map = TYPE_HANDLER_MAP.get(javaType);</span><br><span class="line">      <span class="keyword">if</span> (map == <span class="literal">null</span> || map == NULL_TYPE_HANDLER_MAP) &#123;</span><br><span class="line">        <span class="comment">// 若映射为空，新建一个映射关系</span></span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;JdbcType, TypeHandler&lt;?&gt;&gt;();</span><br><span class="line">        <span class="comment">// 保存至类型处理器映射关系中</span></span><br><span class="line">        TYPE_HANDLER_MAP.put(javaType, map);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 保存jdbcType和处理器关系，完成 java类型，jdbc类型，处理器三者之间的注册</span></span><br><span class="line">      map.put(jdbcType, handler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 保存处理器信息中</span></span><br><span class="line">    ALL_TYPE_HANDLERS_MAP.put(handler.getClass(), handler);</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">// MappedJdbcTypes 注解        </span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MappedJdbcTypes &#123;</span><br><span class="line">  JdbcType[] value();</span><br><span class="line">  <span class="type">boolean</span> <span class="title function_">includeNullJdbcType</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>type + handler</code>方法：先获取处理器的<code>MappedJdbcTypes</code>注解（自定义处理器注解），若注解的<code>value</code>值不为空时，由于该值为<code>JdbcType[]</code>类型，所以<code>for</code>循环 <code>javaType+jdbcType+TypeHandler</code>注册，若<code>includeNullJdbcType</code>（<code>jdbcType</code>是否包含<code>null</code>）为<code>true</code>，默认值为<code>false</code>,注册到相应映射中。若注解的<code>value</code>为<code>null</code>，直接调用注册操作，里面不会注册<code>type + jdbc type + handler</code>关系。</li>
<li><code>type + jdbc type + handler</code>方法：该方法将java类强制转换为<code>java.lang.reflect.Type</code>类型，然后调用最终注册的方法。</li>
</ul>
<h4 id="调用父类BaseBuilder的构造方法"><a href="#调用父类BaseBuilder的构造方法" class="headerlink" title="调用父类BaseBuilder的构造方法"></a>调用父类<code>BaseBuilder</code>的构造方法</h4><p><code>BaseBuilder</code>定义有三个属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Configuration configuration;</span><br><span class="line"><span class="comment">// 类型别名注册器</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> TypeAliasRegistry typeAliasRegistry;</span><br><span class="line"><span class="comment">// 类型处理器注册器</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry;</span><br></pre></td></tr></table></figure>
<p><code>BaseBuilder</code>构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">BaseBuilder</span><span class="params">(Configuration configuration)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.configuration = configuration;</span><br><span class="line">    <span class="built_in">this</span>.typeAliasRegistry = <span class="built_in">this</span>.configuration.getTypeAliasRegistry();</span><br><span class="line">    <span class="built_in">this</span>.typeHandlerRegistry = <span class="built_in">this</span>.configuration.getTypeHandlerRegistry();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里属性，就是上面讲解到的。</p>
<h3 id="调用-XMLConfigBuilder-parse-作为解析入口。"><a href="#调用-XMLConfigBuilder-parse-作为解析入口。" class="headerlink" title="调用 XMLConfigBuilder.parse() 作为解析入口。"></a>调用 <code>XMLConfigBuilder.parse()</code> 作为解析入口。</h3><p><code>parse()</code>实现配置文件是否解析过</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Configuration <span class="title function_">parse</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 若parsed为true，配置文件解析过</span></span><br><span class="line">    <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Each XMLConfigBuilder can only be used once.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标志已解析过</span></span><br><span class="line">    parsed = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 从根节点 configuration 开始解析</span></span><br><span class="line">    parseConfiguration(parser.evalNode(<span class="string">&quot;/configuration&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析<code>/configuration</code>里的配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">parseConfiguration</span><span class="params">(XNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//issue #117 read properties first</span></span><br><span class="line">      propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>));</span><br><span class="line">      <span class="type">Properties</span> <span class="variable">settings</span> <span class="operator">=</span> settingsAsProperties(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line">      loadCustomVfs(settings);</span><br><span class="line">      typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));</span><br><span class="line">      pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line">      objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));</span><br><span class="line">      objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));</span><br><span class="line">      reflectorFactoryElement(root.evalNode(<span class="string">&quot;reflectorFactory&quot;</span>));</span><br><span class="line">      settingsElement(settings);</span><br><span class="line">      <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">      environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>));</span><br><span class="line">      databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));</span><br><span class="line">      typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));</span><br><span class="line">      mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error parsing SQL Mapper Configuration. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面源码中，不难看出这里是解析<code>/configuration</code>中的各个子节点。</p>
<h4 id="properties-节点解析"><a href="#properties-节点解析" class="headerlink" title="properties 节点解析"></a>properties 节点解析</h4><h5 id="properties配置方式"><a href="#properties配置方式" class="headerlink" title="properties配置方式"></a><code>properties</code>配置方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;!-- 方法一 --&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span> /&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 方法二 --&gt;</span><br><span class="line">&lt;properties resource=<span class="string">&quot;xxxConfig.properties&quot;</span>&gt;</span><br><span class="line">&lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 方法三 --&gt;</span><br><span class="line">&lt;properties url=<span class="string">&quot;file:///D:/xxxConfig.properties&quot;</span>&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure>
<h5 id="propertiesElement-方法"><a href="#propertiesElement-方法" class="headerlink" title="propertiesElement()方法"></a><code>propertiesElement()</code>方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">propertiesElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 获取 propertie 节点，并保存 Properties 中</span></span><br><span class="line">      <span class="type">Properties</span> <span class="variable">defaults</span> <span class="operator">=</span> context.getChildrenAsProperties();</span><br><span class="line">      <span class="comment">// 获取 resource 的值</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">      <span class="comment">// 获取 url 的值</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (resource != <span class="literal">null</span> &amp;&amp; url != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;The properties element cannot specify both a URL and a resource based property file reference.  Please specify one or the other.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (resource != <span class="literal">null</span>) &#123;</span><br><span class="line">        defaults.putAll(Resources.getResourceAsProperties(resource));</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (url != <span class="literal">null</span>) &#123;</span><br><span class="line">        defaults.putAll(Resources.getUrlAsProperties(url));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Properties</span> <span class="variable">vars</span> <span class="operator">=</span> configuration.getVariables();</span><br><span class="line">      <span class="keyword">if</span> (vars != <span class="literal">null</span>) &#123;</span><br><span class="line">        defaults.putAll(vars);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将解析的值保存到 XPathParser 中</span></span><br><span class="line">      parser.setVariables(defaults);</span><br><span class="line">      <span class="comment">// 将解析的值保存到 Configuration 中</span></span><br><span class="line">      configuration.setVariables(defaults);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面源码中，<code>resource</code>和<code>url</code>的配置形式不允许同时存在，否则抛出<code>BuilderException</code>异常。先解析<code>propertie</code>的配置值，再解析<code>resource</code>或<code>url</code>的值。<br>当<code>propertie</code>存在与<code>resource</code>或<code>url</code>相同的<code>key</code>时，<code>propertie</code>的配置会被覆盖，应为<code>Properties</code>实现的原理就是继承的<code>Hashtable</code>类来实现的。</p>
<h4 id="settings-节点解析"><a href="#settings-节点解析" class="headerlink" title="settings 节点解析"></a>settings 节点解析</h4><h5 id="settings配置方式"><a href="#settings配置方式" class="headerlink" title="settings配置方式"></a><code>settings</code>配置方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;setting name=<span class="string">&quot;cacheEnabled&quot;</span> value=<span class="string">&quot;true&quot;</span> /&gt;</span><br><span class="line">    ......</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>
<p>设置中各项的意图、默认值 <a href="https://images.ytao.top/settings%E4%B8%AD%E5%90%84%E9%A1%B9%E7%9A%84%E6%84%8F%E5%9B%BE%E3%80%81%E9%BB%98%E8%AE%A4%E5%80%BC.png">图</a>(引用来源：w3cschool)</p>
<table>
<thead>
<tr>
<th align="left">设置参数</th>
<th align="center">描述</th>
<th align="center">有效值</th>
<th align="center">默认值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cacheEnabled</td>
<td align="center">该配置影响的所有映射器中配置的缓存的全局开关。</td>
<td align="center">true,false</td>
<td align="center">true</td>
</tr>
<tr>
<td align="left">lazyLoadingEnabled</td>
<td align="center">延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态。</td>
<td align="center">true,false</td>
<td align="center">false</td>
</tr>
<tr>
<td align="left">aggressiveLazyLoading</td>
<td align="center">当启用时，对任意延迟属性的调用会使带有延迟加载属性的对象完整加载；反之，每种属性将会按需加载。</td>
<td align="center">true,false,true</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">multipleResultSetsEnabled</td>
<td align="center">是否允许单一语句返回多结果集（需要兼容驱动）。</td>
<td align="center">true,false</td>
<td align="center">true</td>
</tr>
<tr>
<td align="left">useColumnLabel</td>
<td align="center">使用列标签代替列名。不同的驱动在这方面会有不同的表现， 具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。</td>
<td align="center">true,false</td>
<td align="center">true</td>
</tr>
<tr>
<td align="left">useGeneratedKeys</td>
<td align="center">允许 JDBC 支持自动生成主键，需要驱动兼容。 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如 Derby）。</td>
<td align="center">true,false</td>
<td align="center">False</td>
</tr>
<tr>
<td align="left">autoMappingBehavior</td>
<td align="center">指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示取消自动映射；PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。 FULL 会自动映射任意复杂的结果集（无论是否嵌套）。</td>
<td align="center">NONE, PARTIAL, FULL</td>
<td align="center">PARTIAL</td>
</tr>
<tr>
<td align="left">defaultExecutorType</td>
<td align="center">配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。</td>
<td align="center">SIMPLE REUSE BATCH</td>
<td align="center">SIMPLE</td>
</tr>
<tr>
<td align="left">defaultStatementTimeout</td>
<td align="center">设置超时时间，它决定驱动等待数据库响应的秒数。</td>
<td align="center">Any positive integer</td>
<td align="center">Not Set (null)</td>
</tr>
<tr>
<td align="left">safeRowBoundsEnabled</td>
<td align="center">允许在嵌套语句中使用分页（RowBounds）。</td>
<td align="center">true,false</td>
<td align="center">False</td>
</tr>
<tr>
<td align="left">mapUnderscoreToCamelCase</td>
<td align="center">是否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。</td>
<td align="center">true, false</td>
<td align="center">False</td>
</tr>
<tr>
<td align="left">localCacheScope</td>
<td align="center">MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地会话仅用在语句执行上，对相同 SqlSession 的不同调用将不会共享数据。</td>
<td align="center">SESSION,STATEMENT</td>
<td align="center">SESSION</td>
</tr>
<tr>
<td align="left">jdbcTypeForNull</td>
<td align="center">当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。</td>
<td align="center">JdbcType enumeration. Most common are: NULL, VARCHAR and OTHER</td>
<td align="center">OTHER</td>
</tr>
<tr>
<td align="left">lazyLoadTriggerMethods</td>
<td align="center">指定哪个对象的方法触发一次延迟加载。</td>
<td align="center">A method name list separated by commas</td>
<td align="center">equals,clone,hashCode,toString</td>
</tr>
<tr>
<td align="left">defaultScriptingLanguage</td>
<td align="center">指定动态 SQL 生成的默认语言。</td>
<td align="center">A type alias or fully qualified class name.</td>
<td align="center">org.apache.ibatis.scripting.xmltags.XMLDynamicLanguageDriver</td>
</tr>
<tr>
<td align="left">callSettersOnNulls</td>
<td align="center">指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这对于有 Map.keySet() 依赖或 null 值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null 的。</td>
<td align="center">true,false</td>
<td align="center">false</td>
</tr>
<tr>
<td align="left">logPrefix</td>
<td align="center">指定 MyBatis 增加到日志名称的前缀。	Any String</td>
<td align="center">Not set</td>
<td align="center"></td>
</tr>
<tr>
<td align="left">logImpl</td>
<td align="center">指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</td>
<td align="center">SLF4J, LOG4J, LOG4J2, JDK_LOGGING, COMMONS_LOGGING, STDOUT_LOGGING, NO_LOGGING</td>
<td align="center">Not set</td>
</tr>
<tr>
<td align="left">proxyFactory</td>
<td align="center">指定 Mybatis 创建具有延迟加载能力的对象所用到的代理工具。</td>
<td align="center">CGLIB JAVASSIST</td>
<td align="center">CGLIB</td>
</tr>
</tbody></table>
<h5 id="settingsAsProperties-方法"><a href="#settingsAsProperties-方法" class="headerlink" title="settingsAsProperties()方法"></a><code>settingsAsProperties()</code>方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Properties <span class="title function_">settingsAsProperties</span><span class="params">(XNode context)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取setting节点的name和value，并保存至Properties返回</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> context.getChildrenAsProperties();</span><br><span class="line">    <span class="comment">// Check that all settings are known to the configuration class</span></span><br><span class="line">    <span class="comment">// 创建Configuration的MetaClass</span></span><br><span class="line">    <span class="type">MetaClass</span> <span class="variable">metaConfig</span> <span class="operator">=</span> MetaClass.forClass(Configuration.class, localReflectorFactory);</span><br><span class="line">    <span class="comment">// 校验Configuration中是否有setting设置的name值</span></span><br><span class="line">    <span class="keyword">for</span> (Object key : props.keySet()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!metaConfig.hasSetter(String.valueOf(key))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;The setting &quot;</span> + key + <span class="string">&quot; is not known.  Make sure you spelled it correctly (case sensitive).&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> props;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里获取到<code>setting</code>的值，并返回<code>Properties</code>对象。然后做配置的<code>name</code>是否合法。<br><code>org.apache.ibatis.reflection.MetaClass</code>类是保存着一个利用反射获取到的类信息，<code>metaConfig.hasSetter(String.valueOf(key))</code>是判断<code>metaConfig</code>对象中是否包含<code>key</code>属性。</p>
<h5 id="vfsImpl-方法"><a href="#vfsImpl-方法" class="headerlink" title="vfsImpl()方法"></a><code>vfsImpl()</code>方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadCustomVfs</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> props.getProperty(<span class="string">&quot;vfsImpl&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (value != <span class="literal">null</span>) &#123;</span><br><span class="line">      String[] clazzes = value.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (String clazz : clazzes) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!clazz.isEmpty()) &#123;</span><br><span class="line">          <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">          Class&lt;? <span class="keyword">extends</span> <span class="title class_">VFS</span>&gt; vfsImpl = (Class&lt;? <span class="keyword">extends</span> <span class="title class_">VFS</span>&gt;)Resources.classForName(clazz);</span><br><span class="line">          configuration.setVfsImpl(vfsImpl);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法是解析虚拟文件系统配置，用来加载自定义虚拟文件系统的资源。类保存在<code>Configuration.vfsImpl</code>中。</p>
<h5 id="settingsElement-方法"><a href="#settingsElement-方法" class="headerlink" title="settingsElement()方法"></a><code>settingsElement()</code>方法</h5><p>这个方法的作用就是将解析的<code>settings</code>设置到 <code>configuration</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">settingsElement</span><span class="params">(Properties props)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    configuration.setAutoMappingBehavior(AutoMappingBehavior.valueOf(props.getProperty(<span class="string">&quot;autoMappingBehavior&quot;</span>, <span class="string">&quot;PARTIAL&quot;</span>)));</span><br><span class="line">    configuration.setAutoMappingUnknownColumnBehavior(AutoMappingUnknownColumnBehavior.valueOf(props.getProperty(<span class="string">&quot;autoMappingUnknownColumnBehavior&quot;</span>, <span class="string">&quot;NONE&quot;</span>)));</span><br><span class="line">    configuration.setCacheEnabled(booleanValueOf(props.getProperty(<span class="string">&quot;cacheEnabled&quot;</span>), <span class="literal">true</span>));</span><br><span class="line">    configuration.setProxyFactory((ProxyFactory) createInstance(props.getProperty(<span class="string">&quot;proxyFactory&quot;</span>)));</span><br><span class="line">    configuration.setLazyLoadingEnabled(booleanValueOf(props.getProperty(<span class="string">&quot;lazyLoadingEnabled&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">    configuration.setAggressiveLazyLoading(booleanValueOf(props.getProperty(<span class="string">&quot;aggressiveLazyLoading&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">    configuration.setMultipleResultSetsEnabled(booleanValueOf(props.getProperty(<span class="string">&quot;multipleResultSetsEnabled&quot;</span>), <span class="literal">true</span>));</span><br><span class="line">    configuration.setUseColumnLabel(booleanValueOf(props.getProperty(<span class="string">&quot;useColumnLabel&quot;</span>), <span class="literal">true</span>));</span><br><span class="line">    configuration.setUseGeneratedKeys(booleanValueOf(props.getProperty(<span class="string">&quot;useGeneratedKeys&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">    configuration.setDefaultExecutorType(ExecutorType.valueOf(props.getProperty(<span class="string">&quot;defaultExecutorType&quot;</span>, <span class="string">&quot;SIMPLE&quot;</span>)));</span><br><span class="line">    configuration.setDefaultStatementTimeout(integerValueOf(props.getProperty(<span class="string">&quot;defaultStatementTimeout&quot;</span>), <span class="literal">null</span>));</span><br><span class="line">    configuration.setDefaultFetchSize(integerValueOf(props.getProperty(<span class="string">&quot;defaultFetchSize&quot;</span>), <span class="literal">null</span>));</span><br><span class="line">    configuration.setMapUnderscoreToCamelCase(booleanValueOf(props.getProperty(<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">    configuration.setSafeRowBoundsEnabled(booleanValueOf(props.getProperty(<span class="string">&quot;safeRowBoundsEnabled&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">    configuration.setLocalCacheScope(LocalCacheScope.valueOf(props.getProperty(<span class="string">&quot;localCacheScope&quot;</span>, <span class="string">&quot;SESSION&quot;</span>)));</span><br><span class="line">    configuration.setJdbcTypeForNull(JdbcType.valueOf(props.getProperty(<span class="string">&quot;jdbcTypeForNull&quot;</span>, <span class="string">&quot;OTHER&quot;</span>)));</span><br><span class="line">    configuration.setLazyLoadTriggerMethods(stringSetValueOf(props.getProperty(<span class="string">&quot;lazyLoadTriggerMethods&quot;</span>), <span class="string">&quot;equals,clone,hashCode,toString&quot;</span>));</span><br><span class="line">    configuration.setSafeResultHandlerEnabled(booleanValueOf(props.getProperty(<span class="string">&quot;safeResultHandlerEnabled&quot;</span>), <span class="literal">true</span>));</span><br><span class="line">    configuration.setDefaultScriptingLanguage(resolveClass(props.getProperty(<span class="string">&quot;defaultScriptingLanguage&quot;</span>)));</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">TypeHandler</span>&gt; typeHandler = (Class&lt;? <span class="keyword">extends</span> <span class="title class_">TypeHandler</span>&gt;)resolveClass(props.getProperty(<span class="string">&quot;defaultEnumTypeHandler&quot;</span>));</span><br><span class="line">    configuration.setDefaultEnumTypeHandler(typeHandler);</span><br><span class="line">    configuration.setCallSettersOnNulls(booleanValueOf(props.getProperty(<span class="string">&quot;callSettersOnNulls&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">    configuration.setUseActualParamName(booleanValueOf(props.getProperty(<span class="string">&quot;useActualParamName&quot;</span>), <span class="literal">true</span>));</span><br><span class="line">    configuration.setReturnInstanceForEmptyRow(booleanValueOf(props.getProperty(<span class="string">&quot;returnInstanceForEmptyRow&quot;</span>), <span class="literal">false</span>));</span><br><span class="line">    configuration.setLogPrefix(props.getProperty(<span class="string">&quot;logPrefix&quot;</span>));</span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Log</span>&gt; logImpl = (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Log</span>&gt;)resolveClass(props.getProperty(<span class="string">&quot;logImpl&quot;</span>));</span><br><span class="line">    configuration.setLogImpl(logImpl);</span><br><span class="line">    configuration.setConfigurationFactory(resolveClass(props.getProperty(<span class="string">&quot;configurationFactory&quot;</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="typeAliases-节点解析"><a href="#typeAliases-节点解析" class="headerlink" title="typeAliases 节点解析"></a>typeAliases 节点解析</h4><h5 id="typeAliases配置方式"><a href="#typeAliases配置方式" class="headerlink" title="typeAliases配置方式"></a><code>typeAliases</code>配置方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">    &lt;<span class="keyword">package</span> name=<span class="string">&quot;com.ytao.main.model&quot;</span>/&gt;</span><br><span class="line">    <span class="comment">// 或</span></span><br><span class="line">    &lt;typeAlias type=<span class="string">&quot;com.ytao.main.model.Student&quot;</span> alias=<span class="string">&quot;student&quot;</span>/&gt;</span><br><span class="line">    &lt;typeAlias type=<span class="string">&quot;com.ytao.main.model.Person&quot;</span>/&gt;</span><br><span class="line">&lt;/typeAliases&gt;</span><br></pre></td></tr></table></figure>
<p>该节点是配置类和别名的关系</p>
<ol>
<li><code>package</code>节点是配置整个包下的类</li>
<li><code>typeAlias</code>节点是指定配置单个类，<code>type</code>为必填值且为类全限定名，<code>alias</code>为选填。<br>配置后，是该类时，可直接使用别名。</li>
</ol>
<h5 id="typeAliasesElement-方法"><a href="#typeAliasesElement-方法" class="headerlink" title="typeAliasesElement()方法"></a><code>typeAliasesElement()</code>方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">typeAliasesElement</span><span class="params">(XNode parent)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">          <span class="comment">// 以 package 方式配置</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">typeAliasPackage</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">          configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 以 alias 方式配置</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">alias</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;alias&quot;</span>);</span><br><span class="line">          <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Resources.classForName(type);</span><br><span class="line">            <span class="keyword">if</span> (alias == <span class="literal">null</span>) &#123;</span><br><span class="line">              typeAliasRegistry.registerAlias(clazz);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              typeAliasRegistry.registerAlias(alias, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error registering typeAlias for &#x27;&quot;</span> + alias + <span class="string">&quot;&#x27;. Cause: &quot;</span> + e, e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="使用-package-配置"><a href="#使用-package-配置" class="headerlink" title="使用 package 配置"></a>使用 package 配置</h6><p>当扫描<code>package</code>时，获取到包名后<code>TypeAliasRegistry.registerAliases(typeAliasPackage)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerAliases</span><span class="params">(String packageName)</span>&#123;</span><br><span class="line">    registerAliases(packageName, Object.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerAliases</span><span class="params">(String packageName, Class&lt;?&gt; superType)</span>&#123;</span><br><span class="line">    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = <span class="keyword">new</span> <span class="title class_">ResolverUtil</span>&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">    <span class="comment">// 获取 package 下所有已 .class 结尾的文件</span></span><br><span class="line">    resolverUtil.find(<span class="keyword">new</span> <span class="title class_">ResolverUtil</span>.IsA(superType), packageName);</span><br><span class="line">    <span class="comment">// 获取扫描出来的类</span></span><br><span class="line">    Set&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Class</span>&lt;?&gt;&gt;&gt; typeSet = resolverUtil.getClasses();</span><br><span class="line">    <span class="keyword">for</span>(Class&lt;?&gt; type : typeSet)&#123;</span><br><span class="line">      <span class="comment">// Ignore inner classes and interfaces (including package-info.java)</span></span><br><span class="line">      <span class="comment">// Skip also inner classes. See issue #6</span></span><br><span class="line">      <span class="comment">// 过滤类</span></span><br><span class="line">      <span class="keyword">if</span> (!type.isAnonymousClass() &amp;&amp; !type.isInterface() &amp;&amp; !type.isMemberClass()) &#123;</span><br><span class="line">        registerAlias(type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扫描到指定<code>package</code>下所有以<code>.class</code>结尾文件的类，并保存至Set集合中，然后遍历集合，过滤掉没有名称，接口，和底层特定类。<br>最后<code>TypeAliasRegistry.registerAlias(Class&lt;?&gt; type)</code>注册到别名注册器中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerAlias</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用类的 simpleName 作为别名，也就是默认的别名命名规则</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">alias</span> <span class="operator">=</span> type.getSimpleName();</span><br><span class="line">    <span class="type">Alias</span> <span class="variable">aliasAnnotation</span> <span class="operator">=</span> type.getAnnotation(Alias.class);</span><br><span class="line">    <span class="keyword">if</span> (aliasAnnotation != <span class="literal">null</span>) &#123;</span><br><span class="line">      alias = aliasAnnotation.value();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 上面分析的最终注册的方法</span></span><br><span class="line">    registerAlias(alias, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过类注册到注册器中时，如果该注册类有使用<code>@Alias</code>（<code>org.apache.ibatis.type.Alias</code>）注解，那么XML配置中配置的别名会被注解配置覆盖。</p>
<h6 id="使用-typeAlias-配置"><a href="#使用-typeAlias-配置" class="headerlink" title="使用 typeAlias 配置"></a>使用 typeAlias 配置</h6><p>如果<code>typeAlias</code>的<code>alias</code>有设置值，使用自定名称方式注册，否则使用默认方式注册，即类的simpleName作为别名。</p>
<h4 id="plugins-节点解析"><a href="#plugins-节点解析" class="headerlink" title="plugins 节点解析"></a>plugins 节点解析</h4><h5 id="plugins配置方式"><a href="#plugins配置方式" class="headerlink" title="plugins配置方式"></a><code>plugins</code>配置方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    <span class="comment">// 配置自定义插件，可指定在某个点进行拦截</span></span><br><span class="line">    &lt;plugin interceptor=<span class="string">&quot;com.ytao.main.plugin.DemoInterceptor&quot;</span>&gt;</span><br><span class="line">        <span class="comment">// 当前插件属性</span></span><br><span class="line">        &lt;property name=<span class="string">&quot;name&quot;</span> value=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure>
<p>自定义插件需要实现<code>org.apache.ibatis.plugin.Interceptor</code>接口,同时在注解上指定拦截的方法。</p>
<h5 id="pluginElement-方法"><a href="#pluginElement-方法" class="headerlink" title="pluginElement()方法"></a><code>pluginElement()</code>方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pluginElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">        <span class="comment">// 获取自定插件的类名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">interceptor</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;interceptor&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取插件属性</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> child.getChildrenAsProperties();</span><br><span class="line">        <span class="comment">// 实例化 Interceptor</span></span><br><span class="line">        <span class="type">Interceptor</span> <span class="variable">interceptorInstance</span> <span class="operator">=</span> (Interceptor) resolveClass(interceptor).newInstance();</span><br><span class="line">        <span class="comment">// 设置插件属性到插件中</span></span><br><span class="line">        interceptorInstance.setProperties(properties);</span><br><span class="line">        <span class="comment">// 将插件保存在 configuration 中</span></span><br><span class="line">        configuration.addInterceptor(interceptorInstance);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里取<code>&lt;plugin&gt;</code>节点的<code>interceptor</code>可以使用别名设置。从源码中<code>resolveClass</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveClass(String alias) &#123;</span><br><span class="line">    <span class="keyword">if</span> (alias == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> resolveAlias(alias);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Error resolving class. Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveAlias(String alias) &#123;</span><br><span class="line">    <span class="keyword">return</span> typeAliasRegistry.resolveAlias(alias);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; Class&lt;T&gt; <span class="title function_">resolveAlias</span><span class="params">(String string)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (string == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// issue #748</span></span><br><span class="line">      <span class="comment">// 将传入的 类 名称统一转换</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> string.toLowerCase(Locale.ENGLISH);</span><br><span class="line">      Class&lt;T&gt; value;</span><br><span class="line">      <span class="comment">// 验证别名中是否有当前传入的key</span></span><br><span class="line">      <span class="keyword">if</span> (TYPE_ALIASES.containsKey(key)) &#123;</span><br><span class="line">        value = (Class&lt;T&gt;) TYPE_ALIASES.get(key);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = (Class&lt;T&gt;) Resources.classForName(string);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeException</span>(<span class="string">&quot;Could not resolve type alias &#x27;&quot;</span> + string + <span class="string">&quot;&#x27;.  Cause: &quot;</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上源码为别名解析过程，其他别名的解析也是调用此方法，先去保存的别名中去找，是否有别名，如果没有就通过<code>Resources.classForName</code>生成实例。</p>
<h4 id="objectFactory，objectWrapperFactory，reflectorFactory-节点解析"><a href="#objectFactory，objectWrapperFactory，reflectorFactory-节点解析" class="headerlink" title="objectFactory，objectWrapperFactory，reflectorFactory 节点解析"></a>objectFactory，objectWrapperFactory，reflectorFactory 节点解析</h4><p>以上都是对实现类都是对MyBatis进行扩展。解析方法也类似，最后都是保存在<code>configuration</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objectFactory 解析</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">objectFactoryElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">      <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> context.getChildrenAsProperties();</span><br><span class="line">      <span class="type">ObjectFactory</span> <span class="variable">factory</span> <span class="operator">=</span> (ObjectFactory) resolveClass(type).newInstance();</span><br><span class="line">      factory.setProperties(properties);</span><br><span class="line">      configuration.setObjectFactory(factory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// objectWrapperFactory 解析</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">objectWrapperFactoryElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">      <span class="type">ObjectWrapperFactory</span> <span class="variable">factory</span> <span class="operator">=</span> (ObjectWrapperFactory) resolveClass(type).newInstance();</span><br><span class="line">      configuration.setObjectWrapperFactory(factory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reflectorFactory 解析</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reflectorFactoryElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">       <span class="type">ReflectorFactory</span> <span class="variable">factory</span> <span class="operator">=</span> (ReflectorFactory) resolveClass(type).newInstance();</span><br><span class="line">       configuration.setReflectorFactory(factory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上为解析<code>objectFactory，objectWrapperFactory，reflectorFactory</code>源码，经过前面的分析后，这里比较容易看懂。</p>
<h4 id="environments-节点解析"><a href="#environments-节点解析" class="headerlink" title="environments 节点解析"></a>environments 节点解析</h4><h5 id="environments配置方式"><a href="#environments配置方式" class="headerlink" title="environments配置方式"></a><code>environments</code>配置方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;environments <span class="keyword">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span><br><span class="line">    &lt;environment id=<span class="string">&quot;development&quot;</span>&gt;</span><br><span class="line">        &lt;!-- 事务管理 --&gt;</span><br><span class="line">        &lt;transactionManager type=<span class="string">&quot;JDBC&quot;</span>&gt;</span><br><span class="line">            &lt;property name=<span class="string">&quot;prop&quot;</span> value=<span class="string">&quot;100&quot;</span>/&gt;</span><br><span class="line">        &lt;/transactionManager&gt;</span><br><span class="line">        &lt;!-- 数据源 --&gt;</span><br><span class="line">        &lt;dataSource type=<span class="string">&quot;UNPOOLED&quot;</span>&gt;</span><br><span class="line">            &lt;!-- JDBC 驱动 --&gt;</span><br><span class="line">            &lt;property name=<span class="string">&quot;driver&quot;</span> value=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br><span class="line">            &lt;!-- 数据库的 url --&gt;</span><br><span class="line">            &lt;property name=<span class="string">&quot;url&quot;</span> value=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br><span class="line">            &lt;!-- 数据库登录名 --&gt;</span><br><span class="line">            &lt;property name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span><br><span class="line">            &lt;!-- 数据库登录密码 --&gt;</span><br><span class="line">            &lt;property name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br><span class="line">        &lt;/dataSource&gt;</span><br><span class="line">    &lt;/environment&gt;</span><br><span class="line">    &lt;!-- 一个环境，对应一个environment --&gt;</span><br><span class="line">    ......</span><br><span class="line">&lt;/environments&gt;</span><br></pre></td></tr></table></figure>
<p>该节点可设置多个环境，针对不同的环境单独配置。<code>environments</code>的属性<code>default</code>是默认环境，该值对应一个<code>environment</code>的属性<code>id</code>的值。</p>
<ul>
<li><code>transactionManager</code>为事务管理，属性<code>type</code>为事务管理类型，上面的介绍的<code>new Configuration()</code>有定义类型有：JDBC 和 MANAGED事务管理类型。</li>
<li><code>dataSource</code>是数据源，<code>type</code>为数据源类型，与<code>transactionManager</code>同理，可知内建的数据源类型有：JNDI，POOLED，UNPOOLED数据源类型。</li>
</ul>
<h5 id="environmentsElement-方法"><a href="#environmentsElement-方法" class="headerlink" title="environmentsElement()方法"></a><code>environmentsElement()</code>方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">environmentsElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (environment == <span class="literal">null</span>) &#123;</span><br><span class="line">        environment = context.getStringAttribute(<span class="string">&quot;default&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (XNode child : context.getChildren()) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="comment">// 验证 id</span></span><br><span class="line">        <span class="keyword">if</span> (isSpecifiedEnvironment(id)) &#123;</span><br><span class="line">          <span class="comment">// 解析 transactionManager， 并实例化 TransactionFactory</span></span><br><span class="line">          <span class="type">TransactionFactory</span> <span class="variable">txFactory</span> <span class="operator">=</span> transactionManagerElement(child.evalNode(<span class="string">&quot;transactionManager&quot;</span>));</span><br><span class="line">          <span class="comment">// 解析 dataSource，并实例化 DataSourceFactory</span></span><br><span class="line">          <span class="type">DataSourceFactory</span> <span class="variable">dsFactory</span> <span class="operator">=</span> dataSourceElement(child.evalNode(<span class="string">&quot;dataSource&quot;</span>));</span><br><span class="line">          <span class="comment">// 获取 dataSource</span></span><br><span class="line">          <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> dsFactory.getDataSource();</span><br><span class="line">          Environment.<span class="type">Builder</span> <span class="variable">environmentBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Environment</span>.Builder(id)</span><br><span class="line">              .transactionFactory(txFactory)</span><br><span class="line">              .dataSource(dataSource);</span><br><span class="line">          configuration.setEnvironment(environmentBuilder.build());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSpecifiedEnvironment</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (environment == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;No environment specified.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (id == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Environment requires an id attribute.&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (environment.equals(id)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若没有配置<code>environment</code>环境或环境没有给<code>id</code>属性，则会抛出异常，若当前<code>id</code>是要使用的就返回<code>true</code>，否则返回<code>false</code>。<br><code>TransactionFactory</code>实例化过程比较简单，与创建<code>DataSourceFactory</code>类似。</p>
<h5 id="数据源的获取"><a href="#数据源的获取" class="headerlink" title="数据源的获取"></a>数据源的获取</h5><p>获取数据源，首先得创建<code>DataSourceFactory</code>,上面使用<code>DataSourceFactory dsFactory = dataSourceElement(child.evalNode(&quot;dataSource&quot;))</code>创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> DataSourceFactory <span class="title function_">dataSourceElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">      <span class="type">Properties</span> <span class="variable">props</span> <span class="operator">=</span> context.getChildrenAsProperties();</span><br><span class="line">      <span class="type">DataSourceFactory</span> <span class="variable">factory</span> <span class="operator">=</span> (DataSourceFactory) resolveClass(type).newInstance();</span><br><span class="line">      factory.setProperties(props);</span><br><span class="line">      <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;Environment declaration requires a DataSourceFactory.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就是获取到数据源得<code>type</code>后，利用上面所讲到得<code>resolveClass()</code>方法获取到<code>DataSourceFactory</code>。<br>以<code>UNPOOLED</code>为例，对应的<code>DataSourceFactory</code>实现类为<code>UnpooledDataSourceFactory</code>。实例化过程中就给该类的属性<code>dataSource</code>数据源赋值了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UnpooledDataSourceFactory 类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UnpooledDataSourceFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.dataSource = <span class="keyword">new</span> <span class="title class_">UnpooledDataSource</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> dataSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>UnpooledDataSource</code>类里面有静态代码块所以数据源被加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UnpooledDataSource 类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Enumeration&lt;Driver&gt; drivers = DriverManager.getDrivers();</span><br><span class="line">    <span class="keyword">while</span> (drivers.hasMoreElements()) &#123;</span><br><span class="line">      <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> drivers.nextElement();</span><br><span class="line">      registeredDrivers.put(driver.getClass().getName(), driver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="databaseIdProvider-节点解析"><a href="#databaseIdProvider-节点解析" class="headerlink" title="databaseIdProvider 节点解析"></a>databaseIdProvider 节点解析</h4><h5 id="databaseIdProvider配置方式"><a href="#databaseIdProvider配置方式" class="headerlink" title="databaseIdProvider配置方式"></a><code>databaseIdProvider</code>配置方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;databaseIdProvider type=<span class="string">&quot;DB_VENDOR&quot;</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;SQL Server&quot;</span> value=<span class="string">&quot;sqlserver&quot;</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;DB2&quot;</span> value=<span class="string">&quot;db2&quot;</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;Oracle&quot;</span> value=<span class="string">&quot;oracle&quot;</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">&quot;MySQL&quot;</span> value=<span class="string">&quot;mysql&quot;</span>/&gt;</span><br><span class="line">&lt;/databaseIdProvider&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id=<span class="string">&quot;select&quot;</span> resultType=<span class="string">&quot;com.ytao.main.model.Student&quot;</span> databaseId=<span class="string">&quot;mysql&quot;</span>&gt;</span><br><span class="line">    select</span><br><span class="line">      *</span><br><span class="line">    from student</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p>基于映射语句中的<code>databaseId</code>属性，可以根据不同数据库厂商执行不同的sql。</p>
<h5 id="databaseIdProviderElement-方法"><a href="#databaseIdProviderElement-方法" class="headerlink" title="databaseIdProviderElement()方法"></a><code>databaseIdProviderElement()</code>方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">databaseIdProviderElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="type">DatabaseIdProvider</span> <span class="variable">databaseIdProvider</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (context != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> context.getStringAttribute(<span class="string">&quot;type&quot;</span>);</span><br><span class="line">    <span class="comment">// 保持向后兼容</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;VENDOR&quot;</span>.equals(type)) &#123;</span><br><span class="line">        type = <span class="string">&quot;DB_VENDOR&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> context.getChildrenAsProperties();</span><br><span class="line">    databaseIdProvider = (DatabaseIdProvider) resolveClass(type).newInstance();</span><br><span class="line">    databaseIdProvider.setProperties(properties);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">Environment</span> <span class="variable">environment</span> <span class="operator">=</span> configuration.getEnvironment();</span><br><span class="line">  <span class="keyword">if</span> (environment != <span class="literal">null</span> &amp;&amp; databaseIdProvider != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">databaseId</span> <span class="operator">=</span> databaseIdProvider.getDatabaseId(environment.getDataSource());</span><br><span class="line">    configuration.setDatabaseId(databaseId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据匹配的数据库厂商类型匹配数据源<code>databaseIdProvider.getDatabaseId(environment.getDataSource())</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getDatabaseId</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (dataSource == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;dataSource cannot be null&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getDatabaseName(dataSource);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;Could not get a databaseId from dataSource&quot;</span>, e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getDatabaseName</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="comment">// 根据数据源获取数据库产品名称</span></span><br><span class="line">  <span class="type">String</span> <span class="variable">productName</span> <span class="operator">=</span> getDatabaseProductName(dataSource);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.properties != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; property : properties.entrySet()) &#123;</span><br><span class="line">      <span class="comment">// 判断是否包含，选择使用的数据库产品</span></span><br><span class="line">      <span class="keyword">if</span> (productName.contains((String) property.getKey())) &#123;</span><br><span class="line">        <span class="keyword">return</span> (String) property.getValue();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// no match, return null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> productName;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">getDatabaseProductName</span><span class="params">(DataSource dataSource)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">  <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 数据库连接</span></span><br><span class="line">    con = dataSource.getConnection();</span><br><span class="line">    <span class="comment">// 获取连接元数据</span></span><br><span class="line">    <span class="type">DatabaseMetaData</span> <span class="variable">metaData</span> <span class="operator">=</span> con.getMetaData();</span><br><span class="line">    <span class="comment">// 获取数据库产品名称</span></span><br><span class="line">    <span class="keyword">return</span> metaData.getDatabaseProductName();</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (con != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        con.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">// ignored</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<p>这里需要注意的是配置：比如使用<code>mysql</code>,我踩过这里的坑，这里Name为<code>MySQL</code>,我把<code>y</code>写成大写，结果匹配不上。<br>另外这里写个<code>My</code>也能匹配上，应为是使用的<code>String.contains</code>方法，只要包含就会符合，这里代码应该不够严谨。</p>
<h4 id="typeHandlers-节点解析"><a href="#typeHandlers-节点解析" class="headerlink" title="typeHandlers 节点解析"></a>typeHandlers 节点解析</h4><h5 id="typeHandlers配置方式"><a href="#typeHandlers配置方式" class="headerlink" title="typeHandlers配置方式"></a><code>typeHandlers</code>配置方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;typeHandlers&gt;</span><br><span class="line">    &lt;<span class="keyword">package</span> name=<span class="string">&quot;com.ytao.main.handler&quot;</span>/&gt;</span><br><span class="line">    <span class="comment">// 或</span></span><br><span class="line">    &lt;typeHandler javaType=<span class="string">&quot;java.util.Date&quot;</span>  jdbcType=<span class="string">&quot;TIMESTAMP&quot;</span> handler=<span class="string">&quot;com.ytao.main.handler.DemoDateHandler&quot;</span> /&gt;</span><br><span class="line">&lt;/typeHandlers&gt;</span><br></pre></td></tr></table></figure>
<p>扫描整个包或者指定类型之间的映射，<code>javaType</code>, <code>jdbcType</code>非必需，<code>handler</code>必填项</p>
<h5 id="typeHandlerElement-方法"><a href="#typeHandlerElement-方法" class="headerlink" title="typeHandlerElement()方法"></a><code>typeHandlerElement()</code>方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">typeHandlerElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">        <span class="comment">// 获取包名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">typeHandlerPackage</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// 注册包下所有的类型处理器</span></span><br><span class="line">        typeHandlerRegistry.register(typeHandlerPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">javaTypeName</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;javaType&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">jdbcTypeName</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;jdbcType&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">handlerTypeName</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;handler&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; javaTypeClass = resolveClass(javaTypeName);</span><br><span class="line">        <span class="type">JdbcType</span> <span class="variable">jdbcType</span> <span class="operator">=</span> resolveJdbcType(jdbcTypeName);</span><br><span class="line">        Class&lt;?&gt; typeHandlerClass = resolveClass(handlerTypeName);</span><br><span class="line">        <span class="keyword">if</span> (javaTypeClass != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (jdbcType == <span class="literal">null</span>) &#123;</span><br><span class="line">            typeHandlerRegistry.register(javaTypeClass, typeHandlerClass);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          typeHandlerRegistry.register(typeHandlerClass);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>源码分析会根据包下所有处理器或者指定处理器进行解析，最后会根据上面分析到的<code>type + handler</code>和<code>type + jdbc type + handler</code>不同情况注册。<br>另外这里还有个<code>TypeHandlerRegistry.register(Class&lt;?&gt; typeHandlerClass)</code>注册类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(Class&lt;?&gt; typeHandlerClass)</span> &#123;</span><br><span class="line">  <span class="comment">// 标志是否从 MappedTypes 注解中获取 javaType 注册</span></span><br><span class="line">  <span class="type">boolean</span> <span class="variable">mappedTypeFound</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="comment">// 获取 MappedTypes 的值</span></span><br><span class="line">  <span class="type">MappedTypes</span> <span class="variable">mappedTypes</span> <span class="operator">=</span> typeHandlerClass.getAnnotation(MappedTypes.class);</span><br><span class="line">  <span class="keyword">if</span> (mappedTypes != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; javaTypeClass : mappedTypes.value()) &#123;</span><br><span class="line">      <span class="comment">// 已 type + handler 的方式注册</span></span><br><span class="line">      register(javaTypeClass, typeHandlerClass);</span><br><span class="line">      <span class="comment">// 标志已通过注解注册类型</span></span><br><span class="line">      mappedTypeFound = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!mappedTypeFound) &#123;</span><br><span class="line">    <span class="comment">// 通过 TypeHandler 注册</span></span><br><span class="line">    register(getInstance(<span class="literal">null</span>, typeHandlerClass));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; TypeHandler&lt;T&gt; <span class="title function_">getInstance</span><span class="params">(Class&lt;?&gt; javaTypeClass, Class&lt;?&gt; typeHandlerClass)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (javaTypeClass != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 获取有参构造函数</span></span><br><span class="line">      Constructor&lt;?&gt; c = typeHandlerClass.getConstructor(Class.class);</span><br><span class="line">      <span class="comment">// 实例化对象</span></span><br><span class="line">      <span class="keyword">return</span> (TypeHandler&lt;T&gt;) c.newInstance(javaTypeClass);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ignored) &#123;</span><br><span class="line">      <span class="comment">// ignored</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeException</span>(<span class="string">&quot;Failed invoking constructor for handler &quot;</span> + typeHandlerClass, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 获取无参构造函数</span></span><br><span class="line">    Constructor&lt;?&gt; c = typeHandlerClass.getConstructor();</span><br><span class="line">    <span class="keyword">return</span> (TypeHandler&lt;T&gt;) c.newInstance();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeException</span>(<span class="string">&quot;Unable to find a usable constructor for &quot;</span> + typeHandlerClass, e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册实例</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(TypeHandler&lt;T&gt; typeHandler)</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> <span class="variable">mappedTypeFound</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="type">MappedTypes</span> <span class="variable">mappedTypes</span> <span class="operator">=</span> typeHandler.getClass().getAnnotation(MappedTypes.class);</span><br><span class="line">  <span class="keyword">if</span> (mappedTypes != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; handledType : mappedTypes.value()) &#123;</span><br><span class="line">      register(handledType, typeHandler);</span><br><span class="line">      mappedTypeFound = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// @since 3.1.0 - try to auto-discover the mapped type</span></span><br><span class="line">  <span class="keyword">if</span> (!mappedTypeFound &amp;&amp; typeHandler <span class="keyword">instanceof</span> TypeReference) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TypeReference&lt;T&gt; typeReference = (TypeReference&lt;T&gt;) typeHandler;</span><br><span class="line">      register(typeReference.getRawType(), typeHandler);</span><br><span class="line">      mappedTypeFound = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="comment">// maybe users define the TypeReference with a different type and are not assignable, so just ignore it</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!mappedTypeFound) &#123;</span><br><span class="line">    register((Class&lt;T&gt;) <span class="literal">null</span>, typeHandler);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>以上的<code>register</code>方法中，了解<code>type + jdbc type + handler</code>后，其他的<code>register</code>重载方法比较容易理解，其他的都是基于它上面的封装。</p>
<h4 id="mappers-节点解析"><a href="#mappers-节点解析" class="headerlink" title="mappers 节点解析"></a>mappers 节点解析</h4><h5 id="mappers配置方式"><a href="#mappers配置方式" class="headerlink" title="mappers配置方式"></a><code>mappers</code>配置方式</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">    &lt;<span class="keyword">package</span> name=<span class="string">&quot;com.ytao.main.mapper&quot;</span>/&gt;</span><br><span class="line">    <span class="comment">// 或</span></span><br><span class="line">    &lt;mapper resource=<span class="string">&quot;mapper/studentMapper.xml&quot;</span>/&gt;</span><br><span class="line">    <span class="comment">// 或</span></span><br><span class="line">    &lt;mapper url=<span class="string">&quot;file:///D:/mybatis-3-mybatis-3.4.6/src/main/resources/mapper/studentMapper.xml&quot;</span>/&gt;</span><br><span class="line">    <span class="comment">// 或</span></span><br><span class="line">    &lt;mapper class=<span class="string">&quot;com.ytao.main.mapper.StudentMapper&quot;</span>/&gt;</span><br><span class="line">&lt;/mappers&gt;</span><br></pre></td></tr></table></figure>
<p>可通过以上四种形式配置<code>mappers</code>节点,<code>&lt;package&gt;</code>和<code>&lt;mapper&gt;</code>为互斥节点。</p>
<h5 id="mapperElement-方法"><a href="#mapperElement-方法" class="headerlink" title="mapperElement()方法"></a><code>mapperElement()</code>方法</h5><p>该方法是负责解析<code>&lt;mappers&gt;</code>节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="comment">// 如果配置 package 节点，则扫描</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">&quot;package&quot;</span>.equals(child.getName())) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapperPackage</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">// 解析包下类Mapper接口，并注册到configuration的mapperRegistry中</span></span><br><span class="line">        configuration.addMappers(mapperPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取mapper节点的resource,url,class属性</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;resource&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">mapperClass</span> <span class="operator">=</span> child.getStringAttribute(<span class="string">&quot;class&quot;</span>);</span><br><span class="line">        <span class="comment">// 根据resource解析，并且url，class值必须为空，也就不能配置值。url，class同理，其它两个属性也不能配置值</span></span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="literal">null</span> &amp;&amp; url == <span class="literal">null</span> &amp;&amp; mapperClass == <span class="literal">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(resource);</span><br><span class="line">          <span class="comment">// 通过resource获取流</span></span><br><span class="line">          <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line">          <span class="comment">// 创建XMLMapperBuilder对象</span></span><br><span class="line">          <span class="type">XMLMapperBuilder</span> <span class="variable">mapperParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">          <span class="comment">// 解析映射配置文件</span></span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="literal">null</span> &amp;&amp; url != <span class="literal">null</span> &amp;&amp; mapperClass == <span class="literal">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(url);</span><br><span class="line">          <span class="comment">// 通过url获取流</span></span><br><span class="line">          <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getUrlAsStream(url);</span><br><span class="line">          <span class="comment">// 和resource解析方式一样，创建XMLMapperBuilder对象，然后解析映射配置文件</span></span><br><span class="line">          <span class="type">XMLMapperBuilder</span> <span class="variable">mapperParser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XMLMapperBuilder</span>(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="literal">null</span> &amp;&amp; url == <span class="literal">null</span> &amp;&amp; mapperClass != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 加载class属性的接口</span></span><br><span class="line">          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">          <span class="comment">// 将接口注册到configuration的mapperRegistry中</span></span><br><span class="line">          configuration.addMapper(mapperInterface);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BuilderException</span>(<span class="string">&quot;A mapper element may only specify a url, resource or class, but not more than one.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;package&gt;</code>的包扫描到的类，然后单个单个注册到configuration的mapperRegistry中，这里和<code>&lt;mapper&gt;</code>使用<code>class</code>属性是一样逻辑。<br>解析<code>package</code>方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Configuration 中定义了</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">MapperRegistry</span> <span class="variable">mapperRegistry</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperRegistry</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤一</span></span><br><span class="line"><span class="comment"> * 该函数于 Configuration 中  </span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMappers</span><span class="params">(String packageName)</span> &#123;</span><br><span class="line">  <span class="comment">// mapperRegistry定义在Configuration中的一个属性</span></span><br><span class="line">  mapperRegistry.addMappers(packageName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤二</span></span><br><span class="line"><span class="comment"> * 该函数于 MapperRegistry 中  </span></span><br><span class="line"><span class="comment"> */</span>   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMappers</span><span class="params">(String packageName)</span> &#123;</span><br><span class="line">  addMappers(packageName, Object.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤三</span></span><br><span class="line"><span class="comment"> * 该函数于 MapperRegistry 中  </span></span><br><span class="line"><span class="comment"> */</span>       </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMappers</span><span class="params">(String packageName, Class&lt;?&gt; superType)</span> &#123;</span><br><span class="line">  <span class="comment">// 通过 ResolverUtil 获取包下的类</span></span><br><span class="line">  ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = <span class="keyword">new</span> <span class="title class_">ResolverUtil</span>&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">  resolverUtil.find(<span class="keyword">new</span> <span class="title class_">ResolverUtil</span>.IsA(superType), packageName);</span><br><span class="line">  Set&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Class</span>&lt;?&gt;&gt;&gt; mapperSet = resolverUtil.getClasses();</span><br><span class="line">  <span class="keyword">for</span> (Class&lt;?&gt; mapperClass : mapperSet) &#123;</span><br><span class="line">    <span class="comment">// 遍历获取到的类，注册到 MapperRegistry</span></span><br><span class="line">    addMapper(mapperClass);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;   </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤四</span></span><br><span class="line"><span class="comment"> * 该函数于 MapperRegistry 中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">  <span class="comment">// mapper 类为 interface 接口</span></span><br><span class="line">  <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">    <span class="comment">// 判断当前class是否已经注册过</span></span><br><span class="line">    <span class="keyword">if</span> (hasMapper(type)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BindingException</span>(<span class="string">&quot;Type &quot;</span> + type + <span class="string">&quot; is already known to the MapperRegistry.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 校验是否加载完成</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">loadCompleted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 保存 mapper 接口和 MapperProxyFactory 之间的映射</span></span><br><span class="line">      knownMappers.put(type, <span class="keyword">new</span> <span class="title class_">MapperProxyFactory</span>&lt;T&gt;(type));</span><br><span class="line">      <span class="comment">// It&#x27;s important that the type is added before the parser is run</span></span><br><span class="line">      <span class="comment">// otherwise the binding may automatically be attempted by the</span></span><br><span class="line">      <span class="comment">// mapper parser. If the type is already known, it won&#x27;t try.</span></span><br><span class="line">      <span class="comment">// 解析xml和注解</span></span><br><span class="line">      <span class="type">MapperAnnotationBuilder</span> <span class="variable">parser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperAnnotationBuilder</span>(config, type);</span><br><span class="line">      parser.parse();</span><br><span class="line">      <span class="comment">// 标志加载完成</span></span><br><span class="line">      loadCompleted = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">        knownMappers.remove(type);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>解析<code>mapper</code>的<code>class</code>属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该函数于 Configuration 中  </span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">  mapperRegistry.addMapper(type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... 这里调用上面的【步骤四】</span></span><br></pre></td></tr></table></figure>
<p>这两中方式是直接注册接口到<code>mapperRegistry</code>,另外两种是解析<code>xml</code>的方式就是获取映射文件的<code>namespace</code>，再注册进来,<code>XMLMapperBuilder</code>是负责解析映射配置文件的类，今后会单独详细分析这个类，这里不展开讲。</p>
<blockquote>
<p>这里对XMLConfigBuilder解析配置文件到此分析完，本文对配置文件解析的流程大致了解流程和原理。相信遇到配置问题异常，大致能排查到根本原因。</p>
</blockquote>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>synchronized 原理知多少</title>
    <url>/2020/06/27/28-synchronized/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/20200627225959.jpg"></p>
<p><code>synchronized</code>是 Java 编程中的一个重要的关键字，也是多线程编程中不可或缺的一员。本文就对它的使用和锁的一些重要概念进行分析。</p>
<h1 id="使用及原理"><a href="#使用及原理" class="headerlink" title="使用及原理"></a>使用及原理</h1><p>synchronized 是一个重量级锁，它主要实现同步操作，在 Java 对象锁中有三种使用方式：</p>
<ul>
<li>普通方法中使用，锁是当前实例对象。</li>
<li>静态方法中使用，锁是当前类的对象。</li>
<li>代码块中使用，锁是代码代码块中配置的对象。</li>
</ul>
<span id="more"></span>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在代码中使用方法分别如下：</p>
<p>普通方法使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公众号：ytao</span></span><br><span class="line"><span class="comment"> * 博客：https://ytao.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedMethodDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态方法使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公众号：ytao</span></span><br><span class="line"><span class="comment"> * 博客：https://ytao.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedMethodDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码块中使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公众号：ytao</span></span><br><span class="line"><span class="comment"> * 博客：https://ytao.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedDemo.class)&#123;</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>方法和代码块的实现原理使用不同方式：</p>
<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>每个对象都拥有一个<code>monitor</code>对象，代码块的<code>&#123;&#125;</code>中会插入<code>monitorenter</code>和<code>monitorexit</code>指令。当执行<code>monitorenter</code>指令时，会进入<code>monitor</code>对象获取锁，当执行<code>monitorexit</code>命令时，会退出<code>monitor</code>对象释放锁。同一时刻，只能有一个线程进入在<code>monitorenter</code>中。</p>
<p>先将<code>SynchronizedDemo.java</code>使用<code>javac SynchronizedDemo.java</code>命令将其编译成<code>SynchronizedDemo.class</code>。然后使用<code>javap -c SynchronizedDemo.class</code>反编译字节码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;SynchronizedDemo.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SynchronizedDemo</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// class SynchronizedDemo</span></span><br><span class="line">       <span class="number">2</span>: dup</span><br><span class="line">       <span class="number">3</span>: astore_1</span><br><span class="line">       <span class="number">4</span>: monitorenter  <span class="comment">// 进入 monitor</span></span><br><span class="line">       <span class="number">5</span>: aload_1</span><br><span class="line">       <span class="number">6</span>: monitorexit  <span class="comment">// 退出 monitor</span></span><br><span class="line">       <span class="number">7</span>: goto          <span class="number">15</span></span><br><span class="line">      <span class="number">10</span>: astore_2</span><br><span class="line">      <span class="number">11</span>: aload_1</span><br><span class="line">      <span class="number">12</span>: monitorexit  <span class="comment">// 退出 monitor</span></span><br><span class="line">      <span class="number">13</span>: aload_2</span><br><span class="line">      <span class="number">14</span>: athrow</span><br><span class="line">      <span class="number">15</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">5</span>     <span class="number">7</span>    <span class="number">10</span>   any</span><br><span class="line">          <span class="number">10</span>    <span class="number">13</span>    <span class="number">10</span>   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面反编码后的代码，有两个<code>monitorexit</code>指令，一个插入在异常位置，一个插入在方法结束位置。</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法中的<code>synchronized</code>与代码块中实现的方式不同，方法中会添加一个叫<code>ACC_SYNCHRONIZED</code>的标志，当调用方法时，首先会检查是否有<code>ACC_SYNCHRONIZED</code>标志，如果存在，则获取<code>monitor</code>对象，调用<code>monitorenter</code>和<code>monitorexit</code>指令。</p>
<p>通过<code>javap -v -c SynchronizedMethodDemo.class</code>命令反编译<code>SynchronizedMethodDemo</code>类。<code>-v</code>参数即<code>-verbose</code>，表示输出反编译的附加信息。下面以反编译普通方法为例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Classfile /E:/SynchronizedMethodDemo.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2020</span>-<span class="number">6</span>-<span class="number">28</span>; size <span class="number">381</span> bytes</span><br><span class="line">  MD5 checksum 55ca2bbd9b6939bbd515c3ad9e59d10c</span><br><span class="line">  Compiled from <span class="string">&quot;SynchronizedMethodDemo.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedMethodDemo</span></span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">5.</span>#<span class="number">13</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">14.</span>#<span class="number">15</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">3</span> = Methodref          #<span class="number">16.</span>#<span class="number">17</span>        <span class="comment">// java/io/PrintStream.println:()V</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">18</span>            <span class="comment">// SynchronizedMethodDemo</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">19</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">6</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">7</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">8</span> = Utf8               Code</span><br><span class="line">   #<span class="number">9</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">10</span> = Utf8               demo</span><br><span class="line">  #<span class="number">11</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">12</span> = Utf8               SynchronizedMethodDemo.java</span><br><span class="line">  #<span class="number">13</span> = NameAndType        #<span class="number">6</span>:#<span class="number">7</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">14</span> = Class              #<span class="number">20</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">15</span> = NameAndType        #<span class="number">21</span>:#<span class="number">22</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">16</span> = Class              #<span class="number">23</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">17</span> = NameAndType        #<span class="number">24</span>:#<span class="number">7</span>         <span class="comment">// println:()V</span></span><br><span class="line">  #<span class="number">18</span> = Utf8               SynchronizedMethodDemo</span><br><span class="line">  #<span class="number">19</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">20</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">21</span> = Utf8               out</span><br><span class="line">  #<span class="number">22</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">23</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">24</span> = Utf8               println</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SynchronizedMethodDemo</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED     <span class="comment">// ACC_SYNCHRONIZED 标志</span></span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/io/PrintStream.println:()V</span></span><br><span class="line">         <span class="number">6</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;SynchronizedMethodDemo.java&quot;</span></span><br></pre></td></tr></table></figure>

<p>上面对代码块和方法的实现方式进行探究：</p>
<ul>
<li>代码块通过在编译后的代码中添加<code>monitorenter</code>和<code>monitorexit</code>指令。</li>
<li>方法中通过添加<code>ACC_SYNCHRONIZED</code>标志，来决定是否调用<code>monitor</code>对象。</li>
</ul>
<h1 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h1><p><code>synchronized</code>锁的相关数据存放在 Java 对象头中。Java 对象头指的 HotSpot 虚拟机的对象头，使用2个字宽或3个字宽存储对象头。</p>
<ul>
<li>第一部分存储运行时的数据，hashCode、锁标记位、是否偏向锁、GC分代年龄等等信息，称作为<code>Mark Word</code>。</li>
<li>第二部分存储对象类型数据的指针。</li>
<li>第三部分，如果对象是数组的话，则用这部分来存储数组长度。</li>
</ul>
<p>Java 对象头 Mark Word 存储内容：</p>
<table>
<thead>
<tr>
<th align="center">存储内容</th>
<th align="center">标志位</th>
<th align="center">状态</th>
</tr>
</thead>
<tbody><tr>
<td align="center">对象的hashCode、GC分代年龄</td>
<td align="center">01</td>
<td align="center">无锁</td>
</tr>
<tr>
<td align="center">指向栈中锁记录的指针</td>
<td align="center">00</td>
<td align="center">轻量级锁</td>
</tr>
<tr>
<td align="center">指向重量级锁的指针</td>
<td align="center">10</td>
<td align="center">重量级锁</td>
</tr>
<tr>
<td align="center">空</td>
<td align="center">11</td>
<td align="center">GC标记</td>
</tr>
<tr>
<td align="center">线程ID、Epoch（一个时间戳）、GC分代年龄</td>
<td align="center">01</td>
<td align="center">偏向锁</td>
</tr>
</tbody></table>
<h1 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h1><p>synchronized 称为重量级锁，但 Java SE 1.6 为优化该锁的性能而减少获取和释放锁的性能消耗，引入<code>偏向锁</code>和<code>轻量级锁</code>。</p>
<p>锁的高低级别为：<code>无锁</code>→<code>偏向锁</code>→<code>轻量级锁</code>→<code>重量级锁</code>。</p>
<p>其中锁的升级是不可逆的，只能由低往高级别升，不能由高往低降。</p>
<h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁是优化在无多线程竞争情况下，提高程序的的运行性能而使用到的锁。在<code>Mark Word</code>中存储一个值，用来标志是否为偏向锁，在 32 位虚拟机和 64 位虚拟机中都是使用一个字节存储，0 为非偏向锁，1 为是偏向锁。</p>
<p>当第一次被线程获取偏向锁时，会将<code>Mark Word</code>中的偏向锁标志设置为 1，同时使用 CAS 操作来记录这个线程的ID。获取到偏向锁的线程，再次进入获取锁时，只需判断<code>Mark Word</code>是否存储着当前线程ID，如果是，则不需再次进行获取锁操作，而是直接持有该锁。</p>
<h3 id="撤销锁"><a href="#撤销锁" class="headerlink" title="撤销锁"></a>撤销锁</h3><p>如果有其他线程出现，尝试获取偏向锁，让偏向锁处于竞争状态，那么当前偏向锁就会撤销。<br>撤销偏向锁时，首先会暂停持有偏向锁的线程，并将线程ID设为空，然后检查该线程是否存活：</p>
<ul>
<li>当暂停线程非存活，则设置对象头为无锁状态。</li>
<li>当暂停线程存活，执行偏向锁的栈，最后对象头的保存其他获取到偏向锁的线程ID或者转向无锁状态。</li>
</ul>
<p><strong>当确定代码一定执行在多线程访问中时，那么这时的偏向锁是无法发挥到优势，如果继续使用偏向锁就显得过于累赘，给系统带来不必要的性能开销，此时可以设置 JVM 参数<code>-XX:BiasedLocking=false</code>来关闭偏向锁。</strong></p>
<h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>代码进入同步块的时候，如果对象头不是锁定状态，JVM 则会在当前线程的栈桢中创建一个<code>锁记录</code>的空间，将锁对象头的<code>Mark Word</code>复制一份到<code>锁记录</code>中，这份复制过来的<code>Mark Word</code>叫做<code>Displaced Mark Word</code>。然后使用 CAS 操作将锁对象头中的<code>Mark Word</code>更新为指向<code>锁记录</code>的指针。如果更新成功，当前线程则会获得锁，如果失败，JVM 先检查锁对象的<code>Mark Word</code>是否指向当前线程，是指向当前线程的话，则当前线程已持有锁，否则存在多线程竞争，当前线程会通过自旋获取锁，这里的自旋可以理解为循环尝试获取锁，所以这过程是消耗 CPU 的过程。当轻量级锁存在竞争状态并自旋获取轻量级锁失败时，轻量级锁就会膨胀为重量级锁，锁对象的<code>Mark Word</code>会更新为指向重量级锁的指针，等待获取锁的线程进入阻塞状态。</p>
<h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>轻量级锁解锁是使用 CAS 操作将<code>锁记录</code>替换到<code>Mark Word</code>中，如果替换成功，则表示同步操作已完成。如果失败，则表示其他竞争线程尝试过获取该轻量级锁，需要在释放锁的同时，去唤醒其他被阻塞的线程，被唤醒的线程回去再次去竞争锁。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>通过分析<code>synchronized</code>的使用以及 Java SE 1.6 升级优化锁后的设计，可以看出其主要是解决是通过多加入两级相对更轻巧的偏向锁和轻量级锁来优化重量级锁的性能消耗，但是这并不是一定会起到优化作用，主要是解决大多数情况下不存在多线程竞争以及同一线程多次获取锁的的优化，这也是根据平时在编码中多观察多反思得出的权衡方案。</p>
</blockquote>
<p><strong>推荐阅读</strong></p>
<p><a href="https://ytao.top/2020/03/15/18-volatile/">《volatile 手摸手带你解析》</a></p>
<p><a href="https://ytao.top/2020/05/12/24-thread-wait-notify/">《Java 线程通信之 wait&#x2F;notify 机制》</a></p>
<p><a href="https://ytao.top/2020/05/17/25-thread-count/">《Java 多线程中使用 JDK 自带工具类实现计数器》</a></p>
<p><a href="https://ytao.top/2020/04/19/22-thread-base/">《Java 线程基础，从这篇开始》</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉查找树的解读和实现</title>
    <url>/2019/11/03/5_bst/</url>
    <content><![CDATA[<p><img src="https://yangtao.ytao.top/BST.png" alt="BST"></p>
<blockquote>
<p> 二叉查找树是将一组无序的数据构建成一颗有序数据的树，其设计思想与二分法类似。很好的提高了海量数据查找效率，使得由从头遍历到尾的方式转为二分查找的方式，时间复杂度从O(n)降低为O(log(n))。</p>
</blockquote>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><ol>
<li>结点：树上的每个元素。</li>
<li>根结点：没有父结点的结点。<span id="more"></span></li>
<li>父结点：结点的上一级结点。</li>
<li>子结点：结点的下一级结点。</li>
<li>叶子结点：没有子结点的结点。</li>
<li>兄弟结点：拥有同一父结点的相邻结点。</li>
<li>结点的度：一个结点中拥有子结点的个数。</li>
<li>树的度：树上最大结点的度。</li>
<li>结点的层次：以根结点为1，每深入一个子结点层次加1。</li>
<li>树的高度：树中最大的结点的层次。</li>
</ol>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ol>
<li>左子树所有的结点值均小于，等于根结点值或为空。</li>
<li>左子树所有的结点值均大于，等于根结点值或为空。</li>
<li>左、右子树也分别为二叉排序树。</li>
<li>没有键值相等的结点。</li>
</ol>
<h1 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h1><p>构建二叉查找树，主要把握几条原则，小于当前结点的在左边，大于的在右边，相等的不予处理。但是情况下结合实际业务需求，也可在相等时放在左结点或右结点，但是必须统一规则，不能左右都存在相等的。<br>创建结点对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytao.bst;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YANGTAO on 2019/11/3 0003.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node leftChildren;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node rightChildren;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(Integer value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getLeftChildren</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> leftChildren;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLeftChildren</span><span class="params">(Node leftChildren)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.leftChildren = leftChildren;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">getRightChildren</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightChildren;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRightChildren</span><span class="params">(Node rightChildren)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.rightChildren = rightChildren;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Integer value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建树的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytao.bst;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YANGTAO on 2019/11/3 0003.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuildBST</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">rootNode</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] vals)</span>&#123;</span><br><span class="line">        <span class="comment">// 遍历所有数据，每次都需从根结点开始寻找左或右子节点为空的位置添加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : vals) &#123;</span><br><span class="line">            <span class="built_in">this</span>.assemble(rootNode, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> rootNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">assemble</span><span class="params">(Node node, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="comment">// 创建根结点</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)&#123;</span><br><span class="line">            rootNode = <span class="keyword">new</span> <span class="title class_">Node</span>(val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">// 根据左小右大特性判断</span></span><br><span class="line">            <span class="keyword">if</span> (val &lt; node.getValue())&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> node.getLeftChildren();</span><br><span class="line">                <span class="comment">// 如果左子结点为空，就添加为当前结点的左结点，否则继续递归下去</span></span><br><span class="line">                <span class="keyword">if</span> (leftNode == <span class="literal">null</span>)&#123;</span><br><span class="line">                    node.setLeftChildren(<span class="keyword">new</span> <span class="title class_">Node</span>(val));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.assemble(node.getLeftChildren(), val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> node.getRightChildren();</span><br><span class="line">                <span class="comment">// 如果右子结点为空，就添加为当前结点的右结点，否则继续递归下去</span></span><br><span class="line">                <span class="keyword">if</span> (rightNode == <span class="literal">null</span>)&#123;</span><br><span class="line">                    node.setRightChildren(<span class="keyword">new</span> <span class="title class_">Node</span>(val));</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="built_in">this</span>.assemble(rightNode, val);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>[7,5,9,2,11,6]</code>测试是否满足我们创建树的要求：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] vals = &#123;<span class="number">7</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">11</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BuildBST</span>().build(vals);</span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(node));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果满足我们要求</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;value&quot;</span>: 7,</span><br><span class="line">    <span class="string">&quot;leftChildren&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: 5,</span><br><span class="line">        <span class="string">&quot;leftChildren&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;value&quot;</span>: 2</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;rightChildren&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;value&quot;</span>: 6</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;rightChildren&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: 9,</span><br><span class="line">        <span class="string">&quot;rightChildren&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;value&quot;</span>: 11</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>假设从一百万个数字中获取值为88的数据，如果我们使用遍历的方式，最糟的情况就是排在第一百万个位置的时候，需要我们遍历一百万次才能获取到数据，这就是我们最不想遇到的情况。这时将一百万个数据构建成二叉查找树，我们就可通过树快速找到我们想要的数据。<br>由于设定一百万个数据比较多，这里我们举例当前拥有数据<code>[7,5,9,2,11,6]</code>,我们要找出其中的<code>6</code>。<br>使用循环遍历所有数据的方法，我们需要6次遍历 7-&gt;5-&gt;9-&gt;2-&gt;11-&gt;6。<br>使用二叉查找树查找时，首先构建好的二叉查找树的结构如图：</p>
<p><img src="https://images.ytao.top/%E6%9E%84%E5%BB%BAbst.png" alt="构建二叉查找树"><br>从根结点开始查找；</p>
<p><img src="https://images.ytao.top/%E6%9F%A5%E6%89%BEbst1.png" alt="查找根结点"><br>获取根结点7，不等于6，且6&lt;7，所以继续找左子结点；</p>
<p><img src="https://images.ytao.top/%E6%9F%A5%E6%89%BEbst2.png" alt="查找子结点"><br>获取到结点5，不等于6，且6&gt;5，所以继续找右子节点；</p>
<p><img src="https://images.ytao.top/%E6%9F%A5%E6%89%BEbst3.png" alt="查找子结点"><br>最终获取到结点6，满足我们需要的条件。所遍历的数据为 7-&gt;5-&gt;6。<br>代码实现查找：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytao.bst;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YANGTAO on 2019/11/3 0003.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SearchBST</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">search</span><span class="params">(Node node, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="comment">// 如果结点为空，说明是没有了符合的结点</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">nodeVal</span> <span class="operator">=</span> node.getValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果结点上的键值相等，就是我们需要找的结点</span></span><br><span class="line">        <span class="keyword">if</span> (val == nodeVal)&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (val &lt; nodeVal)&#123; <span class="comment">// 如果小于结点的值，那么一定在结点的左子树中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.search(node.getLeftChildren(), val);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.search(node.getRightChildren(), val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h1><p>二叉查找树的插入规则，必须是要插入后的结点是作为叶子结点。现在向上面的树中插入10，根据上面所分析到的规则，为确保二叉查找树的完整性，最终的插入流程为7-&gt;9-&gt;11-&gt;10：</p>
<p><img src="https://images.ytao.top/%E6%8F%92%E5%85%A5%E7%BB%93%E7%82%B9.png" alt="插入10的结点"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytao.bst;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YANGTAO on 2019/11/3 0003.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InsertBST</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inesrt</span><span class="params">(Node node, <span class="type">int</span> newVal)</span>&#123;</span><br><span class="line">        <span class="comment">// 当结点为空是，说明是作为根结点</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)&#123;</span><br><span class="line">            node = <span class="keyword">new</span> <span class="title class_">Node</span>(newVal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">nodeVal</span> <span class="operator">=</span> node.getValue();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果小于结点的值，插入到左子树中，大于就插入右子树中</span></span><br><span class="line">        <span class="keyword">if</span> (newVal &lt; nodeVal)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> node.getLeftChildren();</span><br><span class="line">            <span class="comment">// 为空时，说明为叶子结点，可插入</span></span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="literal">null</span>)&#123;</span><br><span class="line">                node.setLeftChildren(<span class="keyword">new</span> <span class="title class_">Node</span>(newVal));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.inesrt(leftNode, newVal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (newVal &gt; nodeVal)&#123;</span><br><span class="line">            <span class="type">Node</span>  <span class="variable">rightNode</span> <span class="operator">=</span> node.getRightChildren();</span><br><span class="line">            <span class="keyword">if</span> (rightNode == <span class="literal">null</span>)&#123;</span><br><span class="line">                node.setRightChildren(<span class="keyword">new</span> <span class="title class_">Node</span>(newVal));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.inesrt(rightNode, newVal);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// todo 相等时，可根据具体业务处理，放弃，或在左右树中选择一个</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h1><p>删除结点分为多种情况，其中主要分析的：</p>
<h2 id="叶子结点"><a href="#叶子结点" class="headerlink" title="叶子结点"></a>叶子结点</h2><p>删除叶子结点，将所要删除的叶子结点直接删除便可，比如删除结点6。</p>
<p><img src="https://images.ytao.top/%E5%88%A0%E9%99%A4%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9.png" alt="删除叶子结点"></p>
<h2 id="单子结点的结点"><a href="#单子结点的结点" class="headerlink" title="单子结点的结点"></a>单子结点的结点</h2><p>被删除结点，如果只有一个子结点，那么被删除结点删除后，该结点的子结点补上其位置，比如删除结点9。</p>
<p><img src="https://images.ytao.top/%E5%88%A0%E9%99%A4%E5%8D%95%E5%AD%90%E8%8A%82%E7%82%B9%E7%9A%84%E7%BB%93%E7%82%B9.png" alt="删除单子结点的结点"></p>
<h2 id="存在左右子结点的结点"><a href="#存在左右子结点的结点" class="headerlink" title="存在左右子结点的结点"></a>存在左右子结点的结点</h2><p>为了更加清楚表达删除存在左右结点的结点，先向树中多添加3个结点8，10，15。然后删除结点9。<br>这里的解决方法就是，删除9后，可以用前驱结点或后继结点补上。前驱结点为左子树中最大的结点，后继结点为右子树中最小的结点。<br>现在以后继结点补上的方案为：</p>
<p><img src="https://images.ytao.top/%E6%B7%BB%E5%8A%A0%E7%BB%93%E7%82%B9%E5%90%8E%E7%9A%84%E6%A0%91.png" alt="二叉查找树"></p>
<p>后继结点补上删除后的结点：</p>
<p><img src="https://images.ytao.top/%E5%90%8E%E7%BB%A7%E7%BB%93%E7%82%B9%E8%A1%A5%E4%B8%8A.png" alt="后继结点补上示意图"></p>
<p>完成删除，后继结点补充上后：</p>
<p><img src="https://images.ytao.top/%E5%90%8E%E7%BB%A7%E7%BB%93%E7%82%B9%E8%A1%A5%E4%B8%8A%E5%90%8E.png" alt="完成删除后的树"></p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytao.bst;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YANGTAO on 2019/11/3 0003.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeleteBST</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">delete</span><span class="params">(Node node, <span class="type">int</span> delVal)</span> &#123;</span><br><span class="line">        <span class="comment">// 为空时，代表叶子结点</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">nodeVal</span> <span class="operator">=</span> node.getValue();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> node.getLeftChildren();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> node.getRightChildren();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除的结点，与遍历到的当前结点做比较，小于，大于或等于</span></span><br><span class="line">        <span class="keyword">if</span> (delVal &lt; nodeVal)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">tempLeftNode</span> <span class="operator">=</span> delete(leftNode, delVal);</span><br><span class="line">            node.setLeftChildren(tempLeftNode);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(delVal &gt; nodeVal)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">tempRightNode</span> <span class="operator">=</span> delete(rightNode, delVal);</span><br><span class="line">            node.setRightChildren(tempRightNode);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除的结点与当前遍历到的结点相等时</span></span><br><span class="line">            <span class="comment">// 并且左结点为空时，返回右结点去补上删除的位置，反则返回左结点补上</span></span><br><span class="line">            <span class="comment">// 说明删除结点为单子结点的情况</span></span><br><span class="line">            <span class="keyword">if</span> (leftNode == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> rightNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightNode == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> leftNode;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过查询最小右结点，获取后继结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">minNode</span> <span class="operator">=</span> minNode(rightNode);</span><br><span class="line">            <span class="type">int</span> <span class="variable">minNodeValue</span> <span class="operator">=</span> minNode.getValue();</span><br><span class="line">            node.setValue(minNodeValue);</span><br><span class="line">            <span class="comment">// 删除后继结点</span></span><br><span class="line">            <span class="type">Node</span> <span class="variable">tempRightNode</span> <span class="operator">=</span> delete(rightNode, minNodeValue);</span><br><span class="line">            node.setRightChildren(tempRightNode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Node <span class="title function_">minNode</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">        <span class="comment">// 一直寻找最小值，知道左子节点为空为止</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> node.getLeftChildren();</span><br><span class="line">        <span class="keyword">if</span> (leftNode != <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> minNode(leftNode);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>至此上面三中情况都予满足。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>上面对二叉查找树的操作都已介绍，但是正真使用中，是要结合实际业务进行相关调整来满足自己的需求，不然，一切的优化手段都是假把式。二叉查找树虽然好用，但是它也是有一定要求，在数据量不大的情况下，使用遍历的方式，更加符合我们的要求，所以它使用场景一般是在海量数据的查询，用来提查询效率。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>爱恨交织的红黑树</title>
    <url>/2019/11/09/6_rbt/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/rbt.png" alt="BST"></p>
<p><strong>虐你千万遍，还要待她如初恋的红黑树，是否对她既欢喜又畏惧。别担心，通过本文讲解，希望你能有前所未有的感动。</strong></p>
<blockquote>
<p>红黑树也是二叉查找树，但比普通的二叉查找树多一些特性条件限制，每个结点上都存储有红色或黑色的标记。因为是二叉查找树，所以他拥有二叉查找树的所有特性。红黑树是一种自平衡二叉查找树，在极端数据条件插入时（正序或倒叙）不会退化成类链状数据，可以更高效的在O(log(n))时间内完成查找，插入，删除操作。</p>
</blockquote>
<span id="more"></span>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>在阅读本文之前，建议先阅读我上篇文章<a href="https://ytao.top/2019/11/03/5_bst/">《二叉查找树的解读和实现》</a>，可以更好的帮助你理解红黑树。</p>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ol>
<li>结点是红色或黑色</li>
<li>根结点必须为黑色</li>
<li>叶子结点（约定为null）一定为黑色</li>
<li>任一结点到叶子结点的每条路径上黑色结点数量都相等</li>
<li>不允许连续两个结点都为红色，也就是说父结点和子结点不能都为红色</li>
</ol>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>红黑树的查找方式和上篇文章所讲述的原理一样，这里就不重新讲述，以结点<code>[38,20,50,15,27,43,70,60,90]</code>为例，返回一颗红黑树。</p>
<p><img src="https://images.ytao.top/%E5%BB%BA%E7%AB%8Brbt.png" alt="红黑树"></p>
<h1 id="普通操作"><a href="#普通操作" class="headerlink" title="普通操作"></a>普通操作</h1><p>红黑树的插入和删除，分为多种情况，相对来说比较复杂。插入或删除新结点后的树，必须要满足上面五点特性的二叉查找树，所以要通过不同手段来调整树。但普通操作就是和普通二叉查找树操作一样。<br>比如普通插入中，因为每个结点只能是红色或黑色，所以我们定义新添加的非根结点默认颜色为红色。将新结点定义为红色的原因是为了满足特性4（任一结点到叶子结点的每条路径上黑色结点数量都相等），否则会多出一个黑色结点打破规则。<br>现在向树中插入结点10。</p>
<p><img src="https://images.ytao.top/rbt_add10.png" alt="插入结点10"></p>
<p>从图中可以看到，父结点15为黑色结点，插入红色结点10，不会增加黑色结点的数量，其他规则也没有受到影响，所以，当插入结点的父结点为黑色时，直接插入树中，不会破坏原红黑树的规则。<br>该种情况代码实现：<br>结点对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytao.rbt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YANGTAO on 2019/11/9 0009.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">RED</span> <span class="operator">=</span> <span class="string">&quot;red&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">BLACK</span> <span class="operator">=</span> <span class="string">&quot;black&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String color;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(Integer value, String color, Node left, Node right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value, String color)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">commonInsert</span><span class="params">(Node node, Integer newVal)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)</span><br><span class="line">        node = <span class="keyword">new</span> <span class="title class_">Node</span>(newVal, Node.BLACK);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (newVal &lt; node.value)&#123;</span><br><span class="line">            <span class="keyword">if</span> (node.left == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="comment">// 如果左树为叶子结点并且父结点为黑色，可以直接插入红色新结点</span></span><br><span class="line">                <span class="keyword">if</span> (node.color == Node.BLACK)&#123;</span><br><span class="line">                    node.left = <span class="keyword">new</span> <span class="title class_">Node</span>(newVal, Node.RED);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (newVal &gt; node.value)&#123;</span><br><span class="line">            <span class="keyword">if</span> (node.right == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span> (node.color == Node.BLACK)&#123;</span><br><span class="line">                    node.right = <span class="keyword">new</span> <span class="title class_">Node</span>(newVal, Node.RED);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这段代码，是否似曾相识的感觉，没错，这就是上篇文章的插入操作加了个颜色限制。<br>同样删除也是如此，这里就不在细述。</p>
<h1 id="变色"><a href="#变色" class="headerlink" title="变色"></a>变色</h1><p>为了更好分析清楚变色的原因，我们将树中的50结点提取出来作为根结点，如图：</p>
<p><img src="https://images.ytao.top/%E7%BB%93%E7%82%B950%E4%BD%9C%E4%B8%BA%E6%A0%B9%E7%9A%84%E6%A0%91.png" alt="结点50作为根的树"></p>
<p>向树中添加结点55，得到树如图：</p>
<p><img src="https://images.ytao.top/50_add_55.png" alt="添加结点55"></p>
<p>这时55和60都为红色结点，不符合红黑树的特性（不允许连续两个结点都为红色），这时我们需要调整，就使用到变色。<br>将父结点60变为黑色，又遇到不符合红黑树特性（任一结点到叶子结点的每条路径上黑色结点数量都相等），因为我们增加了黑色结点60，多出了一个黑色结点。<br>这时的结点70一定为黑色，因为原本的父结点60的颜色为红色。将结点70变为红色，满足了结点70的左子树，但右子树受结点70变为红色的影响，少了个黑色结点，刚好结点90为红色，可以将其变为黑色，满足结点70的右子树要求。<br>该种特殊情况较为简单处理，只需通过变色就能处理。</p>
<p><img src="https://images.ytao.top/50_finish.png" alt="变色调整后"></p>
<p>这种条件结构的红黑树实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">changeColor</span><span class="params">(Node node, <span class="type">int</span> newVal)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> || node.right == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 通过判断待插入结点的父结点和叔叔结点，是否满足我们需要的条件</span></span><br><span class="line">    <span class="keyword">if</span> (node.left.color == Node.RED &amp;&amp; node.right.color == Node.RED)&#123;</span><br><span class="line">        <span class="comment">// 确定是更新到左树还是右树中</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">base</span> <span class="operator">=</span> compare(newVal, node.value) &gt; <span class="number">0</span> ? node.right : node.left;</span><br><span class="line">        <span class="comment">// 和待插入结点的父结点作比较</span></span><br><span class="line">        <span class="keyword">if</span> (newVal &lt; base.value &amp;&amp; base.left == <span class="literal">null</span>)&#123;</span><br><span class="line">            base.left = <span class="keyword">new</span> <span class="title class_">Node</span>(newVal, Node.RED);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (newVal &gt; base.value &amp;&amp; base.right == <span class="literal">null</span>)&#123;</span><br><span class="line">            base.right = <span class="keyword">new</span> <span class="title class_">Node</span>(newVal, Node.RED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node.color = Node.RED;</span><br><span class="line">    <span class="comment">// 通过取反获取插入结点的叔叔结点并将颜色变黑色</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">uncleNode</span> <span class="operator">=</span> compare(newVal, node.value) &gt; <span class="number">0</span> ? node.left : node.right;</span><br><span class="line">    uncleNode.color = Node.BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span> o1, <span class="type">int</span> o2)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o1 == o2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> o1 &gt; o2 ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h1><p>当仅仅通过变色无法解决我们需要满足特性时，我们就要考虑使用红黑树的旋转。<br>旋转在插入和删除中，会频繁用到该操作，为了满足我们的五条特性，通过旋转可以生成一颗新的红黑树，旋转分为左旋转和右旋转。</p>
<h2 id="左旋转"><a href="#左旋转" class="headerlink" title="左旋转"></a>左旋转</h2><p>左旋转为逆时针的旋转，类似于把父结点往左边拉（可以这么记忆区分左右旋转的方向），变换如图：</p>
<p><img src="https://images.ytao.top/rbt_leftR.png" alt="左旋转"></p>
<h2 id="右旋转"><a href="#右旋转" class="headerlink" title="右旋转"></a>右旋转</h2><p>右旋转与左旋转出方向相反外，其他都一样，变换如图：</p>
<p><img src="https://images.ytao.top/rbt_rightR.png" alt="右旋转"></p>
<p>从图中可以看出，旋转后的父子结点，关系对调了，同时子结点的子结点给了父结点。<br>如果是左旋转，那么父结点会成为旋转结点的左子结点；子结点的左子结点会成为父结点的右子结点。<br>如果是右旋转，那么父结点会成为旋转结点的右子结点；子结点的右子结点会成为父结点的左子结点。<br>听起来比较比较拗口，记住一条规则，左小右大，结合上图两个旋转就比较好理解。<br>用代码实现旋转如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 两个旋转结点中的父结点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 两个旋转结点中子结点的值，因为在整合旋转的时候，node可以遍历查找出来，value作为需要旋转的标记结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(Node node, <span class="type">int</span> value)</span>&#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">nodeChild</span> <span class="operator">=</span> compare(value, node.value) &gt; <span class="number">0</span> ? node.right : node.left;</span><br><span class="line">    <span class="keyword">if</span> (nodeChild != <span class="literal">null</span> &amp;&amp; value == nodeChild.value)&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">parent</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="comment">// 旋转子结点小于旋转父结点，执行的是右旋转，否则为左旋转</span></span><br><span class="line">        <span class="keyword">if</span> (value &lt; node.value)&#123;</span><br><span class="line">            rightRotate(parent);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (value &gt; node.value)&#123;</span><br><span class="line">            leftRotate(parent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 左旋转</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node 旋转的父结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">leftRotate</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">rightNode</span> <span class="operator">=</span> node.right;</span><br><span class="line">    <span class="comment">// 旋转结点的左子结点给父结点的右子结点</span></span><br><span class="line">    node.right = rightNode.left;</span><br><span class="line">    <span class="comment">// 父结点作为子结点的左子结点</span></span><br><span class="line">    rightNode.left = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 右旋转</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> node</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rightRotate</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">leftNode</span> <span class="operator">=</span> node.left;</span><br><span class="line">    <span class="comment">// 旋转结点的右子结点给父结点的左子结点</span></span><br><span class="line">    node.left = leftNode.right;</span><br><span class="line">    <span class="comment">// 父结点作为子结点的右子结点</span></span><br><span class="line">    leftNode.right = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="旋转变色案例应用"><a href="#旋转变色案例应用" class="headerlink" title="旋转变色案例应用"></a>旋转变色案例应用</h1><p>在上面结点为38的红黑中插入结点55。应用前面讲解到的变色后，红黑树结构如图：</p>
<p><img src="https://images.ytao.top/rbt_rotate1.png"></p>
<p>此时出现不满足红黑树特性（不允许连续两个结点都为红色），这时需要我们将结点50和结点38进行左旋转，得到如下图：</p>
<p><img src="https://images.ytao.top/rbt_rotate2.png"></p>
<p>根结点50不符合红黑树特性（根结点必须为黑色）,所以先将根结点变为黑色后。</p>
<p><img src="https://images.ytao.top/rbt_rotate3.png"></p>
<p>现在得到的红黑树，又出现违背（任一结点到叶子结点的每条路径上黑色结点数量都相等）特性，左树比右树多一个黑色结点，此时将38，20，15，27颜色改变。</p>
<p><img src="https://images.ytao.top/rbt_rotate4.png"></p>
<p>这里经过变色旋转完成了上面这课树的操作红黑树的调整。</p>
<p>由于代码篇幅较大，并没有将全部可能情况都考虑进来。相信理解了红黑树的对编码实现不是太大问题。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>红黑树的操作是基于普通二叉查找树上加了红黑树的特性，不管是插入还是删除操作，也就是在普通红黑树上进行旋转变色调整树结构，所以在理解红黑树的时候，主要把握旋转，变色，利用旋转变色来满足红黑树的特性，这也是红黑树的精华所在。懂得其原理和设计思想的话，应用到实际中解决问题确实是很不错的设计。当然，红黑树在实际的操作过程中是多变的，复杂的，要完全掌握还是要花点时间来研究的。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>WebSocket实现Web端即时通信</title>
    <url>/2019/11/17/7_websocket/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/7_banner.jpg"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>WebSocket 是HTML5开始提供的一种在浏览器和服务器间进行全双工通信的协议。目前很多没有使用WebSocket进行客户端服务端实时通信的web应用，大多使用设置规则时间的轮询，或者使用长轮询较多来处理消息的实时推送。这样势必会较大程度浪费服务器和带宽资源，而我们现在要讲的WebSocket正是来解决该问题而出现，使得B&#x2F;S架构的应用拥有C&#x2F;S架构一样的实时通信能力。</p>
</blockquote>
<span id="more"></span>

<h1 id="HTTP和WebSocket比较"><a href="#HTTP和WebSocket比较" class="headerlink" title="HTTP和WebSocket比较"></a>HTTP和WebSocket比较</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP协议是半双工协议，也就是说在同一时间点只能处理一个方向的数据传输，同时HTTP消息也是过于庞大，里面包含大量消息头数据，真正在消息处理中很多数据不是必须的，这也是对资源的浪费。</p>
<ul>
<li><strong>定时轮询</strong>：定时轮询就是客户端定时去向服务器发送HTTP请求，看是否有数据，服务器接受到请求后，返回数据给客户端，本次连接也会随着关闭。该实现方案最简单，但是会存在消息延迟和大量浪费服务器和带宽资源。</li>
<li><strong>长轮询</strong>：长轮询与定时轮询一样，也是通过HTTP请求实现，但这里不是定时发送请求。客户端发送请求给服务端，这时服务端会hold住该请求，当有数据过来或者超时时返回给请求的客户端并开始下一轮的请求。</li>
</ul>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket在客户端和服务端只需一次请求，就会在客户端和服务端建立一条通信通道，可以实时相互传输数据，并且不会像HTTP那样携带大量请求头等信息。因为WebSocket是基于TCP双向全双工通信的协议，所以支持在同一时间点处理发送和接收消息，做到实时的消息处理。</p>
<ul>
<li><strong>建立WebSocket连接</strong>：建立WebSocket连接，首先客户端先要向服务端发送一个特殊的HTTP请求，使用的协议不是<code>http</code>或<code>https</code>，而是使用过<code>ws</code>或<code>wss</code>(一个非安全的，一个安全的，类似前两者之间的差别)，请求头里面要附加一个申请协议升级的信息<code>Upgrade: websocket</code>，还有随机生成一个<code>Sec-WebSocket-Key</code>的值，及版本信息<code>Sec-WebSocket-Version</code>等等。服务端收到客户端的请求后，会解析该请求的信息，包括请求协议升级，版本校验，以及将<code>Sec-WebSocket-Key</code>的加密后以<code>sec-websocket-accept</code>的值返回给客户端，这样客户端和服务端的连接就建立了。</li>
<li><strong>关闭WebSocket连接</strong>：客户端和服务端都可发送一个close控制帧，另一端主动关闭连接。</li>
</ul>
<p>HTTP轮询和WebSocket生命周期示意图</p>
<p><img src="https://images.ytao.top/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE.png" alt="HTTP轮询和WebSocket生命周期示意图"></p>
<h1 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h1><p>这里服务端利用Netty的WebSocket开发。这里首先实现服务端启动类，然后自定义处理器来处理WebSocket的消息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytao.websocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpObjectAggregator;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.HttpServerCodec;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.stream.ChunkedWriteHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YANGTAO on 2019/11/17 0017.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOST</span> <span class="operator">=</span> <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">PORT</span> <span class="operator">=</span> <span class="number">8806</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">startUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 监听端口的线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="comment">// 处理每一条连接的数据读写的线程组</span></span><br><span class="line">        <span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="comment">// 启动的引导类</span></span><br><span class="line">        <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serverBootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;logger&quot;</span>, <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO));</span><br><span class="line">                            <span class="comment">// 将请求和返回消息编码或解码成http</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;http-codec&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line">                            <span class="comment">// 使http的多个部分组合成一条完整的http</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;aggregator&quot;</span>, <span class="keyword">new</span> <span class="title class_">HttpObjectAggregator</span>(<span class="number">65536</span>));</span><br><span class="line">                            <span class="comment">// 向客户端发送h5文件，主要是来支持websocket通信</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;http-chunked&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChunkedWriteHandler</span>());</span><br><span class="line">                            <span class="comment">// 服务端自定义处理器</span></span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;handler&quot;</span>, <span class="keyword">new</span> <span class="title class_">WebSocketServerHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    <span class="comment">// 开启心跳机制</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioServerSocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioServerSocketChannel ch)</span> &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;WebSocket服务端启动中...&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">ch</span> <span class="operator">=</span> serverBootstrap.bind(HOST, PORT).sync().channel();</span><br><span class="line">            System.out.println(<span class="string">&quot;WebSocket host: &quot;</span>+ch.localAddress().toString().replace(<span class="string">&quot;/&quot;</span>,<span class="string">&quot;&quot;</span>));</span><br><span class="line">            ch.closeFuture().sync();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        startUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面启动类和HTTP协议的类似，所以较好理解。启动类启动后，我们需要处理WebSocket请求，这里自定义<code>WebSocketServerHandler</code>。<br>我们在处理中设计的业务逻辑有，如果只有一个连接来发送信息聊天，那么我们就以服务器自动回复，如果存在一个以上，我们就将信息发送给其他人。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ytao.websocket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPromise;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.FullHttpRequest;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.http.websocketx.*;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YANGTAO on 2019/11/17 0017.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketServerHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;Object&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WebSocketServerHandshaker handshaker;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, ChannelHandlerContext&gt; channelHandlerContextConcurrentHashMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, String&gt; replyMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        replyMap.put(<span class="string">&quot;博客&quot;</span>, <span class="string">&quot;https://ytao.top&quot;</span>);</span><br><span class="line">        replyMap.put(<span class="string">&quot;公众号&quot;</span>, <span class="string">&quot;ytao公众号&quot;</span>);</span><br><span class="line">        replyMap.put(<span class="string">&quot;在吗&quot;</span>, <span class="string">&quot;在&quot;</span>);</span><br><span class="line">        replyMap.put(<span class="string">&quot;吃饭了吗&quot;</span>, <span class="string">&quot;吃了&quot;</span>);</span><br><span class="line">        replyMap.put(<span class="string">&quot;你好&quot;</span>, <span class="string">&quot;你好&quot;</span>);</span><br><span class="line">        replyMap.put(<span class="string">&quot;谁&quot;</span>, <span class="string">&quot;ytao&quot;</span>);</span><br><span class="line">        replyMap.put(<span class="string">&quot;几点&quot;</span>, <span class="string">&quot;现在本地时间：&quot;</span>+LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="string">&quot;HH:mm:ss&quot;</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">messageReceived</span><span class="params">(ChannelHandlerContext channelHandlerContext, Object msg)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        channelHandlerContextConcurrentHashMap.put(channelHandlerContext.channel().toString(), channelHandlerContext);</span><br><span class="line">        <span class="comment">// http</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> FullHttpRequest)&#123;</span><br><span class="line">            handleHttpRequest(channelHandlerContext, (FullHttpRequest) msg);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> WebSocketFrame)&#123; <span class="comment">// WebSocket</span></span><br><span class="line">            handleWebSocketFrame(channelHandlerContext, (WebSocketFrame) msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelReadComplete</span><span class="params">(ChannelHandlerContext channelHandlerContext)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="keyword">if</span> (channelHandlerContextConcurrentHashMap.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (String key : channelHandlerContextConcurrentHashMap.keySet()) &#123;</span><br><span class="line">                <span class="type">ChannelHandlerContext</span> <span class="variable">current</span> <span class="operator">=</span> channelHandlerContextConcurrentHashMap.get(key);</span><br><span class="line">                <span class="keyword">if</span> (channelHandlerContext == current)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                current.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 单条处理</span></span><br><span class="line">            channelHandlerContext.flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleHttpRequest</span><span class="params">(ChannelHandlerContext channelHandlerContext, FullHttpRequest request)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">// 验证解码是否异常</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;websocket&quot;</span>.equals(request.headers().get(<span class="string">&quot;Upgrade&quot;</span>)) || request.decoderResult().isFailure())&#123;</span><br><span class="line">            <span class="comment">// todo send response bad</span></span><br><span class="line">            System.err.println(<span class="string">&quot;解析http信息异常&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建握手工厂类</span></span><br><span class="line">        <span class="type">WebSocketServerHandshakerFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebSocketServerHandshakerFactory</span>(</span><br><span class="line">          <span class="string">&quot;ws:/&quot;</span>.concat(channelHandlerContext.channel().localAddress().toString()),</span><br><span class="line">                <span class="literal">null</span>,</span><br><span class="line">                <span class="literal">false</span></span><br><span class="line">        );</span><br><span class="line">        handshaker = factory.newHandshaker(request);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (handshaker == <span class="literal">null</span>)</span><br><span class="line">            WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(channelHandlerContext.channel());</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 响应握手消息给客户端</span></span><br><span class="line">            handshaker.handshake(channelHandlerContext.channel(), request);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleWebSocketFrame</span><span class="params">(ChannelHandlerContext channelHandlerContext, WebSocketFrame webSocketFrame)</span>&#123;</span><br><span class="line">        <span class="comment">// 关闭链路</span></span><br><span class="line">        <span class="keyword">if</span> (webSocketFrame <span class="keyword">instanceof</span> CloseWebSocketFrame)&#123;</span><br><span class="line">            handshaker.close(channelHandlerContext.channel(), (CloseWebSocketFrame) webSocketFrame.retain());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ping消息</span></span><br><span class="line">        <span class="keyword">if</span> (webSocketFrame <span class="keyword">instanceof</span> PingWebSocketFrame)&#123;</span><br><span class="line">            channelHandlerContext.channel().write(</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">PongWebSocketFrame</span>(webSocketFrame.content().retain())</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Pong消息</span></span><br><span class="line">        <span class="keyword">if</span> (webSocketFrame <span class="keyword">instanceof</span> PongWebSocketFrame)&#123;</span><br><span class="line">            <span class="comment">// todo Pong消息处理</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 二进制消息</span></span><br><span class="line">        <span class="keyword">if</span> (webSocketFrame <span class="keyword">instanceof</span> BinaryWebSocketFrame)&#123;</span><br><span class="line">            <span class="comment">// todo 二进制消息处理</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拆分数据</span></span><br><span class="line">        <span class="keyword">if</span> (webSocketFrame <span class="keyword">instanceof</span> ContinuationWebSocketFrame)&#123;</span><br><span class="line">            <span class="comment">// todo 数据被拆分为多个websocketframe处理</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 文本信息处理</span></span><br><span class="line">        <span class="keyword">if</span> (webSocketFrame <span class="keyword">instanceof</span> TextWebSocketFrame)&#123;</span><br><span class="line">            <span class="comment">// 推送过来的消息</span></span><br><span class="line">            <span class="type">String</span>  <span class="variable">msg</span> <span class="operator">=</span> ((TextWebSocketFrame) webSocketFrame).text();</span><br><span class="line">            System.out.println(String.format(<span class="string">&quot;%s 收到消息 : %s&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), msg));</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">responseMsg</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (channelHandlerContextConcurrentHashMap.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                responseMsg = msg;</span><br><span class="line">                <span class="keyword">for</span> (String key : channelHandlerContextConcurrentHashMap.keySet()) &#123;</span><br><span class="line">                    <span class="type">ChannelHandlerContext</span> <span class="variable">current</span> <span class="operator">=</span> channelHandlerContextConcurrentHashMap.get(key);</span><br><span class="line">                    <span class="keyword">if</span> (channelHandlerContext == current)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> current.channel();</span><br><span class="line">                    channel.write(</span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(responseMsg)</span><br><span class="line">                    );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 自动回复</span></span><br><span class="line">                responseMsg = <span class="built_in">this</span>.answer(msg);</span><br><span class="line">                <span class="keyword">if</span>(responseMsg == <span class="literal">null</span>)</span><br><span class="line">                    responseMsg = <span class="string">&quot;暂时无法回答你的问题 -&gt;_-&gt;&quot;</span>;</span><br><span class="line">                System.out.println(<span class="string">&quot;回复消息：&quot;</span>+responseMsg);</span><br><span class="line">                <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelHandlerContext.channel();</span><br><span class="line">                channel.write(</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">TextWebSocketFrame</span>(<span class="string">&quot;【服务端】&quot;</span> + responseMsg)</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">answer</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String key : replyMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (msg.contains(key))</span><br><span class="line">                <span class="keyword">return</span> replyMap.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exceptionCaught</span><span class="params">(ChannelHandlerContext channelHandlerContext, Throwable throwable)</span>&#123;</span><br><span class="line">        throwable.printStackTrace();</span><br><span class="line">        channelHandlerContext.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ChannelHandlerContext channelHandlerContext, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        channelHandlerContextConcurrentHashMap.remove(channelHandlerContext.channel().toString());</span><br><span class="line">        channelHandlerContext.close(promise);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚建立连接时，第一次握手有HTTP协议处理，所以<code>WebSocketServerHandler#messageReceived</code>会判断是HTTP还是WebSocket，如果是HTTP时，交由<code>WebSocketServerHandler#handleHttpRequest</code>处理，里面会去验证请求，并且处理握手后将消息返回给客户端。<br>如果不是HTTP协议，而是WebSocket协议时，处理交给<code>WebSocketServerHandler#handleWebSocketFrame</code>处理，进入WebSocket处理后，这里面有判断消息属于哪种类型，里面包括<code>CloseWebSocketFrame</code>，<code>PingWebSocketFrame</code>，<code>PongWebSocketFrame</code>，<code>BinaryWebSocketFrame</code>，<code>ContinuationWebSocketFrame</code>，<code>TextWebSocketFrame</code>，他们都是<code>WebSocketFrame</code>的子类，并且<code>WebSocketFrame</code>又继承自<code>DefaultByteBufHolder</code>。</p>
<p><img src="https://images.ytao.top/WebSocketFrame.png"></p>
<p><code>channelHandlerContextConcurrentHashMap</code>是缓存WebSocket已连接的信息，因为我们实现的需求要记录连接数量，当有连接关闭时我们要删除以缓存的连接，所以在<code>WebSocketServerHandler#close</code>中要移除缓存。</p>
<p>最后的发送文本到客户端，根据连接数量判断。如果连接数量不大于1，那么，我们”价值一个亿的AI核心代码”<code>WebSocketServerHandler#answer</code>来回复客户端消息。否则除了本次接收的连接，消息会发送给其他所有连接的客户端。</p>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>客户端使用JS实现WebSocket的操作，目前主流的浏览器基本都支持WebSocket。支持情况如图：</p>
<p><img src="https://images.ytao.top/websocket_browser.png" alt="支持WebSocket的浏览器"></p>
<p>客户端H5的代码实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>ytao-websocket<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://libs.baidu.com/jquery/2.0.0/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-id">#msgContent</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">line-height</span>:<span class="number">200%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">width</span>: <span class="number">500px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">resize</span>: none;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-color</span>: <span class="number">#FF9900</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.clean</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: white;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.send</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">border-radius</span>: <span class="number">10%</span>;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: <span class="number">#2BD56F</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">        <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">600px</span>) &#123;</span></span><br><span class="line"><span class="language-css">            <span class="selector-id">#msgContent</span>&#123;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">line-height</span>:<span class="number">200%</span>;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> socket;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> <span class="variable constant_">URL</span> = <span class="string">&quot;ws://127.0.0.1:8806/ytao&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">connect</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">connect</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#status&quot;</span>).<span class="title function_">html</span>(<span class="string">&quot;&lt;span&gt;连接中.....&lt;/span&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        <span class="variable language_">window</span>.<span class="property">WebSocket</span> = !<span class="variable language_">window</span>.<span class="property">WebSocket</span> == <span class="literal">true</span>? <span class="variable language_">window</span>.<span class="property">MozWebSocket</span> : <span class="variable language_">window</span>.<span class="property">WebSocket</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(<span class="variable language_">window</span>.<span class="property">WebSocket</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            socket = <span class="keyword">new</span> <span class="title class_">WebSocket</span>(<span class="variable constant_">URL</span>);</span></span><br><span class="line"><span class="language-javascript">            socket.<span class="property">onmessage</span> = <span class="keyword">function</span>(<span class="params">event</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">var</span> msg = event.<span class="property">data</span> + <span class="string">&quot;\n&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="title function_">addMsgContent</span>(msg);</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            socket.<span class="property">onopen</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                $(<span class="string">&quot;#status&quot;</span>).<span class="title function_">html</span>(<span class="string">&quot;&lt;span style=&#x27;background-color: #44b549&#x27;&gt;WebSocket已连接&lt;/span&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            socket.<span class="property">onclose</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                $(<span class="string">&quot;#status&quot;</span>).<span class="title function_">html</span>(<span class="string">&quot;&lt;span style=&#x27;background-color: red&#x27;&gt;WebSocket已断开连接&lt;/span&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                <span class="built_in">setTimeout</span>(<span class="string">&quot;connect()&quot;</span>, <span class="number">3000</span>);</span></span><br><span class="line"><span class="language-javascript">            &#125;;</span></span><br><span class="line"><span class="language-javascript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;#status&quot;</span>).<span class="title function_">html</span>(<span class="string">&quot;&lt;span style=&#x27;background-color: red&#x27;&gt;该浏览器不支持WebSocket协议！&lt;/span&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">addMsgContent</span>(<span class="params">msg</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> contet = $(<span class="string">&quot;#msgContent&quot;</span>).<span class="title function_">val</span>() + msg;</span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#msgContent&quot;</span>).<span class="title function_">val</span>(contet)</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">clean</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        $(<span class="string">&quot;#msgContent&quot;</span>).<span class="title function_">val</span>(<span class="string">&quot;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">getUserName</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> n = $(<span class="string">&quot;input[name=userName]&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (n == <span class="string">&quot;&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">            n = <span class="string">&quot;匿名&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> n;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">function</span> <span class="title function_">send</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">var</span> message = $(<span class="string">&quot;input[name=message]&quot;</span>).<span class="title function_">val</span>();</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(!<span class="variable language_">window</span>.<span class="property">WebSocket</span>) <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> ($.<span class="title function_">trim</span>(message) == <span class="string">&quot;&quot;</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;不能发送空消息！&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">return</span>;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(socket.<span class="property">readyState</span> == <span class="title class_">WebSocket</span>.<span class="property">OPEN</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">var</span> msg = <span class="string">&quot;【我】&quot;</span> + message + <span class="string">&quot;\n&quot;</span>;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="title function_">addMsgContent</span>(msg);</span></span><br><span class="line"><span class="language-javascript">            socket.<span class="title function_">send</span>(<span class="string">&quot;【&quot;</span>+<span class="title function_">getUserName</span>()+<span class="string">&quot;】&quot;</span>+message);</span></span><br><span class="line"><span class="language-javascript">            $(<span class="string">&quot;input[name=message]&quot;</span>).<span class="title function_">val</span>(<span class="string">&quot;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="string">&quot;无法建立WebSocket连接！&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    $(<span class="variable language_">document</span>).<span class="title function_">keyup</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span>(event.<span class="property">keyCode</span> ==<span class="number">13</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">send</span>()</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;text-align: center;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;status&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>连接中.....<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">h2</span>&gt;</span>信息面板<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;msgContent&quot;</span> <span class="attr">readonly</span>=<span class="string">&quot;readonly&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;clean&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;清除聊天纪录&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;clean()&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;userName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户名&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">form</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return false&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;请输入消息&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">&quot;send&quot;</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;msgBtn&quot;</span> <span class="attr">value</span>=<span class="string">&quot;send&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;send()&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://yangtao.ytao.top/ytao%E5%85%AC%E4%BC%97%E5%8F%B7.jpg&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>JS这里实现相对较简单，主要用到：</p>
<ul>
<li><code>new WebSocket(URL)</code>创建WebSocket对象</li>
<li><code>onopen()</code>打开连接</li>
<li><code>onclose()</code>关闭连接</li>
<li><code>onmessage</code>接收消息</li>
<li><code>send()</code>发送消息</li>
</ul>
<p>当断开连接后，客户端这边重新发起连接，直到连接成功为止。</p>
<h1 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h1><p>客户端和服务端连接后，我们从日志和请求中可以看到上面所提到的验证信息。<br>客户端：</p>
<p><img src="https://images.ytao.top/client_connect.png" alt="客户端连接信息"></p>
<p>服务端：</p>
<p><img src="https://images.ytao.top/server_connect.png" alt="服务端连接信息"></p>
<p>启动服务端后，先实验我们”价值一个亿的AI”，只有一个连接用户时，发送信息结果如图：</p>
<p><img src="https://images.ytao.top/only-one_chat.png"></p>
<p>多个用户连接，这里使用三个连接用户群聊。<br>用户一：</p>
<p><img src="https://images.ytao.top/chat1_.jpg"></p>
<p>用户二：</p>
<p><img src="https://images.ytao.top/chat2.png"></p>
<p>用户三：</p>
<p><img src="https://images.ytao.top/chat3.png"></p>
<p>到目前为止，WebSocket已帮助我们实现即时通信的需求，相信大家也基本入门了WebSocket的基本使用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>通过本文了解，可以帮助大家入门WebSocket并且解决当前可能存在的一些Web端的通信问题。我曾经在两个项目中也有看到该类解决方案都是通过定时轮询去做的，也或多或少对服务器资源造成一定的浪费。因为WebSocket本身是较复杂的，它提供的API也是比较多，所以在使用过程，要去真正使用好或去优化它，并不是一件很简单的事，也是需要根据现实场景针对性的去做。</p>
</blockquote>
]]></content>
      <categories>
        <category>WebSocket</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>WebSocket</tag>
        <tag>即时通讯</tag>
      </tags>
  </entry>
  <entry>
    <title>初探Tomcat的架构设计</title>
    <url>/2019/11/24/8_tomcat/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/tomcat.jpg"></p>
<blockquote>
<p>Tomcat 作为 servlet 容器实现，它是基于 Java 语言开发的轻量级应用服务器。因为 Tomcat 作为应用服务器，它有着完全开源，轻量，性能稳定，部署成本低等优点，所以它成为目前 Java 开发应用部署的首选，几乎每个Java Web开发者都有使用过，但是，你对 Tomcat 的整体设计有进行过了解和思考吗？</p>
</blockquote>
<span id="more"></span>

<p><strong>本文将基于 Tomcat8 进行分析，具体版本为 Tomcat8 当前官网最新修改(2019-11-21 09:28)的版本 <code>v8.5.49</code></strong></p>
<h1 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h1><p>Tomcat 的总体结构中有很多模块，下图列出我们将要进行分析结构中的主要模块。其中主要分析的是Service，Connector，Engine，Host，Context，Wrapper。为避免图层看着太乱，下图中<code>n</code>代表该组件可允许存在多个。</p>
<p><img src="https://images.ytao.top/tomcat.png"></p>
<p>如上图所描述的是：Server 是 tomcat 服务器，在 Server 中可以存在多个服务 Service 。每个服务中可有多个连接器和一个 Servlet 引擎 Engine，一个 Service 中多个连接器对应一个 Engine。 每个 Engine 中，可存在多个域名，这里可用虚拟主机的概念来表示 Host。每个 Host 中可以存在多个应用 Context。<br>Server，Service，Connector，Engine，Host，Context，Wrapper 它们之间的关系，除了Connector和Engine，它们是平行关系，其它的都是存在包含关系。同时，它们也都继承了 Lifecycle 接口，该接口提供的是生命周期的管理，里面包括：**初始化（init），启动（start），停止(stop)，销毁(destroy)**。当它的父容器启动时，会调用它子容器的启动，停止也是一样的。</p>
<p><img src="https://images.ytao.top/tomcat-lifecycle.png"></p>
<p>上图中，还可以看到，Engine，Host，Context，Wrapper 都继承自 Container。它有个<code>backgroundProcess()</code>方法，后台异步处理，所以继承它后可以方便的创建异步线程。<br>在 Tomcat7 中，有看到 Service 持有的是 Container，而不是 Engine。估计这也是为什么在当前版本中添加 Engine 方法名叫<code>setContainer</code>。</p>
<h1 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h1><p>Tomcat 源码中有提供<code>org.apache.catalina.Server</code>接口，对应的默认实现类为<code>org.apache.catalina.core.StandardServer</code>，接口里面提供有如下图方法。</p>
<p><img src="https://images.ytao.top/tomcat-server.png"></p>
<p>上图中可以知道 Server 做的工作：对 Service，Address，Port，Catalina 以及全局命名资源的管理操作。<br>Server 在进行初始化的时候，会加载我们 server.xml 中配置的数据。</p>
<p><img src="https://images.ytao.top/tomcat-server-config.png"></p>
<p>这里对其中的 Service 操作的<code>addService</code>向定义的服务集添加新服务进行分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存服务的服务集</span></span><br><span class="line"><span class="keyword">private</span> Service services[] = <span class="keyword">new</span> <span class="title class_">Service</span>[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">PropertyChangeSupport</span> <span class="variable">support</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PropertyChangeSupport</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addService</span><span class="params">(Service service)</span> &#123;</span><br><span class="line">    <span class="comment">// 相互关联</span></span><br><span class="line">    service.setServer(<span class="built_in">this</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用同步锁，防止并发访问   来源：https://ytao.top</span></span><br><span class="line">    <span class="keyword">synchronized</span> (servicesLock) &#123;</span><br><span class="line">        Service results[] = <span class="keyword">new</span> <span class="title class_">Service</span>[services.length + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// copy 旧的服务到新的数组中</span></span><br><span class="line">        System.arraycopy(services, <span class="number">0</span>, results, <span class="number">0</span>, services.length);</span><br><span class="line">        <span class="comment">// 添加新的 service</span></span><br><span class="line">        results[services.length] = service;</span><br><span class="line">        services = results;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 如果当前 server 已经启动，那么当前添加的 service 就开始启动</span></span><br><span class="line">        <span class="keyword">if</span> (getState().isAvailable()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                service.start();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用观察者模式，当被监听对象属性值发生变化时通知监听器，remove 是也会调用。</span></span><br><span class="line">        support.firePropertyChange(<span class="string">&quot;service&quot;</span>, <span class="literal">null</span>, service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>源码中可以看到，向服务器中添加服务后，随机会启动服务，实则也服务启动入口。</p>
<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><p>Service 的主要职责就是将 Connector 和 Engine 的组装在一起。两者分开的目的也就是使请求监听和请求处理进行解耦，能拥有更好的扩展性。每个 Service 都是相互独立的，但是共享一个JVM和系统类库。这里提供了<code>org.apache.catalina.Service</code>接口和默认实现类<code>org.apache.catalina.coreStandardService</code>。</p>
<p><img src="https://images.ytao.top/tomcat-service.png"></p>
<p>在实现类 StandardService 中，主要分析<code>setContainer</code>和<code>addConnector</code>两个方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">Engine</span> <span class="variable">engine</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">MapperListener</span> <span class="variable">mapperListener</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperListener</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContainer</span><span class="params">(Engine engine)</span> &#123;</span><br><span class="line">    <span class="type">Engine</span> <span class="variable">oldEngine</span> <span class="operator">=</span> <span class="built_in">this</span>.engine;</span><br><span class="line">    <span class="comment">// 判断当前 Service 是否有关联 Engine</span></span><br><span class="line">    <span class="keyword">if</span> (oldEngine != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果当前 Service 有关联 Engine，就去掉当前关联的 Engine</span></span><br><span class="line">        oldEngine.setService(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前新的 Engine 不为空，那么 Engine 关联当前 Service，这里是个双向关联</span></span><br><span class="line">    <span class="built_in">this</span>.engine = engine;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.engine != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.engine.setService(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前 Service 启动了，那么就开始启动当前新的 Engine</span></span><br><span class="line">    <span class="keyword">if</span> (getState().isAvailable()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.engine != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="built_in">this</span>.engine.start();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">                log.error(sm.getString(<span class="string">&quot;standardService.engine.startFailed&quot;</span>), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重启 MapperListener ，获取一个新的 Engine ，一定是当前入参的 Engine</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mapperListener.stop();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">            log.error(sm.getString(<span class="string">&quot;standardService.mapperListener.stopFailed&quot;</span>), e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mapperListener.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">            log.error(sm.getString(<span class="string">&quot;standardService.mapperListener.startFailed&quot;</span>), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前 Service 之前有 Engine 关联，那么停止之前的 Engine</span></span><br><span class="line">        <span class="keyword">if</span> (oldEngine != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oldEngine.stop();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">                log.error(sm.getString(<span class="string">&quot;standardService.engine.stopFailed&quot;</span>), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Report this property change to interested listeners</span></span><br><span class="line">    support.firePropertyChange(<span class="string">&quot;container&quot;</span>, oldEngine, <span class="built_in">this</span>.engine);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 实现方式和 StandardServer#addService 类似，不在细述</span></span><br><span class="line"><span class="comment">* 注意，Connector 这里没有像 Engine 一样与 Service 实现双向关联</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addConnector</span><span class="params">(Connector connector)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (connectorsLock) &#123;</span><br><span class="line">        connector.setService(<span class="built_in">this</span>);</span><br><span class="line">        Connector results[] = <span class="keyword">new</span> <span class="title class_">Connector</span>[connectors.length + <span class="number">1</span>];</span><br><span class="line">        System.arraycopy(connectors, <span class="number">0</span>, results, <span class="number">0</span>, connectors.length);</span><br><span class="line">        results[connectors.length] = connector;</span><br><span class="line">        connectors = results;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getState().isAvailable()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connector.start();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (LifecycleException e) &#123;</span><br><span class="line">                log.error(sm.getString(</span><br><span class="line">                        <span class="string">&quot;standardService.connector.startFailed&quot;</span>,</span><br><span class="line">                        connector), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Report this property change to interested listeners</span></span><br><span class="line">        support.firePropertyChange(<span class="string">&quot;connector&quot;</span>, <span class="literal">null</span>, connector);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h1><p>Connector 主要用于接收请求，然后交给 Engine 处理请求，处理完后再给 Connector 去返回给客户端。当前使用版本支持的协议有：HTTP，HHTP&#x2F;2，AJP，NIO，NIO2，APR<br>主要的功能包括：</p>
<ul>
<li>监听服务器端口来读取客户端的请求。</li>
<li>解析协议并交给对应的容器处理请求。</li>
<li>返回处理后的信息给客户端</li>
</ul>
<p>Connector 对应服务器 server.xml 中配置信息的例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里通过配置监听的端口号<code>port</code>，指定处理协议<code>protocol</code>，以及重定向地址<code>redirectPort</code>。<br>协议处理类型通过实例化连接器时设置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Connector</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 无参构造，下面 setProtocol 中默认使用HTTP/1.1</span></span><br><span class="line">    <span class="built_in">this</span>(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Connector</span><span class="params">(String protocol)</span> &#123;</span><br><span class="line">    <span class="comment">// 设置当前连接器协议处理类型</span></span><br><span class="line">    setProtocol(protocol);</span><br><span class="line">    <span class="comment">// 实例化协议处理器，并保存到当前 Connector 中</span></span><br><span class="line">    <span class="type">ProtocolHandler</span> <span class="variable">p</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Class&lt;?&gt; clazz = Class.forName(protocolHandlerClassName);</span><br><span class="line">        p = (ProtocolHandler) clazz.getConstructor().newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(sm.getString(</span><br><span class="line">                <span class="string">&quot;coyoteConnector.protocolHandlerInstantiationFailed&quot;</span>), e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.protocolHandler = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Globals.STRICT_SERVLET_COMPLIANCE) &#123;</span><br><span class="line">        uriCharset = StandardCharsets.ISO_8859_1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        uriCharset = StandardCharsets.UTF_8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 这个设置再 tomcat9 中被移除，改为必配项</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProtocol</span><span class="params">(String protocol)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">aprConnector</span> <span class="operator">=</span> AprLifecycleListener.isAprAvailable() &amp;&amp;</span><br><span class="line">            AprLifecycleListener.getUseAprConnector();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里指定了默认协议和 HTTP/1.1 一样</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;HTTP/1.1&quot;</span>.equals(protocol) || protocol == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aprConnector) &#123;</span><br><span class="line">            setProtocolHandlerClassName(<span class="string">&quot;org.apache.coyote.http11.Http11AprProtocol&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setProtocolHandlerClassName(<span class="string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;AJP/1.3&quot;</span>.equals(protocol)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aprConnector) &#123;</span><br><span class="line">            setProtocolHandlerClassName(<span class="string">&quot;org.apache.coyote.ajp.AjpAprProtocol&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setProtocolHandlerClassName(<span class="string">&quot;org.apache.coyote.ajp.AjpNioProtocol&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 最后如果不是通过指定 HTTP/1.1，AJP/1.3 类型的协议，就通过类名实例化一个协议处理器</span></span><br><span class="line">        setProtocolHandlerClassName(protocol);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ProtocolHandler 是一个协议处理器，针对不同的请求，提供不同实现。实现类 AbstractProtocol 在初始化时，会在最后调用一个抽象类 AbstractEndpoint 初始化来启动线程来监听服务器端口，当接收到请求后，调用 Processor 读取请求，然后交给 Engine 处理请求。</p>
<h1 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h1><p>Engine 对应的是，<code>org.apache.catalina.Engine</code>接口和<code>org.apache.catalina.core.StandardEngine</code>默认实现类。<br>Engine 的功能也比较简单，处理容器关系的关联。</p>
<p><img src="https://images.ytao.top/tomcat-engine.png"></p>
<p>但是实现类中的<code>addChild()</code>不是指的子 Engine，而是只能是 Host。同时没有父容器，<code>setParent</code>是不允许操作设置的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addChild</span><span class="params">(Container child)</span> &#123;</span><br><span class="line">    <span class="comment">// 添加的子容器必须是 Host </span></span><br><span class="line">    <span class="keyword">if</span> (!(child <span class="keyword">instanceof</span> Host))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span></span><br><span class="line">            (sm.getString(<span class="string">&quot;standardEngine.notHost&quot;</span>));</span><br><span class="line">    <span class="built_in">super</span>.addChild(child);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParent</span><span class="params">(Container container)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span></span><br><span class="line">        (sm.getString(<span class="string">&quot;standardEngine.notParent&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>server.xml 可以配置我们的数据：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置默认Host，及jvmRoute --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Engine</span> <span class="attr">name</span>=<span class="string">&quot;Catalina&quot;</span> <span class="attr">defaultHost</span>=<span class="string">&quot;localhost&quot;</span> <span class="attr">jvmRoute</span>=<span class="string">&quot;jvm1&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h1><p>Host 表示一个虚拟主机。应为我们的服务器可设置多个域名，比如 demo.ytao.top，dev.ytao.top。那么我们就要设置两个不同 Host 来处理不同域名的请求。当过来的请求域名为 demo.ytao.top 时，那么它就会去找该域名 Host 下的 Context。<br>所以我们的 server.xml 配置文件也提供该配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- name 设置的时虚拟主机域名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Host</span> <span class="attr">name</span>=<span class="string">&quot;localhost&quot;</span>  <span class="attr">appBase</span>=<span class="string">&quot;webapps&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">unpackWARs</span>=<span class="string">&quot;true&quot;</span> <span class="attr">autoDeploy</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p>到 Context 这里来，就拥有 Servlet 的运行环境，Engine，Host都是主要维护容器关系，不具备运行环境。<br>我们暂且可将 Context 理解为一个应用，例如我们在根目录下有 ytao-demo-1 和 ytao-demo-2 两个应用，那么这里就是有两个 Context。<br>这里主要介绍的<code>addChild</code>方法，该添加的子容器是 Wrapper:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addChild</span><span class="params">(Container child)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Global JspServlet</span></span><br><span class="line">    <span class="type">Wrapper</span> <span class="variable">oldJspServlet</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里添加的子容器只能时 Wrapper</span></span><br><span class="line">    <span class="keyword">if</span> (!(child <span class="keyword">instanceof</span> Wrapper)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span></span><br><span class="line">            (sm.getString(<span class="string">&quot;standardContext.notWrapper&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断子容器 Wrapper 是否为 JspServlet</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isJspServlet</span> <span class="operator">=</span> <span class="string">&quot;jsp&quot;</span>.equals(child.getName());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow webapp to override JspServlet inherited from global web.xml.</span></span><br><span class="line">    <span class="keyword">if</span> (isJspServlet) &#123;</span><br><span class="line">        oldJspServlet = (Wrapper) findChild(<span class="string">&quot;jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (oldJspServlet != <span class="literal">null</span>) &#123;</span><br><span class="line">            removeChild(oldJspServlet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>.addChild(child);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将servlet映射添加到Context组件</span></span><br><span class="line">    <span class="keyword">if</span> (isJspServlet &amp;&amp; oldJspServlet != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * The webapp-specific JspServlet inherits all the mappings</span></span><br><span class="line"><span class="comment">         * specified in the global web.xml, and may add additional ones.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String[] jspMappings = oldJspServlet.findMappings();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; jspMappings!=<span class="literal">null</span> &amp;&amp; i&lt;jspMappings.length; i++) &#123;</span><br><span class="line">            addServletMappingDecoded(jspMappings[i], child.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里也就是每个应用中的 Servlet 管理中心。</p>
<h1 id="Wrapper"><a href="#Wrapper" class="headerlink" title="Wrapper"></a>Wrapper</h1><p>Wrapper 是一个 Servlet 的管理中心，它拥有 Servlet 的整个生命周期，它是没有子容器的，因为它自己就是最底层的容器了。<br>这里主要对 Servlet 加载的分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Servlet <span class="title function_">loadServlet</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果已经实例化或者用实例化池，就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!singleThreadModel &amp;&amp; (instance != <span class="literal">null</span>))</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line"></span><br><span class="line">    <span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> System.out;</span><br><span class="line">    <span class="keyword">if</span> (swallowOutput) &#123;</span><br><span class="line">        SystemLogHandler.startCapture();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Servlet servlet;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">long</span> t1=System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 如果 servlet 类名为空，直接抛出 Servlet 异常</span></span><br><span class="line">        <span class="keyword">if</span> (servletClass == <span class="literal">null</span>) &#123;</span><br><span class="line">            unavailable(<span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span></span><br><span class="line">                (sm.getString(<span class="string">&quot;standardWrapper.notClass&quot;</span>, getName()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 Context 中获取 Servlet</span></span><br><span class="line">        <span class="type">InstanceManager</span> <span class="variable">instanceManager</span> <span class="operator">=</span> ((StandardContext)getParent()).getInstanceManager();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            servlet = (Servlet) instanceManager.newInstance(servletClass);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            unavailable(<span class="literal">null</span>);</span><br><span class="line">            <span class="comment">// Restore the context ClassLoader</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span></span><br><span class="line">                (sm.getString(<span class="string">&quot;standardWrapper.notServlet&quot;</span>, servletClass), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e = ExceptionUtils.unwrapInvocationTargetException(e);</span><br><span class="line">            ExceptionUtils.handleThrowable(e);</span><br><span class="line">            unavailable(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Added extra log statement for Bugzilla 36630:</span></span><br><span class="line">            <span class="comment">// https://bz.apache.org/bugzilla/show_bug.cgi?id=36630</span></span><br><span class="line">            <span class="keyword">if</span>(log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(sm.getString(<span class="string">&quot;standardWrapper.instantiate&quot;</span>, servletClass), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Restore the context ClassLoader</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ServletException</span></span><br><span class="line">                (sm.getString(<span class="string">&quot;standardWrapper.instantiate&quot;</span>, servletClass), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载声明了 MultipartConfig 注解的信息</span></span><br><span class="line">        <span class="keyword">if</span> (multipartConfigElement == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">MultipartConfig</span> <span class="variable">annotation</span> <span class="operator">=</span></span><br><span class="line">                    servlet.getClass().getAnnotation(MultipartConfig.class);</span><br><span class="line">            <span class="keyword">if</span> (annotation != <span class="literal">null</span>) &#123;</span><br><span class="line">                multipartConfigElement =</span><br><span class="line">                        <span class="keyword">new</span> <span class="title class_">MultipartConfigElement</span>(annotation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对 servlet 类型进行检查</span></span><br><span class="line">        <span class="keyword">if</span> (servlet <span class="keyword">instanceof</span> ContainerServlet) &#123;</span><br><span class="line">            ((ContainerServlet) servlet).setWrapper(<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        classLoadTime=(<span class="type">int</span>) (System.currentTimeMillis() -t1);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (servlet <span class="keyword">instanceof</span> SingleThreadModel) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instancePool == <span class="literal">null</span>) &#123;</span><br><span class="line">                instancePool = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            singleThreadModel = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 servlet</span></span><br><span class="line">        initServlet(servlet);</span><br><span class="line"></span><br><span class="line">        fireContainerEvent(<span class="string">&quot;load&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">        loadTime=System.currentTimeMillis() -t1;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (swallowOutput) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">log</span> <span class="operator">=</span> SystemLogHandler.stopCapture();</span><br><span class="line">            <span class="keyword">if</span> (log != <span class="literal">null</span> &amp;&amp; log.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (getServletContext() != <span class="literal">null</span>) &#123;</span><br><span class="line">                    getServletContext().log(log);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    out.println(log);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> servlet;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里加载 Servlet，如果该 Servlet 没有被实例化过，那么一定要加载一个。</p>
<blockquote>
<p>到目前为止，大致介绍了 Tomcat8 的主要组件，对 Tomcat 的整体架构也有个大致了解了，Tomcat 源码进行重构后，可读性确实要好很多，建议大家可以去尝试分析下，里面的使用的一些设计模式，我们在实际编码过程中，还是有一定的借鉴意义。</p>
</blockquote>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>Tomcat</tag>
        <tag>应用服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Scrapy爬虫及案例剖析</title>
    <url>/2019/12/01/9_crawl/</url>
    <content><![CDATA[<p><img src="https://images.ytao.top/crawl.jpg"></p>
<blockquote>
<p>由于互联网的极速发展，所有现在的信息处于大量堆积的状态，我们既要向外界获取大量数据，又要在大量数据中过滤无用的数据。针对我们有益的数据需要我们进行指定抓取，从而出现了现在的爬虫技术，通过爬虫技术我们可以快速获取我们需要的数据。但是在这爬虫过程中，信息拥有方会对爬虫进行反爬处理，我们就需要对这些困难进行逐个击破。</p>
</blockquote>
<p><strong>刚好前段时间做了爬虫相关的工作，这里就记录下一些相关的心得。</strong></p>
<span id="more"></span>

<p>本文案例代码地址 <a href="https://github.com/yangtao9502/ytaoCrawl">https://github.com/yangtao9502/ytaoCrawl</a></p>
<p>这里我是使用的 Scrapy 框架进行爬虫，开发环境相关版本号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Scrapy       : 1.5.1</span><br><span class="line">lxml         : 4.2.5.0</span><br><span class="line">libxml2      : 2.9.8</span><br><span class="line">cssselect    : 1.0.3</span><br><span class="line">parsel       : 1.5.1</span><br><span class="line">w3lib        : 1.20.0</span><br><span class="line">Twisted      : 18.9.0</span><br><span class="line">Python       : 3.7.1 (default, Dec 10 2018, 22:54:23) [MSC v.1915 64 bit (AMD64)]</span><br><span class="line">pyOpenSSL    : 18.0.0 (OpenSSL 1.1.1a  20 Nov 2018)</span><br><span class="line">cryptography : 2.4.2</span><br><span class="line">Platform     : Windows-10-10.0.15063-SP0</span><br></pre></td></tr></table></figure>

<p>本地开发环境建议使用 Anaconda 安装相关环境，否则可能出现各种依赖包的冲突，相信遇到过的都深有体会，在你配置相关环境的时候就失去爬虫的兴趣。<br>本文提取页面数据主要使用 Xpath ，所以在进行文中案例操作前，先了解 Xpath 的基本使用。 </p>
<h1 id="创建-Scrapy-项目"><a href="#创建-Scrapy-项目" class="headerlink" title="创建 Scrapy 项目"></a>创建 Scrapy 项目</h1><p>scrapy 创建项目很简单，直接一条命令搞定，接下来我们创建 ytaoCrawl 项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scrapy startproject ytaoCrawl</span><br></pre></td></tr></table></figure>

<p>注意，项目名称必须以字母开头，并且只包含字母、数字和下划线。<br>创建成功后界面显示：</p>
<p><img src="https://images.ytao.top/scrapy-startproject.png"></p>
<p>初始化项目的文件有：</p>
<p><img src="https://images.ytao.top/scrapy-tree.png"></p>
<p>其中各个文件的用途：</p>
<ul>
<li>spider 目录用于存放爬虫文件。</li>
<li>items.py 文件最为对象，将爬虫数据保存在该对象中。</li>
<li>middlewares.py 文件为中间件处理器，比如请求和响应的转换都在里面实现。</li>
<li>pipelines.py 文件为数据管道，用于数据抓取后输送。</li>
<li>settings.py 文件为配置文件，爬虫中的一些配置可在该文件中设置。</li>
<li>scrapy.cfg 文件为爬虫部署的配置文件。</li>
</ul>
<p>了解几个默认生成的文件后再看下面的 scrapy 结构原理图，相对好理解。</p>
<p><img src="https://images.ytao.top/scrapy-frame.png"></p>
<p>这样我们的一个 scrapy 爬虫项目就此创建完成。</p>
<h1 id="创建-Spider"><a href="#创建-Spider" class="headerlink" title="创建 Spider"></a>创建 Spider</h1><p>我们先创建一个 python 文件 ytaoSpider，该类必须继承 scrapy.Spider 类。接下来我们就以爬取北京  58 租房信息为例进行分析。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># @Author  : YangTao</span></span><br><span class="line"><span class="comment"># @blog    : https://ytao.top</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YtaoSpider</span>(scrapy.Spider):</span><br><span class="line">    <span class="comment"># 定义爬虫名称</span></span><br><span class="line">    name = <span class="string">&quot;crawldemo&quot;</span></span><br><span class="line">    <span class="comment"># 允许爬取的域名，但不包含 start_urls 中的链接</span></span><br><span class="line">    allowed_domains = [<span class="string">&quot;58.com&quot;</span>]</span><br><span class="line">    <span class="comment"># 起始爬取链接</span></span><br><span class="line">    start_urls = [</span><br><span class="line">        <span class="string">&quot;https://bj.58.com/chuzu/?PGTID=0d100000-0038-e441-0c8a-adeb346199d8&amp;ClickID=2&quot;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">download</span>(<span class="params">self, response, fName</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(fName + <span class="string">&quot;.html&quot;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(response.body)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># response 是返回抓取后的对象</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="comment"># 下载北京租房页面到本地，便于分析</span></span><br><span class="line">        self.download(response, <span class="string">&quot;北京租房&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>通过执行命令启动爬虫，指定爬虫名字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scrapy crawl crawldemo</span><br></pre></td></tr></table></figure>

<p>当我们有多个爬虫时，可以通过 <code>scrapy list</code> 获取所有的爬虫名。</p>
<p>开发过程中当然也可以用 mian 函数在编辑器中启动：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    name = YtaoSpider.name</span><br><span class="line">    cmd = <span class="string">&#x27;scrapy crawl &#123;0&#125; &#x27;</span>.<span class="built_in">format</span>(name)</span><br><span class="line">    cmdline.execute(cmd.split())</span><br></pre></td></tr></table></figure>

<p>这时将在我们启动的目录中下载生成我们爬取的页面。</p>
<h1 id="翻页爬取"><a href="#翻页爬取" class="headerlink" title="翻页爬取"></a>翻页爬取</h1><p>上面我们只爬取到了第一页，但是我们实际抓取数据过程中，必定会涉及到分页，所以观察到该网站的分页是将最后一页有展示出来（58最多只展示前七十页的数据），如图。</p>
<p><img src="https://images.ytao.top/scrapy-page.png"></p>
<p>从下图观察到分页的 html 部分代码。</p>
<p><img src="https://images.ytao.top/scrapy-page-html.png"></p>
<p>接下来通过 Xpath 和正则匹配获取最后一页的页码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">pageNum</span>(<span class="params">self, response</span>):</span><br><span class="line">    <span class="comment"># 获取分页的 html 代码块</span></span><br><span class="line">    page_ele = response.xpath(<span class="string">&quot;//li[@id=&#x27;pager_wrap&#x27;]/div[@class=&#x27;pager&#x27;]&quot;</span>)</span><br><span class="line">    <span class="comment"># 通过正则获取含有页码数字的文本</span></span><br><span class="line">    num_eles = re.findall(<span class="string">r&quot;&gt;\d+&lt;&quot;</span>, page_ele.extract()[<span class="number">0</span>].strip())</span><br><span class="line">    <span class="comment"># 找出最大的一个</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num_ele <span class="keyword">in</span> num_eles:</span><br><span class="line">        num_ele = <span class="built_in">str</span>(num_ele).replace(<span class="string">&quot;&gt;&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;&lt;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        num = <span class="built_in">int</span>(num_ele)</span><br><span class="line">        <span class="keyword">if</span> num &gt; count:</span><br><span class="line">            count = num</span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<p>通过对租房链接进行分析，可以看出不同页码的链接为<code>https://bj.58.com/chuzu/pn</code>+<code>num</code> 这里的<code>num</code>代表页码，我们进行不同的页码抓取时，只需更换页码即可，parse 函数可更改为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 爬虫链接，不含页码</span></span><br><span class="line">target_url = <span class="string">&quot;https://bj.58.com/chuzu/pn&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;url: &quot;</span>, response.url)</span><br><span class="line">        num = self.pageNum(response)</span><br><span class="line">        <span class="comment"># 开始页面本来就是第一页，所以在遍历页面时，过滤掉第一页</span></span><br><span class="line">        p = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> p &lt; num:</span><br><span class="line">            p += <span class="number">1</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="comment"># 拼接下一页链接</span></span><br><span class="line">                url = self.target_url + <span class="built_in">str</span>(p)</span><br><span class="line">                <span class="comment"># 进行抓取下一页</span></span><br><span class="line">                <span class="keyword">yield</span> Request(url, callback=self.parse)</span><br><span class="line">            <span class="keyword">except</span> BaseException <span class="keyword">as</span> e:</span><br><span class="line">                logging.error(e)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;爬取数据异常：&quot;</span>, url)</span><br></pre></td></tr></table></figure>

<p>执行后，打印出的信息如图：</p>
<p><img src="https://images.ytao.top/scrapy-page-url.png"></p>
<p>因为爬虫是异步抓取，所以我们的打印出来的并非有序数据。<br><strong>上面所介绍的是通过获取最后一页的页码进行遍历抓取，但是有些网站没有最后一页的页码，这时我们可以通过下一页来判断当前页是否为最后一页，如果不是，就获取下一页所携带的链接进行爬取。</strong></p>
<h1 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h1><p>这里我们就获取标题，面积，位置，小区，及价格信息，我们需要先在 item 中创建这些字段，闲话少说，上代码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 避免取xpath解析数据时索引越界</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">xpath_extract</span>(<span class="params">self, selector, index</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(selector.extract()) &gt; index:</span><br><span class="line">        <span class="keyword">return</span> selector.extract()[index].strip()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">setData</span>(<span class="params">self, response</span>):</span><br><span class="line">    items = []</span><br><span class="line">    houses = response.xpath(<span class="string">&quot;//ul[@class=&#x27;house-list&#x27;]/li[@class=&#x27;house-cell&#x27;]&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> house <span class="keyword">in</span> houses:</span><br><span class="line">        item = YtaocrawlItem()</span><br><span class="line">        <span class="comment"># 标题</span></span><br><span class="line">        item[<span class="string">&quot;title&quot;</span>] = self.xpath_extract(house.xpath(<span class="string">&quot;div[@class=&#x27;des&#x27;]/h2/a/text()&quot;</span>), <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 面积</span></span><br><span class="line">        item[<span class="string">&quot;room&quot;</span>] = self.xpath_extract(house.xpath(<span class="string">&quot;div[@class=&#x27;des&#x27;]/p[@class=&#x27;room&#x27;]/text()&quot;</span>), <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 位置</span></span><br><span class="line">        item[<span class="string">&quot;position&quot;</span>] = self.xpath_extract(house.xpath(<span class="string">&quot;div[@class=&#x27;des&#x27;]/p[@class=&#x27;infor&#x27;]/a/text()&quot;</span>), <span class="number">0</span>)</span><br><span class="line">        <span class="comment"># 小区</span></span><br><span class="line">        item[<span class="string">&quot;quarters&quot;</span>] = self.xpath_extract(house.xpath(<span class="string">&quot;div[@class=&#x27;des&#x27;]/p[@class=&#x27;infor&#x27;]/a/text()&quot;</span>), <span class="number">1</span>)</span><br><span class="line">        money = self.xpath_extract(house.xpath(<span class="string">&quot;div[@class=&#x27;list-li-right&#x27;]/div[@class=&#x27;money&#x27;]/b/text()&quot;</span>), <span class="number">0</span>)</span><br><span class="line">        unit = self.xpath_extract(house.xpath(<span class="string">&quot;div[@class=&#x27;list-li-right&#x27;]/div[@class=&#x27;money&#x27;]/text()&quot;</span>), <span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 价格</span></span><br><span class="line">        item[<span class="string">&quot;price&quot;</span>] = money+unit</span><br><span class="line">        items.append(item)</span><br><span class="line">    <span class="keyword">return</span> items</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">    items = self.setData(response)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        <span class="keyword">yield</span> item</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 接着上面的翻页操作 .....</span></span><br></pre></td></tr></table></figure>

<p>至此，我们以获取我们想要的数据，通过打印 parse 中的 item 可看到结果。</p>
<h1 id="数据入库"><a href="#数据入库" class="headerlink" title="数据入库"></a>数据入库</h1><p>我们已抓取到页面的数据，接下来就是将数据入库，这里我们以 MySQL 存储为例，数据量大的情况，建议使用使用其它存储产品。<br>首先我们先在 settings.py 配置文件中设置 ITEM_PIPELINES 属性，指定 Pipeline 处理类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ITEM_PIPELINES = &#123;</span><br><span class="line">    <span class="comment"># 值越小，优先级调用越高</span></span><br><span class="line">   <span class="string">&#x27;ytaoCrawl.pipelines.YtaocrawlPipeline&#x27;</span>: <span class="number">300</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 YtaocrawlPipeline 类中处理数据持久化，这里 MySQL 封装工具类 mysqlUtils 代码可在 github 中查看。<br>通过再 YtaoSpider#parse 中使用 yield 将数据传输到 YtaocrawlPipeline#process_item 中进行处理。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">YtaocrawlPipeline</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_item</span>(<span class="params">self, item, spider</span>):</span><br><span class="line">        table = <span class="string">&quot;crawl&quot;</span></span><br><span class="line">        item[<span class="string">&quot;id&quot;</span>] = <span class="built_in">str</span>(uuid.uuid1())</span><br><span class="line">        <span class="comment"># 如果当前爬取信息的链接在库中有存在，那么就删除旧的再保存新的</span></span><br><span class="line">        <span class="built_in">list</span> = select(<span class="built_in">str</span>.<span class="built_in">format</span>(<span class="string">&quot;select * from &#123;0&#125; WHERE url = &#x27;&#123;1&#125;&#x27;&quot;</span>, table, item[<span class="string">&quot;url&quot;</span>]))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="built_in">list</span>) &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> o <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">                delete_by_id(o[<span class="number">0</span>], table)</span><br><span class="line">        insert(item, table)</span><br><span class="line">        <span class="keyword">return</span> item</span><br></pre></td></tr></table></figure>

<p>在数据库中，可以看到成功抓取到数据并入库。</p>
<p><img src="https://images.ytao.top/scrapy-data-1.png"></p>
<h1 id="反爬机制应对"><a href="#反爬机制应对" class="headerlink" title="反爬机制应对"></a>反爬机制应对</h1><p>既然有数据爬虫的需求，那么就一定有反扒措施，就当前爬虫案例进行一下分析。</p>
<h2 id="字体加密"><a href="#字体加密" class="headerlink" title="字体加密"></a>字体加密</h2><p>通过上面数据库数据的图，可以看到该数据中存在<code>乱码</code>，通过查看数据乱码规律，可以定位在数字进行了加密。</p>
<p><img src="https://images.ytao.top/scrapy-data-2.png"></p>
<p>同时，通过打印数据可以看到<code>\xa0</code>字符，这个（代表空白符）在 ASCII 字符 0x20~0x7e 范围，可知是转换为了 ASCII 编码。</p>
<p><img src="https://images.ytao.top/scrapy-ascii.png"></p>
<p>因为知道是字体加密，所以在下载的页面查看<code>font-family</code>字体时，发现有如下图所示代码：</p>
<p><img src="https://images.ytao.top/scrapy-font.png"></p>
<p>看到这个<code>fangchan-secret</code>字体比较可疑了，它是在js中动态生成的字体，且以 base64 存储，将以下字体进行解码操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    secret = <span class="string">&quot;AAEAAAALAIAAAwAwR1NVQiCLJXoAAAE4AAAAVE9TLzL4XQjtAAABjAAAAFZjbWFwq8p/XQAAAhAAAAIuZ2x5ZuWIN0cAAARYAAADdGhlYWQXlvp9AAAA4AAAADZoaGVhCtADIwAAALwAAAAkaG10eC7qAAAAAAHkAAAALGxvY2ED7gSyAAAEQAAAABhtYXhwARgANgAAARgAAAAgbmFtZTd6VP8AAAfMAAACanBvc3QFRAYqAAAKOAAAAEUAAQAABmb+ZgAABLEAAAAABGgAAQAAAAAAAAAAAAAAAAAAAAsAAQAAAAEAAOOjpKBfDzz1AAsIAAAAAADaB9e2AAAAANoH17YAAP/mBGgGLgAAAAgAAgAAAAAAAAABAAAACwAqAAMAAAAAAAIAAAAKAAoAAAD/AAAAAAAAAAEAAAAKADAAPgACREZMVAAObGF0bgAaAAQAAAAAAAAAAQAAAAQAAAAAAAAAAQAAAAFsaWdhAAgAAAABAAAAAQAEAAQAAAABAAgAAQAGAAAAAQAAAAEERAGQAAUAAAUTBZkAAAEeBRMFmQAAA9cAZAIQAAACAAUDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFBmRWQAQJR2n6UGZv5mALgGZgGaAAAAAQAAAAAAAAAAAAAEsQAABLEAAASxAAAEsQAABLEAAASxAAAEsQAABLEAAASxAAAEsQAAAAAABQAAAAMAAAAsAAAABAAAAaYAAQAAAAAAoAADAAEAAAAsAAMACgAAAaYABAB0AAAAFAAQAAMABJR2lY+ZPJpLnjqeo59kn5Kfpf//AACUdpWPmTyaS546nqOfZJ+Sn6T//wAAAAAAAAAAAAAAAAAAAAAAAAABABQAFAAUABQAFAAUABQAFAAUAAAACAAGAAQAAgAKAAMACQABAAcABQAAAQYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAiAAAAAAAAAAKAACUdgAAlHYAAAAIAACVjwAAlY8AAAAGAACZPAAAmTwAAAAEAACaSwAAmksAAAACAACeOgAAnjoAAAAKAACeowAAnqMAAAADAACfZAAAn2QAAAAJAACfkgAAn5IAAAABAACfpAAAn6QAAAAHAACfpQAAn6UAAAAFAAAAAAAAACgAPgBmAJoAvgDoASQBOAF+AboAAgAA/+YEWQYnAAoAEgAAExAAISAREAAjIgATECEgERAhIFsBEAECAez+6/rs/v3IATkBNP7S/sEC6AGaAaX85v54/mEBigGB/ZcCcwKJAAABAAAAAAQ1Bi4ACQAAKQE1IREFNSURIQQ1/IgBW/6cAicBWqkEmGe0oPp7AAEAAAAABCYGJwAXAAApATUBPgE1NCYjIgc1NjMyFhUUAgcBFSEEGPxSAcK6fpSMz7y389Hym9j+nwLGqgHButl0hI2wx43iv5D+69b+pwQAAQAA/+YEGQYnACEAABMWMzI2NRAhIzUzIBE0ISIHNTYzMhYVEAUVHgEVFAAjIiePn8igu/5bgXsBdf7jo5CYy8bw/sqow/7T+tyHAQN7nYQBJqIBFP9uuVjPpf7QVwQSyZbR/wBSAAACAAAAAARoBg0ACgASAAABIxEjESE1ATMRMyERNDcjBgcBBGjGvv0uAq3jxv58BAQOLf4zAZL+bgGSfwP8/CACiUVaJlH9TwABAAD/5gQhBg0AGAAANxYzMjYQJiMiBxEhFSERNjMyBBUUACEiJ7GcqaDEx71bmgL6/bxXLPUBEv7a/v3Zbu5mswEppA4DE63+SgX42uH+6kAAAAACAAD/5gRbBicAFgAiAAABJiMiAgMzNjMyEhUUACMiABEQACEyFwEUFjMyNjU0JiMiBgP6eYTJ9AIFbvHJ8P7r1+z+8wFhASClXv1Qo4eAoJeLhKQFRj7+ov7R1f762eP+3AFxAVMBmgHjLfwBmdq8lKCytAAAAAABAAAAAARNBg0ABgAACQEjASE1IQRN/aLLAkD8+gPvBcn6NwVgrQAAAwAA/+YESgYnABUAHwApAAABJDU0JDMyFhUQBRUEERQEIyIkNRAlATQmIyIGFRQXNgEEFRQWMzI2NTQBtv7rAQTKufD+3wFT/un6zf7+AUwBnIJvaJLz+P78/uGoh4OkAy+B9avXyqD+/osEev7aweXitAEohwF7aHh9YcJlZ/7qdNhwkI9r4QAAAAACAAD/5gRGBicAFwAjAAA3FjMyEhEGJwYjIgA1NAAzMgAREAAhIicTFBYzMjY1NCYjIga5gJTQ5QICZvHD/wABGN/nAQT+sP7Xo3FxoI16pqWHfaTSSgFIAS4CAsIBDNbkASX+lf6l/lP+MjUEHJy3p3en274AAAAAABAAxgABAAAAAAABAA8AAAABAAAAAAACAAcADwABAAAAAAADAA8AFgABAAAAAAAEAA8AJQABAAAAAAAFAAsANAABAAAAAAAGAA8APwABAAAAAAAKACsATgABAAAAAAALABMAeQADAAEECQABAB4AjAADAAEECQACAA4AqgADAAEECQADAB4AuAADAAEECQAEAB4A1gADAAEECQAFABYA9AADAAEECQAGAB4BCgADAAEECQAKAFYBKAADAAEECQALACYBfmZhbmdjaGFuLXNlY3JldFJlZ3VsYXJmYW5nY2hhbi1zZWNyZXRmYW5nY2hhbi1zZWNyZXRWZXJzaW9uIDEuMGZhbmdjaGFuLXNlY3JldEdlbmVyYXRlZCBieSBzdmcydHRmIGZyb20gRm9udGVsbG8gcHJvamVjdC5odHRwOi8vZm9udGVsbG8uY29tAGYAYQBuAGcAYwBoAGEAbgAtAHMAZQBjAHIAZQB0AFIAZQBnAHUAbABhAHIAZgBhAG4AZwBjAGgAYQBuAC0AcwBlAGMAcgBlAHQAZgBhAG4AZwBjAGgAYQBuAC0AcwBlAGMAcgBlAHQAVgBlAHIAcwBpAG8AbgAgADEALgAwAGYAYQBuAGcAYwBoAGEAbgAtAHMAZQBjAHIAZQB0AEcAZQBuAGUAcgBhAHQAZQBkACAAYgB5ACAAcwB2AGcAMgB0AHQAZgAgAGYAcgBvAG0AIABGAG8AbgB0AGUAbABsAG8AIABwAHIAbwBqAGUAYwB0AC4AaAB0AHQAcAA6AC8ALwBmAG8AbgB0AGUAbABsAG8ALgBjAG8AbQAAAAIAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwECAQMBBAEFAQYBBwEIAQkBCgELAQwAAAAAAAAAAAAAAAAAAAAA&quot;</span></span><br><span class="line">    <span class="comment"># 将字体文件编码转换为 UTF-8 编码的字节对象</span></span><br><span class="line">    <span class="built_in">bytes</span> = secret.encode(encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">    <span class="comment"># base64位解码</span></span><br><span class="line">    decodebytes = base64.decodebytes(<span class="built_in">bytes</span>)</span><br><span class="line">    <span class="comment"># 利用 decodebytes 初始化 BytesIO，然后使用 TTFont 解析字体库</span></span><br><span class="line">    font = TTFont(BytesIO(decodebytes))</span><br><span class="line">    <span class="comment"># 字体的映射关系</span></span><br><span class="line">    font_map = font[<span class="string">&#x27;cmap&#x27;</span>].tables[<span class="number">0</span>].ttFont.tables[<span class="string">&#x27;cmap&#x27;</span>].tables[<span class="number">0</span>].cmap</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(font_map)</span><br></pre></td></tr></table></figure>

<p>通过将 fontTools 库的 TTFont 将字体进行解析，都到如下字体映射结果:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	38006: <span class="string">&#x27;glyph00007&#x27;</span>,</span><br><span class="line">	38287: <span class="string">&#x27;glyph00005&#x27;</span>,</span><br><span class="line">	39228: <span class="string">&#x27;glyph00006&#x27;</span>,</span><br><span class="line">	39499: <span class="string">&#x27;glyph00003&#x27;</span>,</span><br><span class="line">	40506: <span class="string">&#x27;glyph00010&#x27;</span>,</span><br><span class="line">	40611: <span class="string">&#x27;glyph00001&#x27;</span>,</span><br><span class="line">	40804: <span class="string">&#x27;glyph00009&#x27;</span>,</span><br><span class="line">	40850: <span class="string">&#x27;glyph00004&#x27;</span>,</span><br><span class="line">	40868: <span class="string">&#x27;glyph00002&#x27;</span>,</span><br><span class="line">	40869: <span class="string">&#x27;glyph00008&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>刚好十个映射，对应的 0<del>9 的数量，但是查找相应规律，1</del>9 后，出现了个 10，那么这里对应的数字到底是一个怎么样的规律呢？还有上面映射对应的 key 不是16进制的 ASCII 码，而是一个纯数字，是不是可能是十进制的码呢？<br>接下来验证我们的设想，将页面上获取的十六进制的码转换成十进制的码，然后去匹配映射中的数据，发现映射的值的非零数字部分刚好比页面上对应的数字字符大 1 ,可知，真正的值需要我们在映射值中减 1。<br>代码整理后</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self, response, code</span>):</span><br><span class="line">    secret = re.findall(<span class="string">&quot;charset=utf-8;base64,(.*?)&#x27;\)&quot;</span>, response.text)[<span class="number">0</span>]</span><br><span class="line">    code = self.secretfont(code, secret)</span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">secretfont</span>(<span class="params">self, code, secret</span>):</span><br><span class="line">    <span class="comment"># 将字体文件编码转换为 UTF-8 编码的字节对象</span></span><br><span class="line">    <span class="built_in">bytes</span> = secret.encode(encoding=<span class="string">&#x27;UTF-8&#x27;</span>)</span><br><span class="line">    <span class="comment"># base64位解码</span></span><br><span class="line">    decodebytes = base64.decodebytes(<span class="built_in">bytes</span>)</span><br><span class="line">    <span class="comment"># 利用 decodebytes 初始化 BytesIO，然后使用 TTFont 解析字体库</span></span><br><span class="line">    font = TTFont(BytesIO(decodebytes))</span><br><span class="line">    <span class="comment"># 字体的映射关系</span></span><br><span class="line">    font_map = font[<span class="string">&#x27;cmap&#x27;</span>].tables[<span class="number">0</span>].ttFont.tables[<span class="string">&#x27;cmap&#x27;</span>].tables[<span class="number">0</span>].cmap</span><br><span class="line">    chars = []</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> code:</span><br><span class="line">        <span class="comment"># 将每个字符转换成十进制的 ASCII 码</span></span><br><span class="line">        decode = <span class="built_in">ord</span>(char)</span><br><span class="line">        <span class="comment"># 如果映射关系中存在 ASCII 的 key，那么这个字符就有对应的字体</span></span><br><span class="line">        <span class="keyword">if</span> decode <span class="keyword">in</span> font_map:</span><br><span class="line">            <span class="comment"># 获取映射的值</span></span><br><span class="line">            val = font_map[decode]</span><br><span class="line">            <span class="comment"># 根据规律，获取数字部分，再减1得到真正的值</span></span><br><span class="line">            char = <span class="built_in">int</span>(re.findall(<span class="string">&quot;\d+&quot;</span>, val)[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">        chars.append(char)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(<span class="built_in">map</span>(<span class="keyword">lambda</span> s:<span class="built_in">str</span>(s), chars))</span><br></pre></td></tr></table></figure>

<p>现在，我们将所有爬取的数据进行解密处理，再查看数据：</p>
<p><img src="https://images.ytao.top/scrapy-font-data.png"></p>
<p>上图中，进行解密后，完美解决数据乱码！</p>
<h2 id="验证码和封禁IP"><a href="#验证码和封禁IP" class="headerlink" title="验证码和封禁IP"></a>验证码和封禁IP</h2><p>验证码一般分为两类，一类是刚开始进入时，必须输入验证码的，一类是频繁请求后，需要验证码验证再继续接下来的请求。<br>对于第一种来说，就必须破解它的验证码才能继续，第二种来说，除了破解验证码，还可以使用代理进行绕过验证。<br>对于封禁IP的反爬，同样可使用代理进行绕过。比如还是使用上面的网址爬虫，当它们识别到我可能是爬虫时，就会使用验证码进行拦截，如下图：</p>
<p><img src="https://images.ytao.top/scrapy-verify.png"></p>
<p>接下来，我们使用随机 User-Agent 和代理IP进行绕行。<br>先设置 settings.USER_AGENT，注意<strong>PC端和移动端不要混合设置的 User-Agent，否则你会爬取数据会异常，因为不同端的页面不同</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">USER_AGENT = [</span><br><span class="line">    <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.10 Safari/537.36&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; AcooBrowser; .NET CLR 1.1.4322; .NET CLR 2.0.50727)&quot;</span>,</span><br><span class="line">    <span class="comment"># ......</span></span><br><span class="line">]    </span><br></pre></td></tr></table></figure>

<p>在请求中设置随机 User-Agent 中间件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RandomUserAgentMiddleware</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, agents</span>):</span><br><span class="line">        self.agent = agents</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">from_crawler</span>(<span class="params">cls, crawler</span>):</span><br><span class="line">        <span class="keyword">return</span> cls(</span><br><span class="line">            agents=crawler.settings.get(<span class="string">&#x27;USER_AGENT&#x27;</span>)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_request</span>(<span class="params">self, request, spider</span>):</span><br><span class="line">        <span class="comment"># 随机获取设置中的一个 User-Agent</span></span><br><span class="line">        request.headers.setdefault(<span class="string">&#x27;User-Agent&#x27;</span>, random.choice(self.agent))</span><br></pre></td></tr></table></figure>

<p>设置动态IP中间件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyIPMiddleware</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ip=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">        self.ip = ip</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_request</span>(<span class="params">self, request, spider</span>):</span><br><span class="line">        <span class="comment"># 如果当前的地址重定向到了验证码地址,就使用代理ip进行重新请求</span></span><br><span class="line">        <span class="keyword">if</span> self.ban_url(request.url):</span><br><span class="line">            <span class="comment"># 获取被重定向的地址</span></span><br><span class="line">            redirect_urls = request.meta.get(<span class="string">&quot;redirect_urls&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">            <span class="comment"># 将当前重定向到验证码的地址改为原始请求地址</span></span><br><span class="line">            request._set_url(redirect_urls)</span><br><span class="line">            <span class="comment"># 设置动态代理,这里在线上一般使用接口动态生成代理</span></span><br><span class="line">            request.meta[<span class="string">&quot;proxy&quot;</span>] = <span class="string">&quot;http://%s&quot;</span> % (self.proxy_ip())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">ban_url</span>(<span class="params">self, url</span>):</span><br><span class="line">        <span class="comment"># settings中设置的验证码或被禁止的页面链接，当遇到该链接时，爬虫会进行绕行重爬</span></span><br><span class="line">        dic = settings.BAN_URLS</span><br><span class="line">        <span class="comment"># 验证当前请求地址是否为验证码地址</span></span><br><span class="line">        <span class="keyword">for</span> d <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">if</span> url.find(d) != -<span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 代理动态生成的 ip:port</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">proxy_ip</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 模拟动态生成代理地址</span></span><br><span class="line">        ips = [</span><br><span class="line">            <span class="string">&quot;127.0.0.1:8888&quot;</span>,</span><br><span class="line">            <span class="string">&quot;127.0.0.1:8889&quot;</span>,</span><br><span class="line">        ]</span><br><span class="line">        <span class="keyword">return</span> random.choice(ips);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_response</span>(<span class="params">self, request, response, spider</span>):</span><br><span class="line">        <span class="comment"># 如果不是成功响应,则重新爬虫</span></span><br><span class="line">        <span class="keyword">if</span> response.status != <span class="number">200</span>:</span><br><span class="line">            logging.error(<span class="string">&quot;失败响应: &quot;</span>+ <span class="built_in">str</span>(response.status))</span><br><span class="line">            <span class="keyword">return</span> request</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure>

<p>最后在 settings 配置文件中开启这些中间件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">DOWNLOADER_MIDDLEWARES = &#123;</span><br><span class="line">   <span class="string">&#x27;ytaoCrawl.middlewares.RandomUserAgentMiddleware&#x27;</span>: <span class="number">500</span>,</span><br><span class="line">   <span class="string">&#x27;ytaoCrawl.middlewares.ProxyIPMiddleware&#x27;</span>: <span class="number">501</span>,</span><br><span class="line">   <span class="string">&#x27;ytaoCrawl.middlewares.YtaocrawlDownloaderMiddleware&#x27;</span>: <span class="number">543</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在为止，设置随机 User-Agent 和动态IP绕行已完成。</p>
<h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p>使用 scrapyd 部署爬虫项目，可以对爬虫进行远程管理，如启动，关闭，日志调用等等。<br>部署前，我们得先安装 scrapyd ，使用命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install scrapyd</span><br></pre></td></tr></table></figure>

<p>安装成功后，可以看到该版本为 <code>1.2.1</code>。</p>
<p><img src="https://images.ytao.top/scrapy-scrapyd.png"></p>
<p>部署后，我们还需要一个客户端进行访问，这里就需要一个 scrapyd-client 客户端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install scrapyd-client</span><br></pre></td></tr></table></figure>

<p>修改 scrapy.cfg 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[settings]</span><br><span class="line">default = ytaoCrawl.settings</span><br><span class="line"></span><br><span class="line">[deploy:localytao]</span><br><span class="line">url = http://localhost:6800/</span><br><span class="line">project = ytaoCrawl</span><br><span class="line"></span><br><span class="line"><span class="comment"># deploy 可批量部署</span></span><br></pre></td></tr></table></figure>

<p>启动 scrapyd：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scrapyd</span><br></pre></td></tr></table></figure>

<p>如果是 Windows，要先在<code>X:\xx\Scripts</code>下创建<code>scrapyd-deploy.bat</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="string">&quot;X:\xx\python.exe&quot;</span> <span class="string">&quot;X:\xx\Scripts\scrapyd-deploy&quot;</span> %1 %2</span><br></pre></td></tr></table></figure>

<p>项目部署到 Scrapyd 服务上：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scrapyd-deploy localytao -p ytaoCrawl</span><br></pre></td></tr></table></figure>

<p>远程启动<br>curl <a href="http://localhost:6800/schedule.json">http://localhost:6800/schedule.json</a> -d project&#x3D;ytaoCrawl -d spider&#x3D;ytaoSpider</p>
<p>执行启动后，可以在<code>http://localhost:6800/</code>中查看爬虫执行状态，以及日志</p>
<p><img src="https://images.ytao.top/scrapy-scrapyd-page.png"></p>
<p>除了启动可远程调用外，同时 Scrapyd 还提供了较丰富的 API：</p>
<ul>
<li>服务中爬虫状态查询 <code>curl http://localhost:6800/daemonstatus.json</code></li>
<li>取消爬虫  <code>curl http://localhost:6800/cancel.json -d project=projectName -d job=jobId</code></li>
<li>展示项目 <code>curl http://localhost:6800/listprojects.json</code></li>
<li>删除项目 <code>curl http://localhost:6800/delproject.json -d project=projectName</code></li>
<li>展示爬虫 <code>curl http://localhost:6800/listspiders.json?project=projectName</code></li>
<li>获取项目所有版本号 <code>curl http://localhost:6800/listversions.json?project=projectName</code></li>
<li>删除项目版本号 <code>curl http://localhost:6800/delversion.json -d project=projectName -d version=versionName</code></li>
</ul>
<p>更多详情 <a href="https://scrapyd.readthedocs.io/en/stable/api.html">https://scrapyd.readthedocs.io/en/stable/api.html</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote>
<p>本文篇幅有限，剖析过程中不能面面俱到，有些网站的反爬比较棘手的，只要我们一一分析，都能找到破解的办法，还有眼睛看到的数据并不一定是你拿到的数据，比如有些网站的html渲染都是动态的，就需要我们去处理好这些信息。当你走进crawler的世界，你就会发现，其实挺有意思的。最后，希望大家不要面向监狱爬虫，数据千万条，遵纪守法第一条。</p>
</blockquote>
]]></content>
      <categories>
        <category>Scrapy</category>
      </categories>
      <tags>
        <tag>Scrapy</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
</search>
