<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ytao&#39;s blog</title>
  
  
  <link href="https://ytao.top/atom.xml" rel="self"/>
  
  <link href="https://ytao.top/"/>
  <updated>2023-10-10T14:18:14.221Z</updated>
  <id>https://ytao.top/</id>
  
  <author>
    <name>Yang Tao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AQS 原理剖析</title>
    <link href="https://ytao.top/2020/08/25/29-AQS/"/>
    <id>https://ytao.top/2020/08/25/29-AQS/</id>
    <published>2020-08-24T16:00:00.000Z</published>
    <updated>2023-10-10T14:18:14.221Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.ytao.top/20200627230025.jpg"></p><p><code>AQS</code>即<code>AbstractQueuedSynchronizer</code>类称作队列同步器，是构建其他同步器的一个重要的基础框架，同步器自身是没有实现任何同步接口。它是通过控制一个<code>int</code>类型的<code>state</code>变量来表示同步状态，使用一个内置的<code>FIFO</code>（先进先出）队列来构建工作队列操作。</p><p>同步器定义有两种资源共享方式：<code>Exclusive</code>（独占式）和<code>Share</code>（共享式）的获取同步状态。</p><p>独占式：一个时间点只能执行一个线程。<br>共享式：一个时间点可多个线程同时执行。</p><span id="more"></span><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>同步器的设计采用模板模式，要实现一个同步组件得先继承<code>AbstractQueuedSynchronizer</code>类，通过调用同步器提供的方法和重写同步器的方法来实现。</p><p>调用同步器中的方法就是调用前面提到的通过<code>state</code>变量值的操作来表示同步操作，<code>state</code>是被<code>volatile</code>修饰来保证线程可见性。</p><table><thead><tr><th align="center">方法名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">getState()</td><td align="center">获取当前线程同步状态值。</td></tr><tr><td align="center">setState(int newState)</td><td align="center">设置当前同步状态值。</td></tr><tr><td align="center">compareAndSetState(int expect, int update)</td><td align="center">通过<code>CAS</code>设置<code>state</code>的值。</td></tr></tbody></table><p>为了避免被重写，以上方法都被<code>final</code>修饰了。</p><p>实现同步组件，需要自己根据自己定制化的需求进行处理，所以需要自己重写同步器提供的方法，要重写的方法主要是独占式获取与释放同步状态、共享式获取与释放同步状态。</p><p><strong>tryAcquire(int arg)</strong> 独占式获取同步状态，返回值为<code>boolean</code>类型，获取成返回<code>true</code>，获取失败返回<code>false</code>。</p><p><strong>tryRelease(int arg)</strong> 独占式释放同步状态，返回值为<code>boolean</code>类型，释放成返回<code>true</code>，释放失败返回<code>false</code>。</p><p><strong>tryAcquireShared(int arg)</strong> 共享式获取同步状态，返回值为<code>int</code>类型，获取成功返回大于 0 的值。</p><p><strong>tryReleaseShared(int arg)</strong> 共享式释放同步状态，返回值为<code>boolean</code>类型，释放成返回<code>true</code>，释放失败返回<code>false</code>。</p><p><strong>isHeldExclusively()</strong> 独占模式下是否被当前前程独占，返回值为<code>boolean</code>类型，已被当前线程所独占返回<code>true</code>，反之为<code>false</code>。</p><h1 id="同步器队列"><a href="#同步器队列" class="headerlink" title="同步器队列"></a>同步器队列</h1><p>一个同步器里面拥有<strong>一个同步队列</strong>和<strong>多个等待队列</strong>。</p><h2 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2><p>在<code>AbstractQueuedSynchronizer</code>类中，有一个内部类<code>Node</code>，通过该类构造一个内部的同步队列，这是一个<strong>FIFO 双向队列</strong>。<br>当前运行线程回去同步状态时，如果获取失败，则将当前线程信息创建一个<code>Node</code>追加到同步队列尾部，然后阻塞当前线程，直到队列的上一个节点的同步状态释放，再唤醒当前线程尝试重新获取同步状态。这个重新获取同步状态操作的节点，一定要是同步队列中第一节点。</p><p>Node 源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 共享模式下等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">SHARED</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="comment">// 独占模式下等待的标记</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">EXCLUSIVE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 等待状态常量值，以下四个常量都是</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CANCELLED</span> <span class="operator">=</span>  <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIGNAL</span>    <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CONDITION</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PROPAGATE</span> <span class="operator">=</span> -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待状态</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点的前驱节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前节点的后继节点</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取同步状态的线程（引用）</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待队列中的后继节点</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否共享模式</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isShared</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取前驱节点</span></span><br><span class="line">    <span class="keyword">final</span> Node <span class="title function_">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;    <span class="comment">// Used to establish initial head or SHARED marker</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, Node mode) &#123;     <span class="comment">// Used by addWaiter</span></span><br><span class="line">        <span class="built_in">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node(Thread thread, <span class="type">int</span> waitStatus) &#123; <span class="comment">// Used by Condition</span></span><br><span class="line">        <span class="built_in">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="built_in">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过以上代码，可以看到节点中保存了节点模式、等待状态、线程引用、前驱和后继节点，构造节点。</p><p>同步队列中被阻塞的线程的等待状态包含有四个常量值：CANCELLED、SIGNAL、CONDITION、PROPAGATE ，它们对应的被阻塞原因如下：</p><ul><li><code>CANCELLED</code> 同步队列中当前节点的线程等待超时或被中断，需要从同步队列中取消等待。</li><li><code>SIGNAL</code> 当前节点释放同步状态或被取消后，通知后继节点的线程运行。</li><li><code>CONDITION</code> 当前节点在 Condition 上等待，当其他线程对 Condition 调用了 signal() 方法后，该节点将添加到同步队列中。</li><li><code>PROPAGATE</code> 该状态存在共享模式的首节点中，当前节点唤醒后将传播唤醒其他节点。</li></ul><p>同步器中持有同步队列的首节点和尾节点的引用，在<code>AbstractQueuedSynchronizer</code>中分别对应<code>head</code>和<code>tail</code>字段。</p><p><img src="https://images.ytao.top/aqs-aqs-fields.png"></p><p>所以同步队列的基本结构如图：</p><p><img src="https://images.ytao.top/aqs-fifo-struct.png"></p><h2 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h2><p><code>AbstractQueuedSynchronizer</code>类中包含一个内部类<code>ConditionObject</code>，该类实现了<code>Condition</code>的接口。一个<code>Condition</code>对象包含一个等待队列，同时<code>Condition</code>对象可以实现等待&#x2F;通知功能。</p><p><code>Condition</code>持有等待队列中的首节点（firstWaiter）和尾节点（lastWaiter），如下图代码所示：</p><p><img src="https://images.ytao.top/aqs-ConditionObject-code.png"></p><p>如果当前线程调用<code>Condition.await()</code>时，会将当前线程信息构建一个 Node 节点，因为<code>Condition</code>持有等待队列中的首尾节点，所以将当前等待队列中的尾节点的<code>nextWaiter</code>指向当前线程构建的节点，同时更新<code>lastWaiter</code>的引用节点。</p><p>上述过程中的节点、队列的操作，是获取到锁的线程来调用<code>Condition.await()</code>的，所以整个执行过程在没有基于 CAS 的情况下，也是线程安全的。</p><p>通过以上的描述，可以知道一个同步器中同步队列、等待队列构成的示意图：</p><p><img src="https://images.ytao.top/aqs-syncQueue-waitQueue.png"></p><p>当调用<code>Condition.await()</code>时，同步队列中的首节点，也就是当前线程所创建的节点，会加入到等待队列中的尾部，释放当前线程的同步状态并且唤醒同步队列的后继节点，当前线程也就进入等待状态，这个先后顺序不能颠倒。<strong>这个过程相当于同步队列的首节点的线程构造新的节点加入到等待队列的尾部。</strong></p><p><img src="https://images.ytao.top/aqs-syncQueue-waitQueue-wait.png"></p><p>当调用<code>Condition.signal()</code>方法时，会先将等待队列中首节点转移到同步队列尾部，然后唤醒该同步队列中的线程，该线程从<code>Condition.await()</code>中自旋退出，接着在在同步器的<code>acquireQueued()</code>中自旋获取同步状态。</p><p><img src="https://images.ytao.top/aqs-syncQueue-waitQueue-signal.png"></p><p>当调用<code>Condition.wait()</code>方法，同步队列首节点转移到等待队列方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">// 如果线程已中断，则抛出中断异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InterruptedException</span>();</span><br><span class="line">    <span class="comment">// 添加节点到等待队列中</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addConditionWaiter();</span><br><span class="line">    <span class="comment">// 修改 state 来达到释放同步状态，避免死锁</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">savedState</span> <span class="operator">=</span> fullyRelease(node);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">interruptMode</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断当前节点是否在同步队列中</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 继续获取同步状态竞争</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="literal">null</span>) <span class="comment">// 清除已取消的节点</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>) <span class="comment">// 被中断时的处理</span></span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面<code>addc</code>方法是向等待队列中添加一个新的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">addConditionWaiter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取等待队列中尾节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> lastWaiter;</span><br><span class="line">    <span class="comment">// 如果最后一个节点已取消，则清除取消节点</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用当前线程信息创建等待队列的节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (t == <span class="literal">null</span>) <span class="comment">// 如果最后尾节点为空，当前节点则为等待队列的首节点</span></span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 否则将当前尾节点的下一个节点指向当前线程信息所构造的节点</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;  <span class="comment">// 更新 Condition 的尾节点引用</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用<code>Condition.signal()</code>方法，等待队列首节点转移到同步队列方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 是否被当前线程所独占</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">    <span class="comment">// 获取等待队列中首节点</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">first</span> <span class="operator">=</span> firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 转移到同步队列，然后唤醒该节点</span></span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转移同步队列首节点到同步队列，并唤醒该节点方法<code>doSignal()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSignal</span><span class="params">(Node first)</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="literal">null</span>)</span><br><span class="line">          lastWaiter = <span class="literal">null</span>;</span><br><span class="line">          <span class="comment">// 去除首节点</span></span><br><span class="line">          first.nextWaiter = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp; <span class="comment">// 从等待队列中转移到同步队列</span></span><br><span class="line">              (first = firstWaiter) != <span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转移等待队列到同步队列方法<code>transferForSignal(Node node)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">transferForSignal</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// 验证节点是否被取消</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 转移节点至同步队列</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> enq(node);</span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待队列中的头结点线程安全移动到同步队列方法<code>enq(final Node node)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Node <span class="title function_">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="comment">// 同步队列中如果为空，则初始化同步器</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> <span class="title class_">Node</span>()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则新节点的前驱节点为当前同步队列的尾节点</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// 设置当前新节点为同步队列的尾节点，并更新先前同步队列的尾节点的后继节点指向当前新节点</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="独占式同步状态"><a href="#独占式同步状态" class="headerlink" title="独占式同步状态"></a>独占式同步状态</h1><p>独占式同步状态获取和释放是线程安全的操作，一个时间点确保只有一个线程获取到同步状态。</p><h2 id="独占式同步状态获取"><a href="#独占式同步状态获取" class="headerlink" title="独占式同步状态获取"></a>独占式同步状态获取</h2><p><code>acquire(int arg)</code>方法是获取独占式同步状态的方法，当线程获取同步失败时，会加入到同步队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，当执行<code>tryAcquire(int arg)</code>方法获取同步状态失败时，接着通过<code>addWaiter(Node.EXCLUSIVE)</code>构造当前线程信息的节点，随后将新构造的节点通过<code>acquireQueued(final Node node, int arg)</code>方法加入到同步队列中，节点在同步队列中自旋等待获取同步状态。</p><p><code>tryAcquire(int arg)</code>是自定义同步器实现的，实现该方法需要保证线程安全获取同步状态，前面讲到<code>AQS</code>提供的<code>compareAndSetState(int expect, int update)</code>方法通过<code>CAS</code>设置<code>state</code>值来保证线程安全。</p><p>上面获取独占式同步状态时，主要分析<code>acquireQueued(final Node node, int arg)</code>方法，节点加入队列并自旋等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 是否中断标识</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// 如果前驱节点是首节点，并且当前节点获取到同步状态</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">// 将当前节点设置为首节点</span></span><br><span class="line">                setHead(node);</span><br><span class="line">                <span class="comment">// 将原首节点（即当前节点的前驱节点）引用清空，利于 GC 回收</span></span><br><span class="line">                p.next = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 成功获取到同步状态标志</span></span><br><span class="line">                failed = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断前驱节点是否超时或取消，以及当前线程是否被中断</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果被中断，则节点出队</span></span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在首节点释放同步状态后，同时唤醒后继节点。后继节点通过自旋的方式（这里利用死循环方式）也会检查自己的前驱节点是否为首节点，如果是前驱节点则会尝试获取同步状态。获取成功则返回，否则判断是否被中断或者继续自旋上述获取同步状态操作。</p><h2 id="独占式同步状态释放"><a href="#独占式同步状态释放" class="headerlink" title="独占式同步状态释放"></a>独占式同步状态释放</h2><p><code>release(int arg)</code>方法是释放同步状态，当释放同步状态后会唤醒后继节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tryRelease(int arg)</code>方法同样也是自定义同步器实现。当首节点不为空且处于等待状态时，那么调用<code>unparkSuccessor(Node node)</code>方法唤醒后继节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">unparkSuccessor</span><span class="params">(Node node)</span> &#123;</span><br><span class="line">    <span class="comment">// CAS 设置等待状态为初始状态</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Node</span> <span class="variable">s</span> <span class="operator">=</span> node.next;</span><br><span class="line">    <span class="comment">// 如果当前释放同步状态的节点不存在后继节点或后继节点超时/被中断</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 从尾节点中开始寻找等待状态的节点作为新首节点，这里已排除当前节点（t != node）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">t</span> <span class="operator">=</span> tail; t != <span class="literal">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="literal">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放同步状态的整个过程就是：释放同步状态，唤醒后继节点。这个后继节点必须满足，非空、非当前节点、等待状态小于或等于 0 ，即<code>SIGNAL</code>、<code>CONDITION</code>、<code>PROPAGATE</code>和初始化状态。</p><p>独占式资源共享方式除了上面的同步状态获取，还有<strong>独占式超时获取</strong>使用的方法是<code>doAcquireNanos(int arg, long nanosTimeout)</code>、<strong>独占式可中断获取</strong>使用的方法是<code>acquireInterruptibly(int arg)</code>。</p><h1 id="共享式同步状态"><a href="#共享式同步状态" class="headerlink" title="共享式同步状态"></a>共享式同步状态</h1><p>共享式同步状态同一时间点可以有多个线程获取到同步状态。</p><h2 id="共享式同步状态获取"><a href="#共享式同步状态获取" class="headerlink" title="共享式同步状态获取"></a>共享式同步状态获取</h2><p><code>acquireShared(int arg)</code>方法是共享式同步状态获取的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 获取同步状态失败后调用的方法</span></span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>tryAcquireShared(int arg)</code>方法是自定义同步器实现的，返回大于或等于 0 时，表示获取成功。如果小于 0 时，获取同步状态失败后会调用<code>doAcquireShared(int arg)</code>方法进行再次尝试获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doAcquireShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;、</span><br><span class="line">    <span class="comment">// 构造一个当前线程信息的新节点</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> addWaiter(Node.SHARED);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">failed</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">interrupted</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 自旋式获取同步状态</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">p</span> <span class="operator">=</span> node.predecessor();</span><br><span class="line">            <span class="comment">// 判断新节点的前驱节点是否为首节点</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">// 再次尝试获取同步状态</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 获取成功后退出自旋</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="literal">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，当获取同步状态失败后，则创建一个共享模式类型的节点，然后自旋式获取同步状态，如果前驱节点为首节点时则尝试再次获取同步状态，获取同步状态成功后退出当前自旋。</p><h2 id="共享式释放同步状态"><a href="#共享式释放同步状态" class="headerlink" title="共享式释放同步状态"></a>共享式释放同步状态</h2><p><code>releaseShared(int arg)</code>方法来释放共享式同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 同步状态释放成功后，唤醒后面等待状态的节点</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面<code>tryReleaseShared(int arg)</code>释放同步状态方法必须保证线程安全，因为它多个线程获取到同步状态时会引发并发操作，可以通过循环操作和 CAS 来确保安前行。</p><p><code>doReleaseShared()</code>方法唤醒后续等待状态的节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doReleaseShared</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="literal">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ws</span> <span class="operator">=</span> h.waitStatus;</span><br><span class="line">            <span class="comment">// 验证后继节点的线程处于等待状态</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="comment">// 再次检查后继节点的线程是否处于等待状态</span></span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;   </span><br><span class="line">                <span class="comment">// 唤醒后继节点，这时每唤醒一次就更新一次首节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                      !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>共享同步状态释放后，自旋式依次唤醒队列中节点。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>从 AQS 中可以借鉴它利用循环和 CAS 来确保并发的安全性的思路，同时它采用模板设计模式定义一个处理逻辑，将具体的特定处理逻辑交由子类自定义实现。在 ReentrantLock、ReentrantReadWriteLock、Semaphore、CountDownLatch 以及 Tomncat 的 LimitLatch 都有用其作为同步器。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://images.ytao.top/20200627230025.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AQS&lt;/code&gt;即&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;类称作队列同步器，是构建其他同步器的一个重要的基础框架，同步器自身是没有实现任何同步接口。它是通过控制一个&lt;code&gt;int&lt;/code&gt;类型的&lt;code&gt;state&lt;/code&gt;变量来表示同步状态，使用一个内置的&lt;code&gt;FIFO&lt;/code&gt;（先进先出）队列来构建工作队列操作。&lt;/p&gt;
&lt;p&gt;同步器定义有两种资源共享方式：&lt;code&gt;Exclusive&lt;/code&gt;（独占式）和&lt;code&gt;Share&lt;/code&gt;（共享式）的获取同步状态。&lt;/p&gt;
&lt;p&gt;独占式：一个时间点只能执行一个线程。&lt;br&gt;共享式：一个时间点可多个线程同时执行。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://ytao.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://ytao.top/tags/Java/"/>
    
    <category term="多线程" scheme="https://ytao.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    <category term="AQS" scheme="https://ytao.top/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>synchronized 原理知多少</title>
    <link href="https://ytao.top/2020/06/27/28-synchronized/"/>
    <id>https://ytao.top/2020/06/27/28-synchronized/</id>
    <published>2020-06-26T16:00:00.000Z</published>
    <updated>2023-10-10T14:18:14.221Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.ytao.top/20200627225959.jpg"></p><p><code>synchronized</code>是 Java 编程中的一个重要的关键字，也是多线程编程中不可或缺的一员。本文就对它的使用和锁的一些重要概念进行分析。</p><h1 id="使用及原理"><a href="#使用及原理" class="headerlink" title="使用及原理"></a>使用及原理</h1><p>synchronized 是一个重量级锁，它主要实现同步操作，在 Java 对象锁中有三种使用方式：</p><ul><li>普通方法中使用，锁是当前实例对象。</li><li>静态方法中使用，锁是当前类的对象。</li><li>代码块中使用，锁是代码代码块中配置的对象。</li></ul><span id="more"></span><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在代码中使用方法分别如下：</p><p>普通方法使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公众号：ytao</span></span><br><span class="line"><span class="comment"> * 博客：https://ytao.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedMethodDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态方法使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公众号：ytao</span></span><br><span class="line"><span class="comment"> * 博客：https://ytao.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedMethodDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticDemo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码块中使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公众号：ytao</span></span><br><span class="line"><span class="comment"> * 博客：https://ytao.top</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (SynchronizedDemo.class)&#123;</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>方法和代码块的实现原理使用不同方式：</p><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><p>每个对象都拥有一个<code>monitor</code>对象，代码块的<code>&#123;&#125;</code>中会插入<code>monitorenter</code>和<code>monitorexit</code>指令。当执行<code>monitorenter</code>指令时，会进入<code>monitor</code>对象获取锁，当执行<code>monitorexit</code>命令时，会退出<code>monitor</code>对象释放锁。同一时刻，只能有一个线程进入在<code>monitorenter</code>中。</p><p>先将<code>SynchronizedDemo.java</code>使用<code>javac SynchronizedDemo.java</code>命令将其编译成<code>SynchronizedDemo.class</code>。然后使用<code>javap -c SynchronizedDemo.class</code>反编译字节码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Compiled from <span class="string">&quot;SynchronizedDemo.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedDemo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SynchronizedDemo</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: aload_0</span><br><span class="line">       <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">       <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">       <span class="number">0</span>: ldc           #<span class="number">2</span>                  <span class="comment">// class SynchronizedDemo</span></span><br><span class="line">       <span class="number">2</span>: dup</span><br><span class="line">       <span class="number">3</span>: astore_1</span><br><span class="line">       <span class="number">4</span>: monitorenter  <span class="comment">// 进入 monitor</span></span><br><span class="line">       <span class="number">5</span>: aload_1</span><br><span class="line">       <span class="number">6</span>: monitorexit  <span class="comment">// 退出 monitor</span></span><br><span class="line">       <span class="number">7</span>: goto          <span class="number">15</span></span><br><span class="line">      <span class="number">10</span>: astore_2</span><br><span class="line">      <span class="number">11</span>: aload_1</span><br><span class="line">      <span class="number">12</span>: monitorexit  <span class="comment">// 退出 monitor</span></span><br><span class="line">      <span class="number">13</span>: aload_2</span><br><span class="line">      <span class="number">14</span>: athrow</span><br><span class="line">      <span class="number">15</span>: <span class="keyword">return</span></span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           <span class="number">5</span>     <span class="number">7</span>    <span class="number">10</span>   any</span><br><span class="line">          <span class="number">10</span>    <span class="number">13</span>    <span class="number">10</span>   any</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面反编码后的代码，有两个<code>monitorexit</code>指令，一个插入在异常位置，一个插入在方法结束位置。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法中的<code>synchronized</code>与代码块中实现的方式不同，方法中会添加一个叫<code>ACC_SYNCHRONIZED</code>的标志，当调用方法时，首先会检查是否有<code>ACC_SYNCHRONIZED</code>标志，如果存在，则获取<code>monitor</code>对象，调用<code>monitorenter</code>和<code>monitorexit</code>指令。</p><p>通过<code>javap -v -c SynchronizedMethodDemo.class</code>命令反编译<code>SynchronizedMethodDemo</code>类。<code>-v</code>参数即<code>-verbose</code>，表示输出反编译的附加信息。下面以反编译普通方法为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">Classfile /E:/SynchronizedMethodDemo.<span class="keyword">class</span></span><br><span class="line">  <span class="title class_">Last</span> modified <span class="number">2020</span>-<span class="number">6</span>-<span class="number">28</span>; size <span class="number">381</span> bytes</span><br><span class="line">  MD5 checksum 55ca2bbd9b6939bbd515c3ad9e59d10c</span><br><span class="line">  Compiled from <span class="string">&quot;SynchronizedMethodDemo.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SynchronizedMethodDemo</span></span><br><span class="line">  minor version: <span class="number">0</span></span><br><span class="line">  major version: <span class="number">52</span></span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #<span class="number">1</span> = Methodref          #<span class="number">5.</span>#<span class="number">13</span>         <span class="comment">// java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   #<span class="number">2</span> = Fieldref           #<span class="number">14.</span>#<span class="number">15</span>        <span class="comment">// java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   #<span class="number">3</span> = Methodref          #<span class="number">16.</span>#<span class="number">17</span>        <span class="comment">// java/io/PrintStream.println:()V</span></span><br><span class="line">   #<span class="number">4</span> = Class              #<span class="number">18</span>            <span class="comment">// SynchronizedMethodDemo</span></span><br><span class="line">   #<span class="number">5</span> = Class              #<span class="number">19</span>            <span class="comment">// java/lang/Object</span></span><br><span class="line">   #<span class="number">6</span> = Utf8               &lt;init&gt;</span><br><span class="line">   #<span class="number">7</span> = Utf8               ()V</span><br><span class="line">   #<span class="number">8</span> = Utf8               Code</span><br><span class="line">   #<span class="number">9</span> = Utf8               LineNumberTable</span><br><span class="line">  #<span class="number">10</span> = Utf8               demo</span><br><span class="line">  #<span class="number">11</span> = Utf8               SourceFile</span><br><span class="line">  #<span class="number">12</span> = Utf8               SynchronizedMethodDemo.java</span><br><span class="line">  #<span class="number">13</span> = NameAndType        #<span class="number">6</span>:#<span class="number">7</span>          <span class="comment">// &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  #<span class="number">14</span> = Class              #<span class="number">20</span>            <span class="comment">// java/lang/System</span></span><br><span class="line">  #<span class="number">15</span> = NameAndType        #<span class="number">21</span>:#<span class="number">22</span>        <span class="comment">// out:Ljava/io/PrintStream;</span></span><br><span class="line">  #<span class="number">16</span> = Class              #<span class="number">23</span>            <span class="comment">// java/io/PrintStream</span></span><br><span class="line">  #<span class="number">17</span> = NameAndType        #<span class="number">24</span>:#<span class="number">7</span>         <span class="comment">// println:()V</span></span><br><span class="line">  #<span class="number">18</span> = Utf8               SynchronizedMethodDemo</span><br><span class="line">  #<span class="number">19</span> = Utf8               java/lang/Object</span><br><span class="line">  #<span class="number">20</span> = Utf8               java/lang/System</span><br><span class="line">  #<span class="number">21</span> = Utf8               out</span><br><span class="line">  #<span class="number">22</span> = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #<span class="number">23</span> = Utf8               java/io/PrintStream</span><br><span class="line">  #<span class="number">24</span> = Utf8               println</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">SynchronizedMethodDemo</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">demo</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED     <span class="comment">// ACC_SYNCHRONIZED 标志</span></span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         <span class="number">3</span>: invokevirtual #<span class="number">3</span>                  <span class="comment">// Method java/io/PrintStream.println:()V</span></span><br><span class="line">         <span class="number">6</span>: <span class="keyword">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">8</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">10</span>: <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;SynchronizedMethodDemo.java&quot;</span></span><br></pre></td></tr></table></figure><p>上面对代码块和方法的实现方式进行探究：</p><ul><li>代码块通过在编译后的代码中添加<code>monitorenter</code>和<code>monitorexit</code>指令。</li><li>方法中通过添加<code>ACC_SYNCHRONIZED</code>标志，来决定是否调用<code>monitor</code>对象。</li></ul><h1 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h1><p><code>synchronized</code>锁的相关数据存放在 Java 对象头中。Java 对象头指的 HotSpot 虚拟机的对象头，使用2个字宽或3个字宽存储对象头。</p><ul><li>第一部分存储运行时的数据，hashCode、锁标记位、是否偏向锁、GC分代年龄等等信息，称作为<code>Mark Word</code>。</li><li>第二部分存储对象类型数据的指针。</li><li>第三部分，如果对象是数组的话，则用这部分来存储数组长度。</li></ul><p>Java 对象头 Mark Word 存储内容：</p><table><thead><tr><th align="center">存储内容</th><th align="center">标志位</th><th align="center">状态</th></tr></thead><tbody><tr><td align="center">对象的hashCode、GC分代年龄</td><td align="center">01</td><td align="center">无锁</td></tr><tr><td align="center">指向栈中锁记录的指针</td><td align="center">00</td><td align="center">轻量级锁</td></tr><tr><td align="center">指向重量级锁的指针</td><td align="center">10</td><td align="center">重量级锁</td></tr><tr><td align="center">空</td><td align="center">11</td><td align="center">GC标记</td></tr><tr><td align="center">线程ID、Epoch（一个时间戳）、GC分代年龄</td><td align="center">01</td><td align="center">偏向锁</td></tr></tbody></table><h1 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h1><p>synchronized 称为重量级锁，但 Java SE 1.6 为优化该锁的性能而减少获取和释放锁的性能消耗，引入<code>偏向锁</code>和<code>轻量级锁</code>。</p><p>锁的高低级别为：<code>无锁</code>→<code>偏向锁</code>→<code>轻量级锁</code>→<code>重量级锁</code>。</p><p>其中锁的升级是不可逆的，只能由低往高级别升，不能由高往低降。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁是优化在无多线程竞争情况下，提高程序的的运行性能而使用到的锁。在<code>Mark Word</code>中存储一个值，用来标志是否为偏向锁，在 32 位虚拟机和 64 位虚拟机中都是使用一个字节存储，0 为非偏向锁，1 为是偏向锁。</p><p>当第一次被线程获取偏向锁时，会将<code>Mark Word</code>中的偏向锁标志设置为 1，同时使用 CAS 操作来记录这个线程的ID。获取到偏向锁的线程，再次进入获取锁时，只需判断<code>Mark Word</code>是否存储着当前线程ID，如果是，则不需再次进行获取锁操作，而是直接持有该锁。</p><h3 id="撤销锁"><a href="#撤销锁" class="headerlink" title="撤销锁"></a>撤销锁</h3><p>如果有其他线程出现，尝试获取偏向锁，让偏向锁处于竞争状态，那么当前偏向锁就会撤销。<br>撤销偏向锁时，首先会暂停持有偏向锁的线程，并将线程ID设为空，然后检查该线程是否存活：</p><ul><li>当暂停线程非存活，则设置对象头为无锁状态。</li><li>当暂停线程存活，执行偏向锁的栈，最后对象头的保存其他获取到偏向锁的线程ID或者转向无锁状态。</li></ul><p><strong>当确定代码一定执行在多线程访问中时，那么这时的偏向锁是无法发挥到优势，如果继续使用偏向锁就显得过于累赘，给系统带来不必要的性能开销，此时可以设置 JVM 参数<code>-XX:BiasedLocking=false</code>来关闭偏向锁。</strong></p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>代码进入同步块的时候，如果对象头不是锁定状态，JVM 则会在当前线程的栈桢中创建一个<code>锁记录</code>的空间，将锁对象头的<code>Mark Word</code>复制一份到<code>锁记录</code>中，这份复制过来的<code>Mark Word</code>叫做<code>Displaced Mark Word</code>。然后使用 CAS 操作将锁对象头中的<code>Mark Word</code>更新为指向<code>锁记录</code>的指针。如果更新成功，当前线程则会获得锁，如果失败，JVM 先检查锁对象的<code>Mark Word</code>是否指向当前线程，是指向当前线程的话，则当前线程已持有锁，否则存在多线程竞争，当前线程会通过自旋获取锁，这里的自旋可以理解为循环尝试获取锁，所以这过程是消耗 CPU 的过程。当轻量级锁存在竞争状态并自旋获取轻量级锁失败时，轻量级锁就会膨胀为重量级锁，锁对象的<code>Mark Word</code>会更新为指向重量级锁的指针，等待获取锁的线程进入阻塞状态。</p><h3 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h3><p>轻量级锁解锁是使用 CAS 操作将<code>锁记录</code>替换到<code>Mark Word</code>中，如果替换成功，则表示同步操作已完成。如果失败，则表示其他竞争线程尝试过获取该轻量级锁，需要在释放锁的同时，去唤醒其他被阻塞的线程，被唤醒的线程回去再次去竞争锁。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>通过分析<code>synchronized</code>的使用以及 Java SE 1.6 升级优化锁后的设计，可以看出其主要是解决是通过多加入两级相对更轻巧的偏向锁和轻量级锁来优化重量级锁的性能消耗，但是这并不是一定会起到优化作用，主要是解决大多数情况下不存在多线程竞争以及同一线程多次获取锁的的优化，这也是根据平时在编码中多观察多反思得出的权衡方案。</p></blockquote><p><strong>推荐阅读</strong></p><p><a href="https://ytao.top/2020/03/15/18-volatile/">《volatile 手摸手带你解析》</a></p><p><a href="https://ytao.top/2020/05/12/24-thread-wait-notify/">《Java 线程通信之 wait&#x2F;notify 机制》</a></p><p><a href="https://ytao.top/2020/05/17/25-thread-count/">《Java 多线程中使用 JDK 自带工具类实现计数器》</a></p><p><a href="https://ytao.top/2020/04/19/22-thread-base/">《Java 线程基础，从这篇开始》</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://images.ytao.top/20200627225959.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt;是 Java 编程中的一个重要的关键字，也是多线程编程中不可或缺的一员。本文就对它的使用和锁的一些重要概念进行分析。&lt;/p&gt;
&lt;h1 id=&quot;使用及原理&quot;&gt;&lt;a href=&quot;#使用及原理&quot; class=&quot;headerlink&quot; title=&quot;使用及原理&quot;&gt;&lt;/a&gt;使用及原理&lt;/h1&gt;&lt;p&gt;synchronized 是一个重量级锁，它主要实现同步操作，在 Java 对象锁中有三种使用方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通方法中使用，锁是当前实例对象。&lt;/li&gt;
&lt;li&gt;静态方法中使用，锁是当前类的对象。&lt;/li&gt;
&lt;li&gt;代码块中使用，锁是代码代码块中配置的对象。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java" scheme="https://ytao.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://ytao.top/tags/Java/"/>
    
    <category term="多线程" scheme="https://ytao.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 常用查询操作</title>
    <link href="https://ytao.top/2020/06/14/27-mongodb-query/"/>
    <id>https://ytao.top/2020/06/14/27-mongodb-query/</id>
    <published>2020-06-13T16:00:00.000Z</published>
    <updated>2023-10-10T14:18:14.221Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.ytao.top/mongoDB.jpg"></p><blockquote><p>MongoDB 查询操作可实现大部分关系型数据库的常用查询操作，本文对 MongoDB 常用查询进行讲解。</p></blockquote><span id="more"></span><p>在阅读本文前，推荐先阅读<a href="https://ytao.top/2020/05/31/26-mongodb-install-base/">《MongoDB 安装及文档的基本操作》</a></p><p>在进行操作讲解前，先展示当前 MongoDB 中已存在的文档，集合名称<code>article</code><br><img src="https://images.ytao.top/mongodb-query.png"></p><h1 id="条件大小比较操作"><a href="#条件大小比较操作" class="headerlink" title="条件大小比较操作"></a>条件大小比较操作</h1><p>查询文档时，对条件的大小、范围进行过滤查询，以下是常用比较操作符</p><table><thead><tr><th align="center">操作符</th><th>说明</th></tr></thead><tbody><tr><td align="center">$eq</td><td>查询与条件值相等的文档，类似关系型数据库的 &#x3D;</td></tr><tr><td align="center">$ne</td><td>查询与条件值不相等或不存在的文档，类似关系型数据库的 !&#x3D;</td></tr><tr><td align="center">$gt</td><td>查询大于条件值的文档，类似关系型数据库的 &gt;</td></tr><tr><td align="center">$gte</td><td>查询大于或等于条件值的文档，类似关系型数据库的 &gt;&#x3D;</td></tr><tr><td align="center">$lt</td><td>查询小于条件值的文档，类似关系型数据库的 &lt;</td></tr><tr><td align="center">$lte</td><td>查询小于或等于条件值的文档，类似关系型数据库的 &lt;&#x3D;</td></tr><tr><td align="center">$in</td><td>查询 $in 数据里值的文档，类似关系型数据库的 in</td></tr><tr><td align="center">$nin</td><td>与 $in 查询相反，类似关系型数据库的 not in</td></tr></tbody></table><p>由于使用大于、小于、等于关系都差不多，比较好理解，这里就举一个例子说明，使用<code>$gte</code>来获取大于或等于<code>150</code>的 visitor</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.find(&#123;<span class="string">&quot;visitor&quot;</span>: &#123;<span class="variable">$gte</span>:150&#125;&#125;)</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://images.ytao.top/mongodb-query-gte.png"></p><p>使用<code>$in</code>时，必须用数组来设置条件值，比如获取 visitor 为<code>70</code>和<code>150</code>的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.article.find(&#123;<span class="string">&quot;visitor&quot;</span>: &#123;<span class="variable">$in</span>:[70, 150]&#125;&#125;)</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://images.ytao.top/mongodb-query-in.png"></p><h1 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h1><p>多条件查询中，条件与条件连接符号叫做逻辑操作符。常用操作符：</p><table><thead><tr><th align="center">操作符</th><th>说明</th></tr></thead><tbody><tr><td align="center">$and</td><td>表示所有条件同时满足时成立</td></tr><tr><td align="center">$nor</td><td>与<code>$and</code>相反，所有条件都不满足时成立</td></tr><tr><td align="center">$or</td><td>只要有一个条件满足则成立</td></tr><tr><td align="center">$not</td><td>表示字段存在并且不符合条件</td></tr></tbody></table><p><code>$and</code> 查询<code>author=ytao</code>且<code>visitor=150</code>的文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.article.find(</span><br><span class="line">    &#123;<span class="variable">$and</span>:[</span><br><span class="line">      &#123;<span class="string">&quot;author&quot;</span>:&#123;<span class="variable">$eq</span>:<span class="string">&quot;ytao&quot;</span>&#125;&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;visitor&quot;</span>:&#123;<span class="variable">$eq</span>:150&#125;&#125;</span><br><span class="line">    ]&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>$nor</code>查询不是<code>author=ytao</code>和不是<code>visitor=170</code>的文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.article.find(</span><br><span class="line">    &#123;<span class="variable">$nor</span>:[</span><br><span class="line">      &#123;<span class="string">&quot;author&quot;</span>:&#123;<span class="variable">$eq</span>:<span class="string">&quot;ytao&quot;</span>&#125;&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;visitor&quot;</span>:&#123;<span class="variable">$eq</span>:170&#125;&#125;</span><br><span class="line">    ]&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>$or</code>查询<code>author=ytao</code>或<code>visitor=170</code>的文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.article.find(</span><br><span class="line">    &#123;<span class="variable">$or</span>:[</span><br><span class="line">      &#123;<span class="string">&quot;author&quot;</span>:&#123;<span class="variable">$eq</span>:<span class="string">&quot;ytao&quot;</span>&#125;&#125;,</span><br><span class="line">      &#123;<span class="string">&quot;visitor&quot;</span>:&#123;<span class="variable">$eq</span>:170&#125;&#125;</span><br><span class="line">    ]&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>$not</code>查询不是<code>author=ytao</code>的文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.article.find(</span><br><span class="line">    &#123;<span class="string">&quot;author&quot;</span>:&#123;<span class="variable">$not</span>:&#123;<span class="variable">$eq</span>:<span class="string">&quot;ytao&quot;</span>&#125;&#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="元素操作符"><a href="#元素操作符" class="headerlink" title="元素操作符"></a>元素操作符</h1><p>对字段元素上的操作符叫做元素操作符</p><table><thead><tr><th align="center">操作符</th><th>说明</th></tr></thead><tbody><tr><td align="center">$exists</td><td>判断文档中字段是否存在，<code>true</code>为存在，<code>false</code>为不存在</td></tr><tr><td align="center">$type</td><td>筛选指定字段类型的文档</td></tr></tbody></table><p><code>$exists</code>查询<code>author</code>字段存在的文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.article.find(</span><br><span class="line">    &#123;<span class="string">&quot;author&quot;</span>:&#123;<span class="variable">$exists</span>:<span class="literal">true</span>&#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>$type</code>查询<code>author</code>字段为数组的文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.article.find(</span><br><span class="line">    &#123;<span class="string">&quot;author&quot;</span>:&#123;<span class="variable">$type</span>:<span class="string">&quot;array&quot;</span>&#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>MongoDB 支持正则表达式匹配文档，通过正则表达我们可以实现关系型数据库的模糊查询，以及更加强大匹配规则，其使用语法有三种：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; &lt; field &gt;: &#123; <span class="variable">$regex</span>: /pattern/, $ options ： <span class="string">&#x27;&lt;options&gt;&#x27;</span> &#125; &#125;</span><br><span class="line">&#123; &lt; field &gt;: &#123; <span class="variable">$regex</span>: <span class="string">&#x27;pattern&#x27;</span>, $ options ： <span class="string">&#x27;&lt;options&gt;&#x27;</span> &#125; &#125;</span><br><span class="line">&#123; &lt; field &gt;: &#123; <span class="variable">$regex</span>: /pattern/&lt;options&gt; &#125; &#125;</span><br></pre></td></tr></table></figure><p>参数<code>/pattern/</code>和<code>&#39;pattern&#39;</code>都是表示正则表达式，直接添加字符串可用来模糊查询。<br>参数<code>$options</code>为可选参数，有四个固定值选择</p><table><thead><tr><th align="center">options 选项</th><th>说明</th></tr></thead><tbody><tr><td align="center">i</td><td>匹配过程忽略大小写</td></tr><tr><td align="center">x</td><td>匹配过程忽略空格</td></tr><tr><td align="center">m</td><td>匹配多行数据，但都是从每行的起点和结尾匹配</td></tr><tr><td align="center">s</td><td>将多行转换成一行后进行匹配，可匹配换行符<code>\n</code>字符串</td></tr></tbody></table><p>模糊查询<code>author</code>为<code>Tao</code>的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.article.find(</span><br><span class="line">    &#123;<span class="string">&quot;author&quot;</span>:&#123;<span class="variable">$regex</span>:/Tao/, <span class="variable">$options</span>:<span class="string">&#x27;i&#x27;</span>&#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>查询结果</p><p><img src="https://images.ytao.top/mongodb-query-regex.png"></p><p>从上面查询结果中可以看到，数据格式也可以进行匹配到。</p><h1 id="聚合操作"><a href="#聚合操作" class="headerlink" title="聚合操作"></a>聚合操作</h1><p>聚合操作可以实现分组、排序、分页、多集合关联查询等，使用语法格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate([</span><br><span class="line">    &#123;聚合操作一&#125;,</span><br><span class="line">    &#123;聚合操作二&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h2 id="条件筛选"><a href="#条件筛选" class="headerlink" title="条件筛选"></a>条件筛选</h2><p><strong>$match</strong> 用来进行条件筛选，可以使用一些条件限制来进行查询。</p><p>语法格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.article.aggregate([</span><br><span class="line">    &#123; <span class="variable">$match</span>: &lt;条件&gt; &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>查询<code>author = ytao</code>且<code>visitor &gt; 100</code>的文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.article.aggregate([</span><br><span class="line">    &#123; <span class="variable">$match</span>: &#123;</span><br><span class="line">        <span class="variable">$and</span>: [</span><br><span class="line">            &#123;<span class="string">&quot;author&quot;</span>: &#123;<span class="variable">$eq</span>: <span class="string">&quot;ytao&quot;</span>&#125;&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;visitor&quot;</span>: &#123;<span class="variable">$gt</span>: 100&#125;&#125;</span><br><span class="line">        ]&#125; </span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h2 id="分组操作"><a href="#分组操作" class="headerlink" title="分组操作"></a>分组操作</h2><p><strong>$group</strong> 是分组操作符，类似于关系型数据库中的<code>group by</code>操作。其语法格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$group</span>:&#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;$&lt;分组字段名&gt;&quot;</span>, </span><br><span class="line">            &lt;显示结果的字段名称&gt;:&#123;&lt;运算符&gt;:<span class="string">&quot;$&lt;运算符计算的字段名&gt;&quot;</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>其中运算符如下：</p><table><thead><tr><th align="center">运算符</th><th>说明</th></tr></thead><tbody><tr><td align="center">$avg</td><td>当前组的平均数</td></tr><tr><td align="center">$sum</td><td>当前组的总和</td></tr><tr><td align="center">$min</td><td>当前组的最小值</td></tr><tr><td align="center">$max</td><td>当前组的最大值</td></tr><tr><td align="center">$first</td><td>当前组的第一个的值</td></tr><tr><td align="center">$last</td><td>当前组的最后一个的值</td></tr><tr><td align="center">$push</td><td>数组形式展示指定的当前组字段值</td></tr><tr><td align="center">$addToSet</td><td>数组形式展示指定的当前组字段不重复值</td></tr></tbody></table><p>分组求出每个<code>author</code>的<code>visitor</code>平均数的例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.article.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$group</span>:&#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span>:<span class="string">&quot;<span class="variable">$author</span>&quot;</span>, </span><br><span class="line">            <span class="string">&quot;avg_visitor&quot;</span>:&#123;<span class="variable">$sum</span>:<span class="string">&quot;<span class="variable">$visitor</span>&quot;</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><h2 id="字段显示"><a href="#字段显示" class="headerlink" title="字段显示"></a>字段显示</h2><p>指定查询后返回的字段使用**$project**，字段指定默认值为<code>0</code>，但是<code>_id</code>默认为<code>1</code>，显示指定字段语法为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$project</span>:&#123;</span><br><span class="line">            <span class="string">&quot;&lt;字段名&gt;&quot;</span>: &lt;0或1&gt;, </span><br><span class="line">            <span class="string">&quot;&lt;字段名&gt;&quot;</span>:&lt;0或1&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>展示<code>title</code>和<code>visitor</code>字段示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.article.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$project</span>:&#123;</span><br><span class="line">            <span class="string">&quot;_id&quot;</span>: 0, </span><br><span class="line">            <span class="string">&quot;title&quot;</span>: 1,</span><br><span class="line">            <span class="string">&quot;visitor&quot;</span>: 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>同时，<code>$project</code>还以搭配<code>$split</code>(字符串拆分)、<code>$substr</code>(截取字符串)、<code>$concat</code>(合并字符串)、<code>$switch</code>(条件判断)、<code>$toLower</code>(转换成小写)、<code>$toUpper</code>(转换成大写)、时间格式处理等等操作符进行操作，语法为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$project</span>:&#123;</span><br><span class="line">            <span class="string">&quot;&lt;字段名&gt;&quot;</span>: &#123;&lt;操作符&gt;: &lt;条件&gt;&#125;, </span><br><span class="line">            <span class="string">&quot;&lt;字段名&gt;&quot;</span>: &#123;&lt;操作符&gt;: &lt;条件&gt;&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>例如将<code>title</code>中的字母都转换成大写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.article.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$project</span>:&#123;</span><br><span class="line">            <span class="string">&quot;titleField&quot;</span>:&#123; <span class="variable">$toUpper</span>:<span class="string">&quot;<span class="variable">$title</span>&quot;</span> &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>返回结果</p><p><img src="https://images.ytao.top/mongodb-query-project.png"></p><h2 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h2><p><strong>$sort</strong>是文档排序操作符，类似关系型数据中的<code>order by</code>指令。<code>$sort</code>排序用<code>1</code>和<code>-1</code>表示正序和倒序。</p><p>语法格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$sort</span>:&#123;</span><br><span class="line">            <span class="string">&quot;&lt;排序字段名&gt;&quot;</span>: &lt;1 或 -1&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>按<code>visitor</code>字段名进行倒序排序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.article.aggregate([</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$sort</span>:&#123;</span><br><span class="line">            <span class="string">&quot;visitor&quot;</span>: -1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>排序结果</p><p><img src="https://images.ytao.top/mongodb-query-sort.png"></p><h2 id="分页操作"><a href="#分页操作" class="headerlink" title="分页操作"></a>分页操作</h2><p>分页使用 <strong>$skip</strong> 和 <strong>$limit</strong> 进行分页操作。<code>$skip</code>表示跳过文档的数量，<code>$limit</code>表示返回的文档数量，这两个指令使用，类似于关系型数据中的<code>limit &lt;start&gt;, &lt;size&gt;</code>分页操作。</p><p>语法格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate([</span><br><span class="line">    &#123;<span class="variable">$skip</span>: &lt;跳过的文档数量&gt;&#125;,</span><br><span class="line">    &#123;<span class="variable">$limit</span>: &lt;返回的文档数量&gt;&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>查询第二页的两条数据示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.article.aggregate([</span><br><span class="line">    &#123;<span class="variable">$skip</span>: 2&#125;,</span><br><span class="line">    &#123;<span class="variable">$limit</span>: 2&#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>返回结果</p><p><img src="https://images.ytao.top/mongodb-query-page.png"></p><h2 id="统计文档数量"><a href="#统计文档数量" class="headerlink" title="统计文档数量"></a>统计文档数量</h2><p><strong>$count</strong>用来统计文档数量，进行条件筛选时。</p><p>语法格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate([</span><br><span class="line">    &#123; <span class="variable">$count</span>: <span class="string">&quot;&lt;显示数量的字段的名称&gt;&quot;</span> &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>统计全部文档数量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.article.aggregate([</span><br><span class="line">    &#123; <span class="variable">$count</span>: <span class="string">&quot;数量&quot;</span> &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>统计结果：</p><p><img src="https://images.ytao.top/mongodb-query-count.png"></p><h2 id="多集合关联查询"><a href="#多集合关联查询" class="headerlink" title="多集合关联查询"></a>多集合关联查询</h2><p><strong>$lookup</strong> 是用来多集合关联查询时使用的，类似于关系型数据库中的联表查询。</p><p>使用语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.collection.aggregate([</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="variable">$lookup</span>: &#123;</span><br><span class="line">            from: &lt;关联的表名&gt;,</span><br><span class="line">            localField: &lt;当前表的关联字段&gt;,</span><br><span class="line">            foreignField: &lt;关联表的关联字段&gt;,</span><br><span class="line">            as: &lt;另一集合嵌入的字段名&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>在进行多集合关联查询演示前，先添加一个集合<code>person</code>，里面添加一条数据：</p><p><img src="https://images.ytao.top/mongodb-query-person-collection.png"></p><p>查询<code>age = 18</code>的集合：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">db.article.aggregate([</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="variable">$lookup</span>: &#123;</span><br><span class="line">            from: <span class="string">&quot;person&quot;</span>,</span><br><span class="line">            localField: <span class="string">&quot;author&quot;</span>,</span><br><span class="line">            foreignField: <span class="string">&quot;author&quot;</span>,</span><br><span class="line">            as: <span class="string">&quot;person_info&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="variable">$match</span>:&#123;</span><br><span class="line">           <span class="string">&quot;person_info.age&quot;</span>: &#123;<span class="variable">$eq</span>: 18&#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>返回结果：</p><p><img src="https://images.ytao.top/mongodb-query-lookup.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对 MongoDB 的常用查询操作进行了解后，可以发现它和关系型数据操作有很多类似的操作思想。对于这些操作的使用，相对也是较为灵活，提供的 API 也是较为强大，几乎能满足大部分使用场景的检索要求。掌握这些查询操作，可以更高效的获取 MongoDB 中的文档。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://images.ytao.top/mongoDB.jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MongoDB 查询操作可实现大部分关系型数据库的常用查询操作，本文对 MongoDB 常用查询进行讲解。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="MongoDB" scheme="https://ytao.top/categories/MongoDB/"/>
    
    
    <category term="MongoDB" scheme="https://ytao.top/tags/MongoDB/"/>
    
    <category term="数据库" scheme="https://ytao.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 安装及文档的基本操作</title>
    <link href="https://ytao.top/2020/05/31/26-mongodb-install-base/"/>
    <id>https://ytao.top/2020/05/31/26-mongodb-install-base/</id>
    <published>2020-05-30T16:00:00.000Z</published>
    <updated>2023-10-10T14:18:14.221Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.ytao.top/mongoDB.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MongoDB 是一个基于分布式文件存储的半结构化的非关系型数据库。在海量数据中，可以较高性能的处理存取操作。它是以 BSON 格式进行数据存储（类似 JSON 格式，但类型更为丰富），因此对于复杂的数据类型，可以较轻松的保存和处理。同时，在非关系型数据库阵容中，相比其他数据库产品，它拥有更丰富的功能，并且与关系型数据库类型，所以对于新手使用也能快速上手。</p><span id="more"></span><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote><p>环境：CentOS 7<br>版本号：4.2.6 企业版<br>版本：免安版（TGZ）</p></blockquote><h2 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h2><p>访问官网链接下载链接：<a href="https://www.mongodb.com/download-center/enterprise">https://www.mongodb.com/download-center/enterprise</a></p><p>我这里使用的是企业版，下载选项如图：</p><p><img src="https://images.ytao.top/mongoDB-download.png"></p><p>下载后得到压缩包 mongodb-linux-x86_64-enterprise-rhel70-4.2.6.tgz</p><p>将下载的压缩包上传至对应目录，然后进行解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; tar -zxvf mongodb-linux-x86_64-enterprise-rhel70-4.2.6.tgz</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>当前使用的是免安版，所以 mongoDB 的配置文件需要自己手动创建。如果使用的是安装版，安装后配置文件会在 &#x2F;etc&#x2F;mongod.conf 中。</p><p>创建配置前，先创建 data、log、run 三个目录，分别对应的数据存储目录、日志目录、进程 ID 保存目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">mkdir</span> -p /var/mongodb/data</span><br><span class="line">&gt; <span class="built_in">mkdir</span> -p /var/mongodb/log</span><br><span class="line">&gt; <span class="built_in">mkdir</span> -p /var/mongodb/run</span><br></pre></td></tr></table></figure><p>创建 mongod.conf 在 &#x2F;var&#x2F;mongodb 目录中，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mongod.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for documentation of all options, see:</span></span><br><span class="line"><span class="comment">#   http://docs.mongodb.org/manual/reference/configuration-options/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># where to write logging data.</span></span><br><span class="line">systemLog:</span><br><span class="line">  destination: file</span><br><span class="line">  logAppend: <span class="literal">true</span></span><br><span class="line">  path: /var/mongodb/log/mongo.log <span class="comment"># 日志文件路径设置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Where and how to store data.</span></span><br><span class="line">storage:</span><br><span class="line">  dbPath: /var/mongodb/data <span class="comment"># 数据存储路径</span></span><br><span class="line">  journal:</span><br><span class="line">    enabled: <span class="literal">true</span></span><br><span class="line"><span class="comment">#  engine:</span></span><br><span class="line"><span class="comment">#  wiredTiger:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># how the process runs</span></span><br><span class="line">processManagement:</span><br><span class="line">  fork: <span class="literal">true</span>  <span class="comment"># fork and run in background</span></span><br><span class="line">  pidFilePath: /var/mongodb/run/mongod.pid  <span class="comment"># location of pidfile  </span></span><br><span class="line">  timeZoneInfo: /usr/share/zoneinfo</span><br><span class="line"></span><br><span class="line"><span class="comment"># network interfaces</span></span><br><span class="line">net:</span><br><span class="line">  port: 27017 <span class="comment"># 端口号</span></span><br><span class="line">  bindIp: 127.0.0.1  <span class="comment"># 监听 IP ，即可访问 IP，默认是本机</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">security:</span><br><span class="line">  authorization: enabled</span><br><span class="line">  </span><br><span class="line"><span class="comment">#operationProfiling:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#replication:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#sharding:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Enterprise-Only Options</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#auditLog:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#snmp:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>配置文件常用基本属性：</p><table><thead><tr><th align="center">属性</th><th>说明</th></tr></thead><tbody><tr><td align="center">systemLog#destination</td><td>日志输出位置，file 或 syslog，使用 file 时，必须指定 path</td></tr><tr><td align="center">systemLog#logAppend</td><td>当实例启动时日志是否追加写入到现有日志中</td></tr><tr><td align="center">systemLog#path</td><td>日志存放路径</td></tr><tr><td align="center">storage#dbPath</td><td>数据存储路径</td></tr><tr><td align="center">storage#journal#enabled</td><td>日志是否永久性，可以用来恢复数据</td></tr><tr><td align="center">processManagement#fork</td><td>是否后台运行服务</td></tr><tr><td align="center">processManagement#pidFilePath</td><td>pid 文件的存储路径</td></tr><tr><td align="center">processManagement#timeZoneInfo</td><td>数据库使用的时区路径</td></tr><tr><td align="center">net#port</td><td>数据使用的端口</td></tr><tr><td align="center">net#bindIp</td><td>监听客户端连接的 IP，即可访问的 IP</td></tr><tr><td align="center">security#authorization</td><td>是否启动权限管控</td></tr></tbody></table><h2 id="服务启停"><a href="#服务启停" class="headerlink" title="服务启停"></a>服务启停</h2><p>将解压后的安装包 bin 路径添加到环境变量 &#x2F;etc&#x2F;profile 中，在 PATH 上进行追加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mongoDB</span></span><br><span class="line">PATH=<span class="variable">$PATH</span>:/usr/local/software/mongoDB/mongodb-linux-x86_64-enterprise-rhel70-4.2.6/bin</span><br></pre></td></tr></table></figure><p>使用 &#x2F;var&#x2F;mongodb&#x2F;mongod.conf 配置文件启动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; mongod -f /var/mongodb/mongodb.conf</span><br></pre></td></tr></table></figure><p>如图所示，则启动成功</p><p><img src="https://images.ytao.top/mongoDB-successfully.png"></p><p>启动完成后，验证是否正常运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; mongo</span><br></pre></td></tr></table></figure><p>如果正常运行，则进入登录页面</p><p><img src="https://images.ytao.top/mongoDB-login-ui.png"></p><p>创建账号，并设置角色为 root</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; use admin</span><br><span class="line">&gt; db.createUser(&#123;user:<span class="string">&quot;xxxx&quot;</span>,<span class="built_in">pwd</span>:<span class="string">&quot;xxxxxx&quot;</span>,roles:[<span class="string">&quot;root&quot;</span>]&#125;)</span><br></pre></td></tr></table></figure><p>设置账号后，重新登录，此时需要进行账号权限校验</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; mongo -u accont -p password</span><br></pre></td></tr></table></figure><p>停止 MongoDB 服务，必须切换到 admin 数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; use admin</span><br><span class="line">&gt; db.shutdownServer()</span><br></pre></td></tr></table></figure><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>在介绍几本操作之前，现将常用的 MongoDB 对象与关系型数据库进行类比，便于更好理解 MongoDB 对象。</p><table><thead><tr><th align="center">MongoDB</th><th>关系型数据库</th></tr></thead><tbody><tr><td align="center">Database（数据库）</td><td>Database（数据库）</td></tr><tr><td align="center">Collection（集合）</td><td>Table（表）</td></tr><tr><td align="center">Document（文档）</td><td>Row（行）</td></tr><tr><td align="center">Field（字段）</td><td>Column（列）</td></tr></tbody></table><h2 id="Database-的操作"><a href="#Database-的操作" class="headerlink" title="Database 的操作"></a>Database 的操作</h2><p>数据创建和选择，都是使用<code>use db</code>命令</p><p>查看所有数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; show dbs</span><br></pre></td></tr></table></figure><p>删除数据库，先选择再删除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; use db</span><br><span class="line">&gt; db.dropDatabase()</span><br></pre></td></tr></table></figure><h2 id="Collection-的操作"><a href="#Collection-的操作" class="headerlink" title="Collection 的操作"></a>Collection 的操作</h2><p>创建集合命令，同时，如果没有先创建集合，插入数据时会自动创建集合</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.createCollection(collectionName, [options])</span><br></pre></td></tr></table></figure><p>其中<code>options</code>为可选参数，主要是数据的校验规则，这里不展开分析。</p><p>查看数据库中所有集合</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; show collections</span><br></pre></td></tr></table></figure><p>选择集合</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.getCollection(collectionName)</span><br><span class="line">或</span><br><span class="line">&gt; db.collectionName</span><br></pre></td></tr></table></figure><p>删除集合</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.collectionName.drop()</span><br></pre></td></tr></table></figure><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>MongoDB 插入方法有 <strong>insertOne()、insertMany()、insert()、save()</strong> 。其中 insert() 功能就包括了 insertOne() 和 insertMany() 功能。</p><h3 id="insertOne"><a href="#insertOne" class="headerlink" title="insertOne"></a>insertOne</h3><p>insertOne() 是向数据库中插入一个文档，语法格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.collect.insertOne(</span><br><span class="line">    &lt;document&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        writeConcern: &lt;document&gt;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>指令 insertOne() 中参数： </p><ul><li>document 参数为 插入的 BSON 数据</li><li>writeConcern 为写入策略，是可选参数</li></ul><p>向 MongoDB 的 ytao 数据库中，插入一条 article 集合的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.article.insertOne(</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">&quot;Dubbo 负载均衡的实现&quot;</span>,</span><br><span class="line">        url: <span class="string">&quot;https://ytao.top/2020/05/02/23-dubbo-loadbalance/&quot;</span>,</span><br><span class="line">        author: <span class="string">&quot;ytao&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>数据库数据为：</p><p><img src="https://images.ytao.top/mongoDB-insertOne-data.png"></p><p><strong>注意：</strong> 如果插入数据时，没指定 _id ，则会自动生成 _id ；如果指定 _id ，则必须 _id 在数据库中存在，否则会报错插入失败。</p><h3 id="insertMany"><a href="#insertMany" class="headerlink" title="insertMany"></a>insertMany</h3><p>insertMany() 方法是一次插入多个文档，语法格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collect.insertMany(</span><br><span class="line">    [&lt;document 1&gt;, &lt;document 2&gt;],</span><br><span class="line">    &#123;</span><br><span class="line">        writeConcern: &lt;document&gt;,</span><br><span class="line">        ordered: &lt;boolean&gt;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参数<code>ordered</code>为是否有序插入文档，可选参数，默认 true。</p><p>向 MongoDB 的 ytao 数据库中，插入了两条 article 集合的数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">db.article.insertMany(</span><br><span class="line">    [</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">&quot;Netty中粘包/拆包处理&quot;</span>,</span><br><span class="line">        url: <span class="string">&quot;https://ytao.top/2019/12/09/10-netty/&quot;</span>,</span><br><span class="line">        author: <span class="string">&quot;ytao&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">&quot;WebSocket实现Web端即时通信&quot;</span>,</span><br><span class="line">        url: <span class="string">&quot;https://ytao.top/2019/11/17/7_websocket/&quot;</span>,</span><br><span class="line">        author: <span class="string">&quot;ytao&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>插入后的数据</p><p><img src="https://images.ytao.top/mongoDB-insertMany-data.png"></p><p>同理，与 insertOne() 相同，插入重复插入已存在的 _id ，否则报错。</p><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>insert() 可以插入单个或多个文档，<strong>这个也是最较为常用的方法</strong>，其语法为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collect.insert(</span><br><span class="line">    &lt;document&gt; or [&lt;document 1&gt;, &lt;document 2&gt;],</span><br><span class="line">    &#123;</span><br><span class="line">        writeConcern: &lt;document&gt;,</span><br><span class="line">        ordered: &lt;boolean&gt;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>插入的文档如果是单个，则类似 insertOne() 的插入方式；如果插入的文档是多个，则类似 insertMany() 的插入方式。其中参数 writeConcern 和 ordered 都是一样。</p><h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><p>save() 也可以进行数据插入，当新插入的 _id 存在时，会将已存在的文档进行覆盖，如果 _id 不存在时，则类似 insertOne() 的方式插入。其操作语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.collect.save(</span><br><span class="line">    &lt;document&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        writeConcern: &lt;document&gt;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>进行更新的方法有 ** updateOne()、updateMany()、update()、replaceOne() 以及 save() **。其中 update() 包括 updateOne() 和 updateMany() 的功能。</p><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>通过 update() 可以更新一个或多个文档，其语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.collection.update(</span><br><span class="line">    &lt;query&gt;,</span><br><span class="line">    &lt;update&gt;,</span><br><span class="line">    &#123;</span><br><span class="line">        upsert: &lt;boolean&gt;,</span><br><span class="line">        multi: &lt;boolean&gt;,</span><br><span class="line">        writeConcern &lt;document&gt;,</span><br><span class="line">        collation: &lt;document&gt;,</span><br><span class="line">        arrayFilters: [&lt;filter1&gt;,&lt;filter2&gt;]</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>update 的参数：</p><ul><li>query：要更新文档的查询条件</li><li>update：要更新的字段</li><li>upsert：默认为 false。当设置 true 时，如果更新的条件没有匹配到数据时，则插入此更新条件。反之，设为 false 时，则不插入。</li><li>multi：默认为 false。当查询条件匹配到多条数据时，如果设置为 true，则会更新所有匹配的数据；如果设置为 false，则更新匹配出的第一条数据。</li><li>writeConcern：和上面 insert 的参数一样。</li><li>collation：更新数据的排序规则。</li><li>arrayFilters：更新数据中数组格式数据的某个特定元素。</li></ul><p>接下来就演示两个例子，一个普通更新，一个带使用 arrayFilters 数据的更新，这个比较难说明，但通过例子就容易理解。</p><p>更新前数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5ed299cee89845fb9ec805e4&quot;</span>),</span><br><span class="line">    <span class="string">&quot;title&quot;</span> : <span class="string">&quot;WebSocket实现Web端即时通信&quot;</span>,</span><br><span class="line">    <span class="string">&quot;url&quot;</span> : <span class="string">&quot;https://ytao.top/2019/11/17/7_websocket/&quot;</span>,</span><br><span class="line">    <span class="string">&quot;author&quot;</span> : <span class="string">&quot;ytao&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>案例一</strong> 将<code>author</code>数据更新为<code>[&quot;杨滔&quot;, &quot;ytao&quot;]</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.article.update(</span><br><span class="line">    &#123;title: <span class="string">&quot;WebSocket实现Web端即时通信&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="variable">$set</span>: &#123;author: [<span class="string">&quot;杨滔&quot;</span>, <span class="string">&quot;ytao&quot;</span>]&#125;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>案例二</strong> 将<code>author</code>数据<code>[&quot;杨滔&quot;, &quot;ytao&quot;]</code>的<code>杨滔</code>更新为<code>YangTao</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.article.update(</span><br><span class="line">    &#123;title: <span class="string">&quot;WebSocket实现Web端即时通信&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="variable">$set</span>: &#123;<span class="string">&quot;author.$[idx]&quot;</span>: <span class="string">&quot;YangTao&quot;</span>&#125;&#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        arrayFilters:[</span><br><span class="line">            &#123;<span class="string">&quot;idx&quot;</span>: &#123;<span class="variable">$eq</span>: <span class="string">&quot;杨滔&quot;</span>&#125;&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>上面<code>idx</code>表示数组中元素的位置。</p><p>更新后的数据</p><p><img src="https://images.ytao.top/mongoDB-update-arrayfilters.png"></p><h3 id="updateOne"><a href="#updateOne" class="headerlink" title="updateOne"></a>updateOne</h3><p>updateOne() 只能更新一个文档，和 update() 使用类似，将<code>multi</code>参数值为 false 一样，这里不再使用案例演示。</p><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.collection.updateOne(</span><br><span class="line">   &lt;filter&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;,</span><br><span class="line">     collation: &lt;document&gt;,</span><br><span class="line">     arrayFilters: [ &lt;filterdocument1&gt;, ... ],</span><br><span class="line">     hint:  &lt;document|string&gt; </span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>hint</code>是<code>4.2.1</code>版本中新增的参数，用于指定更新文档的索引。</p><h3 id="updateMany"><a href="#updateMany" class="headerlink" title="updateMany"></a>updateMany</h3><p>updateMany() 同样和 update() 更新多个文档使用一样。</p><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">db.collection.updateMany(</span><br><span class="line">   &lt;filter&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;,</span><br><span class="line">     collation: &lt;document&gt;,</span><br><span class="line">     arrayFilters: [ &lt;filterdocument1&gt;, ... ],</span><br><span class="line">     hint:  &lt;document|string&gt; </span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="replaceOne"><a href="#replaceOne" class="headerlink" title="replaceOne"></a>replaceOne</h3><p>replaceOne 将一个文档完全覆盖，并且不需要指定 _id。只能覆盖一个文档。</p><p>语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db.collection.replaceOne(</span><br><span class="line">   &lt;filter&gt;,</span><br><span class="line">   &lt;replacement&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;,</span><br><span class="line">     collation: &lt;document&gt;,</span><br><span class="line">     hint: &lt;document|string&gt; </span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="save-1"><a href="#save-1" class="headerlink" title="save"></a>save</h3><p>save() 在更新中是指定 _id 的方式进行文档覆盖。即上文插入中的 save() 用法。</p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除文档的方法有 <strong>deleteOne()、deleteMany()、remove()</strong></p><h3 id="deleteOne"><a href="#deleteOne" class="headerlink" title="deleteOne"></a>deleteOne</h3><p>deleteOne() 一次只能删除一个文档，其语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collection.deleteOne(</span><br><span class="line">   &lt;filter&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">      writeConcern: &lt;document&gt;,</span><br><span class="line">      collation: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>filter</code>为删除文档的过滤条件。</p><h3 id="deleteMany"><a href="#deleteMany" class="headerlink" title="deleteMany"></a>deleteMany</h3><p>deleteMany() 一次可删除多个匹配到的文档，其语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collection.deleteMany(</span><br><span class="line">   &lt;filter&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">      writeConcern: &lt;document&gt;,</span><br><span class="line">      collation: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p>remove() 是删除查询出的文档，其语法有两个：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.collection.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;justOne&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.collection.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     justOne: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;,</span><br><span class="line">     collation: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>justOne</code>参数默认为 false，表示删除全部匹配到的数据；true 表示只删除第一个文档</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>MongoDB 中常用的基本查询有 ** findOne() ** 和 ** find() **。</p><h3 id="findOne"><a href="#findOne" class="headerlink" title="findOne"></a>findOne</h3><p>findOne() 只返回匹配到的第一个文档，语法为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.collection.findOne(</span><br><span class="line">    &lt;query&gt;, </span><br><span class="line">    &lt;projection&gt;</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>query 表示查询条件。</li><li>projection 表示返回的字段（Field）。</li></ul><p>下面查询一个文档，并且只返回<code>title</code>和<code>url</code></p><p><img src="https://images.ytao.top/mongoDB-findOne.png"></p><p>通过指定字段的 value 为 1，即表示查询后返回的字段。</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>find() 是返回所有匹配到的集合，语法为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.collection.find(</span><br><span class="line">    &lt;query&gt;, </span><br><span class="line">    &lt;projection&gt;</span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>下面案例查询查询结果：</p><p><img src="https://images.ytao.top/mongoDB-find.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>本文对 MongoDB 的入门和基本操作进行了简单的了解，在这使用过程中，有点类似关系型数据库操作的影子，所以对有关系型数据库使用经验的人，上手是较为简单的。</p></blockquote><p>更多使用操作，官方文档：<a href="https://docs.mongodb.com/manual/reference/">https://docs.mongodb.com/manual/reference/</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://images.ytao.top/mongoDB.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;MongoDB 是一个基于分布式文件存储的半结构化的非关系型数据库。在海量数据中，可以较高性能的处理存取操作。它是以 BSON 格式进行数据存储（类似 JSON 格式，但类型更为丰富），因此对于复杂的数据类型，可以较轻松的保存和处理。同时，在非关系型数据库阵容中，相比其他数据库产品，它拥有更丰富的功能，并且与关系型数据库类型，所以对于新手使用也能快速上手。&lt;/p&gt;</summary>
    
    
    
    <category term="MongoDB" scheme="https://ytao.top/categories/MongoDB/"/>
    
    
    <category term="MongoDB" scheme="https://ytao.top/tags/MongoDB/"/>
    
    <category term="数据库" scheme="https://ytao.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java 多线程中使用 JDK 自带工具类实现计数器</title>
    <link href="https://ytao.top/2020/05/17/25-thread-count/"/>
    <id>https://ytao.top/2020/05/17/25-thread-count/</id>
    <published>2020-05-16T16:00:00.000Z</published>
    <updated>2023-10-10T14:18:14.221Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.ytao.top/iupmg.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在实际开发过程中，经常遇到需要多线程并行的业务，最后需要进行将各个线程完成的任务进行汇总，但主线程一般会早于子线程结束，如果要想等各个子线程完成后再继续运行主线程，这时就需要对各个线程是否执行完成进行标识，JDK 并发包中就给开发者提供了几个不错的使用工具类。</p><p>接下来将通过 Thread#join 方法以及 CountDownLatch、CyclicBarrier 类进行上面案例方案的分析。</p><span id="more"></span><h1 id="Thread-join-方法"><a href="#Thread-join-方法" class="headerlink" title="Thread#join 方法"></a>Thread#join 方法</h1><p>使用 join() 方法的子线程对象正常执行 run() 中代码，但当前线程会被无超时阻塞，等待执行 join() 方法的线程销毁后，继续执行被阻塞的当前线程。join() 方法阻塞原理是该方法内使用 wait() 方法阻塞，源码如下所示：</p><p><img src="https://images.ytao.top/thread-count-join.png"></p><p>子线程 join() 完成时会调用 notifyAll() 来通知当前线程继续执行接下来的代码。</p><p>假如现在有两个线程产生数据结果，最后将两个线程结果进行相加，如果直接将两个线程执行并进行汇总，如下实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.thread.count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * htpps://ytao.top</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Created by YangTao on 2020/5/17 0017.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinTest</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            map.put(<span class="string">&quot;thread1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;run thread1&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            map.put(<span class="string">&quot;thread2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;run thread2&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;thread1&quot;</span>) + map.get(<span class="string">&quot;thread2&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end....&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://images.ytao.top/thread-count-nojoin.png"></p><p>由于主线程的汇总计算可能早于子线程完成，所以这时获取子线程结果为空指针异常。</p><p>通过增加 join() 方法实现阻塞主线程，等待子线程完成后再进行汇总：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.thread.count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * htpps://ytao.top</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Created by YangTao on 2020/5/17 0017.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JoinTest</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            map.put(<span class="string">&quot;thread1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;run thread1&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            map.put(<span class="string">&quot;thread2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;run thread2&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 两个线程分别调用 join() 方法，使主线程被阻塞</span></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;thread1&quot;</span>) + map.get(<span class="string">&quot;thread2&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end....&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果为：</p><p><img src="https://images.ytao.top/thread-count-hasjoin.png"></p><p>通过结果可以看到子线程汇总求和为 3。此时主线程在两个子线程销毁前都处于等待状态，直至两个销毁后主线程再执行汇总求和，所以两个线程产生的值都已存在。</p><p>同时，子线程 join() 方法可以使当前线程无期限等待，也可以设置最长等待时长 join(long) 方法，无论子线程是否执行完成，当前线程会继续执行后面代码。使用方法加入超时参数即可，其它与 join() 方法使用相同。</p><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><p>CountDownLatch 可以使一个或多个线程等待其他线程完成操作后再继续执行当前线程后面代码。</p><p>CountDownLatch 的使用：首先创建 CountDownLatch 对象，通过传入参数 int 构造 CountDownLatch 对象。该参数是值将要等待的执行点的数量。</p><p>CountDownLatch 中有几个方法：</p><ul><li><strong>getCount()</strong> 返回当前计数器数，即当前剩余的等待数量。官方解释说该方法通常用于调试和测试目的。</li><li><strong>countDown</strong> 每调用一次，计数器便会进行减 1 操作，但计数器必须大于 0。</li><li><strong>await</strong> 该方法会阻塞当前线程，直至计数器为 0 时，就会不再阻塞当前线程。同时也提供 await(long timeout, TimeUnit unit) 方法，可设置超时时间。</li></ul><p>利用 CountDownLatch 实现汇总求和案例，实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.thread.count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://ytao.top</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by YangTao on 2020/5/17 0017.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountDownLatchTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            map.put(<span class="string">&quot;thread1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;run thread1&quot;</span>);</span><br><span class="line">            count.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            map.put(<span class="string">&quot;thread2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;run thread2&quot;</span>);</span><br><span class="line">            count.countDown();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一直阻塞当前线程，直至计数器为 0</span></span><br><span class="line">        count.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;thread1&quot;</span>) + map.get(<span class="string">&quot;thread2&quot;</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;end.... getCount: &quot;</span> + count.getCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://images.ytao.top/thread-count-countdownlatch.png"></p><p>上图中求和结果为 3，同时计数器为 0。</p><p>通过查看 CountDownLatch 源码，主要是通过一个继承 AbstractQueuedSynchronizer 类的内部类 Sync 来实现的，可知其实现原理为 AQS，这里不进行展开讲述。</p><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><p>CyclicBarrier 是一个可循环使用的屏障。实现原理解释，就是在一个或多个线程运行中设置一个屏障，线程到达这个屏障时会被阻塞，直到最后一个线程到达时，被屏障阻塞的线程继续执行。</p><p>CyclicBarrier 构造方法有两个，<code>CyclicBarrier(int count)</code>和<code>CyclicBarrier(int count, Runnable barrierAction)</code>:</p><ul><li>单个<code>int</code>参数构造方法，表示构造到达屏障线程的数量。</li><li>一个<code>int</code>和一个<code>Runnable</code>参数构造方法，前者参数表示到达屏障线程的数量，后者参数表示所有线程到达屏障后接下来要执行的代码;</li></ul><p>CyclicBarrier 中方法：</p><table><thead><tr><th align="center">方法</th><th>说明</th></tr></thead><tbody><tr><td align="center">await()</td><td>阻塞前线程，等待 trip.signal() 或 trip.signalAll() 方法唤醒</td></tr><tr><td align="center">await(long, TimeUnit)</td><td>在 await() 上增加两个参数，等待超时时间 timeout，单位为 unit</td></tr><tr><td align="center">breakBarrier()</td><td>放开屏障，设置标志，唤醒被屏障阻塞的线程</td></tr><tr><td align="center">isBroken()</td><td>阻塞的线程是否被中断</td></tr><tr><td align="center">reset()</td><td>重置 CyclicBarrier 对象</td></tr><tr><td align="center">getNumberWaiting()</td><td>当前被阻塞线程的数量</td></tr><tr><td align="center">getParties()</td><td>到达屏障的线程总数量，即创建时指定的数量</td></tr></tbody></table><p>使用 CyclicBarrier 实现上面汇总：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.thread.count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.BrokenBarrierException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CyclicBarrier;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * https://ytao.top</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by YangTao on 2020/5/17 0017.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CyclicBarrierTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> BrokenBarrierException, InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">CyclicBarrier</span> <span class="variable">barrier</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="comment">// 所有线程到达屏障后，需要执行的代码</span></span><br><span class="line">            System.out.println(map.get(<span class="string">&quot;thread1&quot;</span>) + map.get(<span class="string">&quot;thread2&quot;</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;CyclicBarrier end.... &quot;</span>);</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            map.put(<span class="string">&quot;thread1&quot;</span>, <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;run thread1&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            map.put(<span class="string">&quot;thread2&quot;</span>, <span class="number">2</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;run thread2&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                barrier.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://images.ytao.top/thread-count-cyclicbarrier.png"></p><p>执行完两条子线程，并且在子线程里调用<code>barrier.await()</code>后，屏障被打开，最后执行 CyclicBarrier 的最后的代码逻辑。</p><p>通过上面 CyclicBarrier 的方法可知，CyclicBarrier 比 CountDownLatch 使用更加灵活，CyclicBarrier 的 reset() 方法可以重置计数器，而 CountDownLatch 则只能使用一次。同时，CyclicBarrier 拥有更多线程阻塞信息的方法提供使用，在使用过程中，提供更加灵活的使用方式。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面三种方式，均由 JDK 的并发包中提供的工具。在多线程协作任务中，对计数器场景问题的解决方案，实现 main 线程对 worker 线程的等待完成。在实际开发应用中，使用频率也是非常之高。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://images.ytao.top/iupmg.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在实际开发过程中，经常遇到需要多线程并行的业务，最后需要进行将各个线程完成的任务进行汇总，但主线程一般会早于子线程结束，如果要想等各个子线程完成后再继续运行主线程，这时就需要对各个线程是否执行完成进行标识，JDK 并发包中就给开发者提供了几个不错的使用工具类。&lt;/p&gt;
&lt;p&gt;接下来将通过 Thread#join 方法以及 CountDownLatch、CyclicBarrier 类进行上面案例方案的分析。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://ytao.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://ytao.top/tags/Java/"/>
    
    <category term="线程" scheme="https://ytao.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程通信之 wait/notify 机制</title>
    <link href="https://ytao.top/2020/05/12/24-thread-wait-notify/"/>
    <id>https://ytao.top/2020/05/12/24-thread-wait-notify/</id>
    <published>2020-05-11T16:00:00.000Z</published>
    <updated>2023-10-10T14:18:14.221Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.ytao.top/uiower.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Java 线程通信是将多个独立的线程个体进行关联处理，使得线程与线程之间能进行相互通信。比如线程 A 修改了对象的值，然后通知给线程 B，使线程 B 能够知道线程 A 修改的值，这就是线程通信。</p><span id="more"></span><h1 id="wait-notify-机制"><a href="#wait-notify-机制" class="headerlink" title="wait&#x2F;notify 机制"></a>wait&#x2F;notify 机制</h1><p>一个线程调用 Object 的 wait() 方法，使其线程被阻塞；另一线程调用 Object 的 notify()&#x2F;notifyAll() 方法，wait() 阻塞的线程继续执行。</p><p>wai&#x2F;notify 方法</p><table><thead><tr><th align="center">方法</th><th>说明</th></tr></thead><tbody><tr><td align="center">wait()</td><td>当前线程被阻塞，线程进入 WAITING 状态</td></tr><tr><td align="center">wait(long)</td><td>设置线程阻塞时长，线程会进入 TIMED_WAITING 状态。如果设置时间内（毫秒）没有通知，则超时返回</td></tr><tr><td align="center">wait(long, int)</td><td>纳秒级别的线程阻塞时长设置</td></tr><tr><td align="center">notify()</td><td>通知同一个对象上已执行 wait() 方法且获得对象锁的等待线程</td></tr><tr><td align="center">notifyAll()</td><td>通知同一对象上所有等待的线程</td></tr></tbody></table><p>实现 wait&#x2F;notify 机制的条件：</p><ul><li>调用 wait 线程和 notify 线程必须拥有相同对象锁。</li><li>wait() 方法和 notify()&#x2F;notifyAll() 方法必须在 Synchronized 方法或代码块中。</li></ul><p>由于 wait&#x2F;notify 方法是定义在<code>java.lang.Object</code>中，所以在任何 Java 对象上都可以使用。</p><h1 id="wait-方法"><a href="#wait-方法" class="headerlink" title="wait 方法"></a>wait 方法</h1><p>在执行 wait() 方法前，当前线程必须已获得对象锁。调用它时会阻塞当前线程，进入等待状态，在当前 wait() 处暂停线程。同时，wait() 方法执行后，会立即释放获得的对象锁。</p><p>下面通过案例来查看 wait() 释放锁。</p><p>首先查看不使用 wait() 方法时的代码执行情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.thread.waitnotify;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始线程 A&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;结束线程 A&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始线程 B&quot;</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;结束线程 B&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建 A、B 两个线程，。首先在 B 线程创建后 sleep ，保证 B 线程的打印后于 A 线程执行。在 A 线程中，获取到对象锁后，sleep 一段时间，且时间大于 B 线程的 sleep 时间。</p><p>执行结果为：</p><p><img src="https://images.ytao.top/thread-wait-notify-nowait.png"></p><p>从上图结果中，可以看到，B 线程一定等 A 线程执行完 synchronize 代码块释放对象锁后 A 线程再获取对象锁进入 synchronize 代码块中。在这过程中，Thread.sleep() 方法也不会释放锁。</p><p>当前在 A 线程 synchronize 代码块中执行 wait() 方法后，就会主动释放对象锁，A 线程代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始线程 A&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用 object 对象的 wait 方法</span></span><br><span class="line">            object.wait();</span><br><span class="line">            Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束线程 A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;线程 A&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://images.ytao.top/thread-wait-notify-wait.png"></p><p>同时 A 线程一直处于阻塞状态，不会打印<code>结束线程 A</code>。</p><p>wait(long) 方法是设置超时时间，当等待时间大于设置的超时时间后，会继续往 wait(long) 方法后的代码执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始线程 A&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            object.wait(<span class="number">1000</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;结束线程 A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;线程 A&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>执行结果</p><p><img src="https://images.ytao.top/thread-wait-notify-wait-timeout.png"></p><p>同理，wait(long, int) 方法与 wait(long) 同样，只是多个纳秒级别的时间设置。</p><h1 id="notify-方法"><a href="#notify-方法" class="headerlink" title="notify 方法"></a>notify 方法</h1><p>同样，在执行 notify() 方法前，当前线程也必须已获得线程锁。调用 notify() 方法后，会通知一个执行了 wait() 方法的阻塞等待线程，使该等待线程重新获取到对象锁，然后继续执行 wait() 后面的代码。但是，与 wait() 方法不同，执行 notify() 后，不会立即释放对象锁，而需要执行完 synchronize 的代码块或方法才会释放锁，所以接收通知的线程也不会立即获得锁，也需要等待执行 notify() 方法的线程释放锁后再获取锁。</p><h2 id="notify"><a href="#notify" class="headerlink" title="notify()"></a>notify()</h2><p>下面是 notify() 方法的使用，实现一个完整的 wait&#x2F;notify 的例子，同时验证发出通知后，执行 notify() 方法的线程是否立即释放锁，执行 wait() 方法的线程是否立即获取锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.thread.waitnotify;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始线程 A&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    object.wait();</span><br><span class="line">                    System.out.println(<span class="string">&quot;A 线程重新获取到锁，继续进行&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;结束线程 A&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始线程 B&quot;</span>);</span><br><span class="line">                object.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;线程 B 通知完线程 A&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 试验执行完 notify() 方法后，A 线程是否能立即获取到锁</span></span><br><span class="line">                    Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;结束线程 B&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上 A 线程执行 wait() 方法，B 线程执行 notify() 方法，执行结果为：</p><p><img src="https://images.ytao.top/thread-wait-notify-wait-notify.png"></p><p>执行结果中可以看到，B 线程执行 notify() 方法后，即使 sleep 了，A 线程也没有获取到锁，可知，notify() 方法并没有释放锁。</p><p>notify() 是通知到等待中的线程，但是调用一次 notify() 方法，只能通知到一个执行 wait() 方法的等待线程。如果有多个等待状态的线程，则需多次调用 notify() 方法，通知到线程顺序则根据执行 wait() 方法的先后顺序进行通知。</p><p>下面创建有两个执行 wait() 方法的线程的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.thread.waitnotify;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiWaitNotifyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始线程 A&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    object.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;结束线程 A&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始线程 B&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    object.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;结束线程 B&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;开始通知线程 C&quot;</span>);</span><br><span class="line">                object.notify();</span><br><span class="line">                object.notify();</span><br><span class="line">                System.out.println(<span class="string">&quot;结束通知线程 C&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程 C&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先 A 线程执行 wait() 方法，然后 B 线程执行 wait() 方法，最后 C 线程调用两次 notify() 方法，执行结果：</p><p><img src="https://images.ytao.top/thread-wait-notify-multi-wait-notify.png"></p><h2 id="notifyAll"><a href="#notifyAll" class="headerlink" title="notifyAll()"></a>notifyAll()</h2><p>通知多个等待状态的线程，通过多次调用 notify() 方法实现的方案，在实际应用过程中，实现过程不太友好，如果是想通知所有等待状态的线程，可使用 notifyAll() 方法，就能唤醒所有线程。</p><p>实现方式，只需将上面 C 线程的多次调用 notify() 方法部分改为调用一次 notifyAll() 方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">3000L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (object)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;开始通知线程 C&quot;</span>);</span><br><span class="line">        object.notifyAll();</span><br><span class="line">        System.out.println(<span class="string">&quot;结束通知线程 C&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;线程 C&quot;</span>).start();</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://images.ytao.top/thread-wait-notify-wait-notifyall.png"></p><p>根据不同 JVM 的实现，notifyAll() 的唤醒顺序会有所不同，当前测试环境中，以倒序顺序唤醒线程。</p><h1 id="实现生产者消费者模式"><a href="#实现生产者消费者模式" class="headerlink" title="实现生产者消费者模式"></a>实现生产者消费者模式</h1><p>生产消费者模式就是一个线程生产数据进行存储，另一线程进行数据提取消费。下面就以两个线程来模拟，生产者生成一个 UUID 存放到 List 对象中，消费者读取 List 对象中的数据，读取完成后进行清除。</p><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.thread.waitnotify;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitNotifyModelTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储生产者产生的数据</span></span><br><span class="line">    <span class="keyword">static</span> List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">                    <span class="comment">// 判断 list 中是否有数据，如果有数据的话，就进入等待状态，等数据消费完</span></span><br><span class="line">                    <span class="keyword">if</span> (list.size() != <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            list.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// list 中没有数据时，产生数据添加到 list 中</span></span><br><span class="line">                    list.add(UUID.randomUUID().toString());</span><br><span class="line">                    list.notify();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + list);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;生产者线程 A &quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (list)&#123;</span><br><span class="line">                    <span class="comment">// 如果 list 中没有数据，则进入等待状态，等收到有数据通知后再继续运行</span></span><br><span class="line">                    <span class="keyword">if</span> (list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            list.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 有数据时，读取数据</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + list);</span><br><span class="line">                    list.notify();</span><br><span class="line">                    <span class="comment">// 读取完毕，将当前这条 UUID 数据进行清除</span></span><br><span class="line">                    list.clear();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;消费者线程 B &quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://images.ytao.top/thread-wait-notify-wait-notify-model.png"></p><p>生产者线程运行时，如果已存在未消费的数据，则当前线程进入等待状态，收到通知后，表明数据已消费完，再继续向 list 中添加数据。</p><p>消费者线程运行时，如果不存在未消费的数据，则当前线程进入等待状态，收到通知后，表明 List 中已有新数据被添加，继续执行代码消费数据并清除。</p><p>不管是生产者还是消费者，基于对象锁，一次只能一个线程能获取到，如果生产者获取到锁就校验是否需要生成数据，如果消费者获取到锁就校验是否有数据可消费。</p><p>一个简单的生产者消费者模式就以完成。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>等待&#x2F;通知机制是实现 Java 线程间通信的一种方式，将多线程中，各个独立运行的线程通过相互通信来更高效的协作完成工作，更大效率利用 CPU 处理程序。这也是学习或研究 Java 线程的必学知识点。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://images.ytao.top/uiower.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Java 线程通信是将多个独立的线程个体进行关联处理，使得线程与线程之间能进行相互通信。比如线程 A 修改了对象的值，然后通知给线程 B，使线程 B 能够知道线程 A 修改的值，这就是线程通信。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://ytao.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://ytao.top/tags/Java/"/>
    
    <category term="线程" scheme="https://ytao.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo 负载均衡的实现</title>
    <link href="https://ytao.top/2020/05/02/23-dubbo-loadbalance/"/>
    <id>https://ytao.top/2020/05/02/23-dubbo-loadbalance/</id>
    <published>2020-05-01T16:00:00.000Z</published>
    <updated>2023-10-10T14:18:14.206Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.ytao.top/dubbo.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>负载均衡是指在集群中，将多个数据请求分散在不同单元上进行执行，主要为了提高系统容错能力和加强系统对数据的处理能力。</p><blockquote><p>在 Dubbo 中，一次服务的调用就是对所有实体域 Invoker 的一次筛选过滤，最终选定具体调用的 Invoker。首先在 Directory 中获取全部 Invoker 列表，通过路由筛选出符合规则的 Invoker，最后再经过负载均衡选出具体的 Invoker。所以 Dubbo 负载均衡机制是决定一次服务调用使用哪个提供者的服务。</p></blockquote><span id="more"></span><h1 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h1><p>Dubbo 负载均衡的分析入口是 org.apache.dubbo.rpc.cluster.loadbalance.AbstractLoadBalance 抽象类，查看这个类继承关系。</p><p><img src="https://images.ytao.top/dubbo_loadbalance_abstractloadbalance.png"></p><p>这个被 RandomLoadBalance、LeastActiveLoadBalance、RoundRobinLoadBalance 及 ConsistentHashLoadBalance 类继承，这四个类是 Dubbo 中提供的四种负载均衡算法的实现。</p><table><thead><tr><th align="center">名称</th><th>说明</th></tr></thead><tbody><tr><td align="center">RandomLoadBalance</td><td>随机算法，根据权重设置随机的概率</td></tr><tr><td align="center">LeastActiveLoadBalance</td><td>最少活跃数算法，指请求数和完成数之差，使执行效率高的服务接收更多请求</td></tr><tr><td align="center">RoundRobinLoadBalance</td><td>加权轮训算法，根据权重设置轮训比例</td></tr><tr><td align="center">ConsistentHashLoadBalance</td><td>Hash 一致性算法，相同请求参数分配到相同提供者</td></tr></tbody></table><p>以上则是 Dubbo 提供的四种负载均衡算法。</p><p>从上图中，看到 AbstractLoadBalance 实现了 LoadBalance 接口，同时是一个 SPI 接口，指定默认实现为 RandomLoadBalance 随机算法机制。</p><p><img src="https://images.ytao.top/dubbo_loadbalance_loadbalance.png"></p><p>抽象类 <strong>AbstractLoadBalance</strong> 中，实现了负载均衡通用的逻辑，同时给子类声明了一个抽象方法供子类实现其负载均衡的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractLoadBalance</span> <span class="keyword">implements</span> <span class="title class_">LoadBalance</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> 运行时间（毫秒）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> 预热时间（毫秒）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> 要计算的 Invoker 权重值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculateWarmupWeight</span><span class="params">(<span class="type">int</span> uptime, <span class="type">int</span> warmup, <span class="type">int</span> weight)</span> &#123;</span><br><span class="line">        <span class="comment">// 计算预热时期的权重</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ww</span> <span class="operator">=</span> (<span class="type">int</span>) ((<span class="type">float</span>) uptime / ((<span class="type">float</span>) warmup / (<span class="type">float</span>) weight));</span><br><span class="line">        <span class="comment">// 返回的权重值区间在: 1 ~ weight</span></span><br><span class="line">        <span class="keyword">return</span> ww &lt; <span class="number">1</span> ? <span class="number">1</span> : (ww &gt; weight ? weight : ww);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">select</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> &#123;</span><br><span class="line">        <span class="comment">// 校验 invokers 是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当到达负载均衡流程时，invokers 中只有一个 Invoker 时，直接返回该 Invoker</span></span><br><span class="line">        <span class="keyword">if</span> (invokers.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在不同负载均衡策略中完成具体的实现</span></span><br><span class="line">        <span class="keyword">return</span> doSelect(invokers, url, invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明抽象方法，在子类中具体实现</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">(Invoker&lt;?&gt; invoker, Invocation invocation)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前Invoker配置的权重值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> invoker.getUrl().getMethodParameter(invocation.getMethodName(), WEIGHT_KEY, DEFAULT_WEIGHT);</span><br><span class="line">        <span class="keyword">if</span> (weight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 服务启动时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> invoker.getUrl().getParameter(REMOTE_TIMESTAMP_KEY, <span class="number">0L</span>);</span><br><span class="line">            <span class="keyword">if</span> (timestamp &gt; <span class="number">0L</span>) &#123;</span><br><span class="line">                <span class="comment">// 服务已运行时长</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">uptime</span> <span class="operator">=</span> (<span class="type">int</span>) (System.currentTimeMillis() - timestamp);</span><br><span class="line">                <span class="comment">// 服务预热时间，默认 DEFAULT_WARMUP = 10 * 60 * 1000 ，预热十分钟</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">warmup</span> <span class="operator">=</span> invoker.getUrl().getParameter(WARMUP_KEY, DEFAULT_WARMUP);</span><br><span class="line">                <span class="comment">// 如果服务运行时长小于预热时长，重新计算出预热时期的权重</span></span><br><span class="line">                <span class="keyword">if</span> (uptime &gt; <span class="number">0</span> &amp;&amp; uptime &lt; warmup) &#123;</span><br><span class="line">                    weight = calculateWarmupWeight(uptime, warmup, weight);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保证最后返回的权重值不小于0</span></span><br><span class="line">        <span class="keyword">return</span> weight &gt;= <span class="number">0</span> ? weight : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 AbstractLoadBalance 中，getWeight 和 calculateWarmupWeight 方法是获取和计算当前 Invoker 的权重值。</p><p>getWeight 中获取当前权重值，通过 URL 获取当前 Invoker 设置的权重，如果当前服务提供者启动时间小于预热时间，则会重新计算权重值，对服务进行降权处理，保证服务能在启动初期不分发设置比例的全部流量，健康运行下去。</p><p>calculateWarmupWeight 是重新计算权重值的方法，计算公式为：<code>服务运行时长 / (预热时长 / 设置的权重值)</code>，等价于<code>(服务运行时长 / 预热时长) * 设置的权重值</code>，同时条件<code>服务运行时长 &lt; 预热时长</code>。由该公式可知，预热时长和设置的权重值不变，服务运行时间越长，计算出的值越接近 weight，但不会等于 weight。<br>在返回计算后的权重结果中，对小于1和大于设置的权重值进行了处理，当重新计算后的权重小于1时返回1；处于1和设置的权重值之间时，直接返回计算后的结果；当权重大于设置的权重值时（因为条件限制，不会出现该类情况），返回设置的权重值。所以得出结论：<strong>重新计算后的权重值为 1 ~ 设置的权重值，运行时间越长，计算出的权重值越接近设置的权重值</strong>。</p><h1 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>通过 XML 配置方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 服务级别配置 --&gt;</span><br><span class="line">&lt;dubbo:service <span class="built_in">id</span>=<span class="string">&quot;xXXXService&quot;</span> interface=<span class="string">&quot;top.ytao.service.XXXXService&quot;</span> class=<span class="string">&quot;top.ytao.service.impl.XXXXServiceImpl&quot;</span> loadbalance=<span class="string">&quot;负载策略&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 方法级别配置 --&gt;</span><br><span class="line">&lt;dubbo:service <span class="built_in">id</span>=<span class="string">&quot;xXXXService&quot;</span> interface=<span class="string">&quot;top.ytao.service.XXXXService&quot;</span> class=<span class="string">&quot;top.ytao.service.impl.XXXXServiceImpl&quot;</span>&gt;</span><br><span class="line">    &lt;dubbo:method name=<span class="string">&quot;方法名&quot;</span> loadbalance=<span class="string">&quot;负载策略&quot;</span>/&gt;</span><br><span class="line">&lt;/dubbo:service&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过 Properties 配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo.service.loadbalance=负载策略</span><br></pre></td></tr></table></figure><p>通过注解方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(loadbalance = &quot;负载策略&quot;)</span></span><br></pre></td></tr></table></figure><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>通过 XML 配置方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 服务级别配置 --&gt;</span><br><span class="line">&lt;dubbo:reference <span class="built_in">id</span>=<span class="string">&quot;xXXXService&quot;</span> interface=<span class="string">&quot;top.ytao.service.XXXXService&quot;</span> loadbalance=<span class="string">&quot;负载策略&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 方法级别配置 --&gt;</span><br><span class="line">&lt;dubbo:reference <span class="built_in">id</span>=<span class="string">&quot;xXXXService&quot;</span> interface=<span class="string">&quot;top.ytao.service.XXXXService&quot;</span>&gt;</span><br><span class="line">    &lt;dubbo:method name=<span class="string">&quot;方法名&quot;</span> loadbalance=<span class="string">&quot;负载策略&quot;</span>/&gt;</span><br><span class="line">&lt;/dubbo:reference&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过 Properties 配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dubbo.reference.loadbalance=负载策略</span><br></pre></td></tr></table></figure><p>通过注解配置方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Reference(loadbalance = &quot;负载策略&quot;)</span></span><br></pre></td></tr></table></figure><p>实现方式也可通过 Dubbo-Admin 管理后台进行配置，如图：</p><p><img src="https://images.ytao.top/dubbo_loadbalance_admin.png"></p><h1 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h1><p>加权随机算法负载均衡策略（RandomLoadBalance）是 dubbo 负载均衡的默认实现方式，根据权重分配各个 Invoker 随机选中的比例。这里的意思是：将到达负载均衡流程的 Invoker 列表中的 权重进行求和，然后求出单个 Invoker 权重在总权重中的占比，随机数就在总权重值的范围内生成。</p><p>如图，假如当前有<code>192.168.1.10</code>和<code>192.168.1.11</code>两个负载均衡的服务，权重分别为 4、6 ，则它们的被选中的比例为 2&#x2F;5、3&#x2F;5。</p><p><img src="https://images.ytao.top/dubbo_loadbalance_random.png"></p><p>当生成随机数为 6 时，就会选中<code>192.168.1.11</code>的服务。</p><p>dubbo 中 RandomLoadBalance 的 doSelect 实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomLoadBalance</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalance</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;random&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> &#123;</span><br><span class="line">        <span class="comment">// Invoker 数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> invokers.size();</span><br><span class="line">        <span class="comment">// 标识所有 Invoker 的权重是否都一样</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">sameWeight</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 用一个数组保存每个 Invoker 的权重</span></span><br><span class="line">        <span class="type">int</span>[] weights = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="comment">// 第一个 Invoker 的权重</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">firstWeight</span> <span class="operator">=</span> getWeight(invokers.get(<span class="number">0</span>), invocation);</span><br><span class="line">        weights[<span class="number">0</span>] = firstWeight;</span><br><span class="line">        <span class="comment">// 求和总权重</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalWeight</span> <span class="operator">=</span> firstWeight;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> getWeight(invokers.get(i), invocation);</span><br><span class="line">            <span class="comment">// 保存每个 Invoker 的权重到数组总</span></span><br><span class="line">            weights[i] = weight;</span><br><span class="line">            <span class="comment">// 累加求和总权重</span></span><br><span class="line">            totalWeight += weight;</span><br><span class="line">            <span class="comment">// 如果不是所有 Invoker 的权重都一样，就给标记上 sameWeight = false</span></span><br><span class="line">            <span class="keyword">if</span> (sameWeight &amp;&amp; weight != firstWeight) &#123;</span><br><span class="line">                sameWeight = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算随机数取到的 Invoker，条件是必须总权重大于0，并且每个 Invoker 的权重都不一样</span></span><br><span class="line">        <span class="keyword">if</span> (totalWeight &gt; <span class="number">0</span> &amp;&amp; !sameWeight) &#123;</span><br><span class="line">            <span class="comment">// 基于 0~总数 范围内生成随机数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line">            <span class="comment">// 计算随机数对应的 Invoker</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                offset -= weights[i];</span><br><span class="line">                <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果所有 Invoker 的权重都一样则随机从 Invoker 列表中返回一个</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(ThreadLocalRandom.current().nextInt(length));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是加权随机策略的实现，这里比较主要关注计算生成的随机数对应的 Invoker。通过遍历权重数组，生成的数累减当前权重值，当 offset 为 0 时，就表示 offset 对应当前的 Invoker 服务。</p><p>以生成的随机数为 6 为例，遍历 Invokers 长度：</p><ol><li><p>第一轮：offset &#x3D; 6 - 4 &#x3D; 2 不满足 offset &lt; 0，继续遍历。</p></li><li><p>第二轮：offset &#x3D; 2 - 6 &#x3D; -4 满足 offset &lt; 0，返回当前索引对应的 Invoker。因为 offset 返回负数，表示 offset 落在当前 Invoker 权重的区间里。</p></li></ol><p>加权随机策略并非一定按照比例被选到，理论上调用次数越多，分布的比例越接近权重所占的比例。</p><h1 id="最少活跃数算法"><a href="#最少活跃数算法" class="headerlink" title="最少活跃数算法"></a>最少活跃数算法</h1><p>最小活跃数负载均衡策略（LeastActiveLoadBalance）是从最小活跃数的 Invoker 中进行选择。什么是活跃数呢？活跃数是一个 Invoker 正在处理的请求的数量，当 Invoker 开始处理请求时，会将活跃数加 1，完成请求处理后，将相应 Invoker 的活跃数减 1。找出最小活跃数后，最后根据权重进行选择最终的 Invoker。如果最后找出的最小活跃数相同，则随机从中选中一个 Invoker。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeastActiveLoadBalance</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalance</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;leastactive&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> &#123;</span><br><span class="line">        <span class="comment">// Invoker 数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> invokers.size();</span><br><span class="line">        <span class="comment">// 所有 Invoker 中的最小活跃值都是 -1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leastActive</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 最小活跃值 Invoker 的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leastCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最小活跃值 Invoker 在 Invokers 列表中对应的下标位置</span></span><br><span class="line">        <span class="type">int</span>[] leastIndexes = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="comment">// 保存每个 Invoker 的权重</span></span><br><span class="line">        <span class="type">int</span>[] weights = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="comment">// 总权重</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalWeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 第一个最小活跃数的权重</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">firstWeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最小活跃数 Invoker 列表的权重是否一样</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">sameWeight</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出最小活跃数 Invoker 的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            Invoker&lt;T&gt; invoker = invokers.get(i);</span><br><span class="line">            <span class="comment">// 获取最小活跃数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">active</span> <span class="operator">=</span> RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();</span><br><span class="line">            <span class="comment">// 获取权重</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">afterWarmup</span> <span class="operator">=</span> getWeight(invoker, invocation);</span><br><span class="line">            <span class="comment">// 保存权重</span></span><br><span class="line">            weights[i] = afterWarmup;</span><br><span class="line">            <span class="comment">// 如果当前最小活跃数为-1（-1为最小值）或小于leastActive</span></span><br><span class="line">            <span class="keyword">if</span> (leastActive == -<span class="number">1</span> || active &lt; leastActive) &#123;</span><br><span class="line">                <span class="comment">// 重置最小活跃数</span></span><br><span class="line">                leastActive = active;</span><br><span class="line">                <span class="comment">// 重置最小活跃数 Invoker 的数量</span></span><br><span class="line">                leastCount = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 保存当前 Invoker 在 Invokers 列表中的索引至leastIndexes数组中</span></span><br><span class="line">                leastIndexes[<span class="number">0</span>] = i;</span><br><span class="line">                <span class="comment">// 重置最小活跃数 invoker 的总权重值</span></span><br><span class="line">                totalWeight = afterWarmup;</span><br><span class="line">                <span class="comment">// 记录当前 Invoker 权重为第一个最小活跃数 Invoker 的权重</span></span><br><span class="line">                firstWeight = afterWarmup;</span><br><span class="line">                <span class="comment">// 因为当前 Invoker 重置为第一个最小活跃数 Invoker ，所以标识所有最小活跃数 Invoker 权重都一样的值为 true</span></span><br><span class="line">                sameWeight = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 如果当前最小活跃数和已声明的最小活跃数相等 </span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (active == leastActive) &#123;</span><br><span class="line">                <span class="comment">// 记录当前 Invoker 的位置</span></span><br><span class="line">                leastIndexes[leastCount++] = i;</span><br><span class="line">                <span class="comment">// 累加当前 Invoker 权重到总权重中</span></span><br><span class="line">                totalWeight += afterWarmup;</span><br><span class="line">                <span class="comment">// 如果当前权重与firstWeight不相等，则将 sameWeight 改为 false</span></span><br><span class="line">                <span class="keyword">if</span> (sameWeight &amp;&amp; i &gt; <span class="number">0</span></span><br><span class="line">                        &amp;&amp; afterWarmup != firstWeight) &#123;</span><br><span class="line">                    sameWeight = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果最小活跃数 Invoker 只有一个，直接返回该 Invoker</span></span><br><span class="line">        <span class="keyword">if</span> (leastCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers.get(leastIndexes[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!sameWeight &amp;&amp; totalWeight &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 根据权重随机从最小活跃数 Invoker 列表中选择一个 </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">offsetWeight</span> <span class="operator">=</span> ThreadLocalRandom.current().nextInt(totalWeight);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; leastCount; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">leastIndex</span> <span class="operator">=</span> leastIndexes[i];</span><br><span class="line">                offsetWeight -= weights[leastIndex];</span><br><span class="line">                <span class="keyword">if</span> (offsetWeight &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> invokers.get(leastIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果所有 Invoker 的权重都一样则随机从 Invoker 列表中返回一个</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(leastIndexes[ThreadLocalRandom.current().nextInt(leastCount)]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码的整个逻辑就是，从 Invokers 列表中筛选出最小活跃数的 Invoker，然后类似加权随机算法策略方式选择最终的 Invoker 服务。</p><h1 id="轮询算法"><a href="#轮询算法" class="headerlink" title="轮询算法"></a>轮询算法</h1><p>加权轮询负载均衡策略（RoundRobinLoadBalance）是基于权重来决定轮询的比例。普通轮询会将请求均匀的分布在每个节点，但不能很好调节不同性能服务器的请求处理，所以加权负载均衡来根据权重在轮询机制中分配相对应的请求比例给每台服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoundRobinLoadBalance</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalance</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;roundrobin&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RECYCLE_PERIOD</span> <span class="operator">=</span> <span class="number">60000</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WeightedRoundRobin</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> weight;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">AtomicLong</span> <span class="variable">current</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> lastUpdate;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getWeight</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setWeight</span><span class="params">(<span class="type">int</span> weight)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.weight = weight;</span><br><span class="line">            current.set(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">increaseCurrent</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> current.addAndGet(weight);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sel</span><span class="params">(<span class="type">int</span> total)</span> &#123;</span><br><span class="line">            current.addAndGet(-<span class="number">1</span> * total);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getLastUpdate</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lastUpdate;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLastUpdate</span><span class="params">(<span class="type">long</span> lastUpdate)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.lastUpdate = lastUpdate;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt; methodWeightMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">updateLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * get invoker addr list cached for specified invocation</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * &lt;b&gt;for unit test only&lt;/b&gt;</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invokers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> invocation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; Collection&lt;String&gt; <span class="title function_">getInvokerAddrList</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, Invocation invocation)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">&quot;.&quot;</span> + invocation.getMethodName();</span><br><span class="line">        Map&lt;String, WeightedRoundRobin&gt; map = methodWeightMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.keySet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> &#123;</span><br><span class="line">        <span class="comment">// key 为 接口名+方法名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">&quot;.&quot;</span> + invocation.getMethodName();</span><br><span class="line">        <span class="comment">// 查看缓存中是否存在相应服务接口的信息，如果没有则新添加一个元素到缓存中</span></span><br><span class="line">        ConcurrentMap&lt;String, WeightedRoundRobin&gt; map = methodWeightMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (map == <span class="literal">null</span>) &#123;</span><br><span class="line">            methodWeightMap.putIfAbsent(key, <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, WeightedRoundRobin&gt;());</span><br><span class="line">            map = methodWeightMap.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 总权重</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalWeight</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">maxCurrent</span> <span class="operator">=</span> Long.MIN_VALUE;</span><br><span class="line">        <span class="comment">// 当前时间戳</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 最大 current 的 Invoker</span></span><br><span class="line">        Invoker&lt;T&gt; selectedInvoker = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 保存选中的 WeightedRoundRobin 对象</span></span><br><span class="line">        <span class="type">WeightedRoundRobin</span> <span class="variable">selectedWRR</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 遍历 Invokers 列表</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="comment">// 从缓存中获取 WeightedRoundRobin 对象</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">identifyString</span> <span class="operator">=</span> invoker.getUrl().toIdentityString();</span><br><span class="line">            <span class="type">WeightedRoundRobin</span> <span class="variable">weightedRoundRobin</span> <span class="operator">=</span> map.get(identifyString);</span><br><span class="line">            <span class="comment">// 获取当前 Invoker 对象</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">weight</span> <span class="operator">=</span> getWeight(invoker, invocation);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前 Invoker 没有对应的 WeightedRoundRobin 对象，则新增一个</span></span><br><span class="line">            <span class="keyword">if</span> (weightedRoundRobin == <span class="literal">null</span>) &#123;</span><br><span class="line">                weightedRoundRobin = <span class="keyword">new</span> <span class="title class_">WeightedRoundRobin</span>();</span><br><span class="line">                weightedRoundRobin.setWeight(weight);</span><br><span class="line">                map.putIfAbsent(identifyString, weightedRoundRobin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前 Invoker 权重不等于对应的 WeightedRoundRobin 对象中的权重，则重新设置当前权重到对应的 WeightedRoundRobin 对象中</span></span><br><span class="line">            <span class="keyword">if</span> (weight != weightedRoundRobin.getWeight()) &#123;</span><br><span class="line">                weightedRoundRobin.setWeight(weight);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 累加权重到 current 中</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">cur</span> <span class="operator">=</span> weightedRoundRobin.increaseCurrent();</span><br><span class="line">            <span class="comment">// 设置 weightedRoundRobin 对象最后更新时间</span></span><br><span class="line">            weightedRoundRobin.setLastUpdate(now);</span><br><span class="line">            <span class="comment">// 最大 current 的 Invoker，并赋值给相应的变量</span></span><br><span class="line">            <span class="keyword">if</span> (cur &gt; maxCurrent) &#123;</span><br><span class="line">                maxCurrent = cur;</span><br><span class="line">                selectedInvoker = invoker;</span><br><span class="line">                selectedWRR = weightedRoundRobin;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 累加权重到总权重中</span></span><br><span class="line">            totalWeight += weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 Invokers 列表中的数量不等于缓存map中的数量</span></span><br><span class="line">        <span class="keyword">if</span> (!updateLock.get() &amp;&amp; invokers.size() != map.size()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (updateLock.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 拷贝 map 到 newMap 中</span></span><br><span class="line">                    ConcurrentMap&lt;String, WeightedRoundRobin&gt; newMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, WeightedRoundRobin&gt;();</span><br><span class="line">                    newMap.putAll(map);</span><br><span class="line">                    <span class="comment">// newMap 转化为 Iterator</span></span><br><span class="line">                    Iterator&lt;Entry&lt;String, WeightedRoundRobin&gt;&gt; it = newMap.entrySet().iterator();</span><br><span class="line">                    <span class="comment">// 循环删除超过设定时长没更新的缓存</span></span><br><span class="line">                    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                        Entry&lt;String, WeightedRoundRobin&gt; item = it.next();</span><br><span class="line">                        <span class="keyword">if</span> (now - item.getValue().getLastUpdate() &gt; RECYCLE_PERIOD) &#123;</span><br><span class="line">                            it.remove();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将当前newMap服务缓存中</span></span><br><span class="line">                    methodWeightMap.put(key, newMap);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    updateLock.set(<span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果存在被选中的 Invoker</span></span><br><span class="line">        <span class="keyword">if</span> (selectedInvoker != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算 current = current - totalWeight</span></span><br><span class="line">            selectedWRR.sel(totalWeight);</span><br><span class="line">            <span class="keyword">return</span> selectedInvoker;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正常情况这里不会到达</span></span><br><span class="line">        <span class="keyword">return</span> invokers.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面选中 Invoker 逻辑为：每个 Invoker 都有一个 current 值，初始值为自身权重。在每个 Invoker 中<code>current = current + weight</code>。遍历完 Invoker 后，current 最大的那个 Invoker 就是本次选中的 Invoker。选中 Invoker 后，将本次 current 值计算<code>current = current - totalWeight</code>。 </p><p>以上面<code>192.168.1.10</code>和<code>192.168.1.11</code>两个负载均衡的服务，权重分别为 4、6 。基于选中前<code>current = current + weight</code>、选中后<code>current = current - totalWeight</code>计算公式得出如下</p><table><thead><tr><th align="center">请求次数</th><th align="center">选中前 current</th><th align="center">选中后 current</th><th align="center">被选中服务</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">[4, 6]</td><td align="center">[4, -4]</td><td align="center">192.168.1.11</td></tr><tr><td align="center">2</td><td align="center">[8, 2]</td><td align="center">[-2, 2]</td><td align="center">192.168.1.10</td></tr><tr><td align="center">3</td><td align="center">[2, 8]</td><td align="center">[2, -2]</td><td align="center">192.168.1.11</td></tr><tr><td align="center">4</td><td align="center">[6, 4]</td><td align="center">[-4, 4]</td><td align="center">192.168.1.10</td></tr><tr><td align="center">5</td><td align="center">[0, 10]</td><td align="center">[0, 0]</td><td align="center">192.168.1.11</td></tr></tbody></table><h1 id="一致性-Hash-算法"><a href="#一致性-Hash-算法" class="headerlink" title="一致性 Hash 算法"></a>一致性 Hash 算法</h1><p>一致性 Hash 负载均衡策略（ConsistentHashLoadBalance）是让参数相同的请求分配到同一机器上。把每个服务节点分布在一个环上，请求也分布在环形中。以请求在环上的位置，顺时针寻找换上第一个服务节点。如图所示：</p><p><img src="https://images.ytao.top/dubbo_loadbalance_hash.png"></p><p>同时，为避免请求散列不均匀，dubbo 中会将每个 Invoker 再虚拟多个节点出来，使得请求调用更加均匀。</p><p>一致性 Hash 修改配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- dubbo 默认只对第一个参数进行 <span class="built_in">hash</span> 标识，指定<span class="built_in">hash</span>参数 --&gt;</span><br><span class="line">&lt;dubbo:parameter key=<span class="string">&quot;hash.arguments&quot;</span> value=<span class="string">&quot;1&quot;</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 虚拟节点数量 --&gt;</span><br><span class="line">&lt;dubbo:parameter key=<span class="string">&quot;hash.nodes&quot;</span> value=<span class="string">&quot;200&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>一致性 Hash 实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsistentHashLoadBalance</span> <span class="keyword">extends</span> <span class="title class_">AbstractLoadBalance</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">NAME</span> <span class="operator">=</span> <span class="string">&quot;consistenthash&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hash nodes name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HASH_NODES</span> <span class="operator">=</span> <span class="string">&quot;hash.nodes&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hash arguments name</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">HASH_ARGUMENTS</span> <span class="operator">=</span> <span class="string">&quot;hash.arguments&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;String, ConsistentHashSelector&lt;?&gt;&gt; selectors = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;String, ConsistentHashSelector&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">doSelect</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取请求的方法名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> RpcUtils.getMethodName(invocation);</span><br><span class="line">        <span class="comment">// key = 接口名+方法名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> invokers.get(<span class="number">0</span>).getUrl().getServiceKey() + <span class="string">&quot;.&quot;</span> + methodName;</span><br><span class="line">        <span class="comment">// invokers 的 hashcode</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">identityHashCode</span> <span class="operator">=</span> System.identityHashCode(invokers);</span><br><span class="line">        <span class="comment">// 查看缓存中是否存在对应 key 的数据，或 Invokers 列表是否有过变动。如果没有，则新添加到缓存中，并且返回负载均衡得出的 Invoker</span></span><br><span class="line">        ConsistentHashSelector&lt;T&gt; selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class="line">        <span class="keyword">if</span> (selector == <span class="literal">null</span> || selector.identityHashCode != identityHashCode) &#123;</span><br><span class="line">            selectors.put(key, <span class="keyword">new</span> <span class="title class_">ConsistentHashSelector</span>&lt;T&gt;(invokers, methodName, identityHashCode));</span><br><span class="line">            selector = (ConsistentHashSelector&lt;T&gt;) selectors.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> selector.select(invocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ConsistentHashSelector class ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doSelect 中主要实现缓存检查和 Invokers 变动检查，一致性 hash 负载均衡的实现在这个内部类 ConsistentHashSelector 中实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ConsistentHashSelector</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储虚拟节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, Invoker&lt;T&gt;&gt; virtualInvokers;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 节点数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> replicaNumber;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// invoker 列表的 hashcode，用来判断 Invoker 列表是否变化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> identityHashCode;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 请求中用来作Hash映射的参数的索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span>[] argumentIndex;</span><br><span class="line">    </span><br><span class="line">    ConsistentHashSelector(List&lt;Invoker&lt;T&gt;&gt; invokers, String methodName, <span class="type">int</span> identityHashCode) &#123;</span><br><span class="line">        <span class="built_in">this</span>.virtualInvokers = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Long, Invoker&lt;T&gt;&gt;();</span><br><span class="line">        <span class="built_in">this</span>.identityHashCode = identityHashCode;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> invokers.get(<span class="number">0</span>).getUrl();</span><br><span class="line">        <span class="comment">// 获取节点数</span></span><br><span class="line">        <span class="built_in">this</span>.replicaNumber = url.getMethodParameter(methodName, HASH_NODES, <span class="number">160</span>);</span><br><span class="line">        <span class="comment">// 获取配置中的 参数索引</span></span><br><span class="line">        String[] index = COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, HASH_ARGUMENTS, <span class="string">&quot;0&quot;</span>));</span><br><span class="line">        argumentIndex = <span class="keyword">new</span> <span class="title class_">int</span>[index.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index.length; i++) &#123;</span><br><span class="line">            argumentIndex[i] = Integer.parseInt(index[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="comment">// 获取 Invoker 中的地址，包括端口号</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> invoker.getUrl().getAddress();</span><br><span class="line">            <span class="comment">// 创建虚拟节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; replicaNumber / <span class="number">4</span>; i++) &#123;</span><br><span class="line">                <span class="type">byte</span>[] digest = md5(address + i);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">0</span>; h &lt; <span class="number">4</span>; h++) &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> hash(digest, h);</span><br><span class="line">                    virtualInvokers.put(m, invoker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找出 Invoker</span></span><br><span class="line">    <span class="keyword">public</span> Invoker&lt;T&gt; <span class="title function_">select</span><span class="params">(Invocation invocation)</span> &#123;</span><br><span class="line">        <span class="comment">// 将参数转为字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> toKey(invocation.getArguments());</span><br><span class="line">        <span class="comment">// 字符串参数转换为 md5</span></span><br><span class="line">        <span class="type">byte</span>[] digest = md5(key);</span><br><span class="line">        <span class="comment">// 根据 md5 找出 Invoker</span></span><br><span class="line">        <span class="keyword">return</span> selectForKey(hash(digest, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将参数拼接成字符串</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">toKey</span><span class="params">(Object[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : argumentIndex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">0</span> &amp;&amp; i &lt; args.length) &#123;</span><br><span class="line">                buf.append(args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buf.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用 md5 匹配到对应的 Invoker</span></span><br><span class="line">    <span class="keyword">private</span> Invoker&lt;T&gt; <span class="title function_">selectForKey</span><span class="params">(<span class="type">long</span> hash)</span> &#123;</span><br><span class="line">        <span class="comment">// 找到第一个大于当前 hash 的 Invoker</span></span><br><span class="line">        Map.Entry&lt;Long, Invoker&lt;T&gt;&gt; entry = virtualInvokers.ceilingEntry(hash);</span><br><span class="line">        <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">            entry = virtualInvokers.firstEntry();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// hash 运算</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="title function_">hash</span><span class="params">(<span class="type">byte</span>[] digest, <span class="type">int</span> number)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (((<span class="type">long</span>) (digest[<span class="number">3</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">2</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">16</span>)</span><br><span class="line">                | ((<span class="type">long</span>) (digest[<span class="number">1</span> + number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>) &lt;&lt; <span class="number">8</span>)</span><br><span class="line">                | (digest[number * <span class="number">4</span>] &amp; <span class="number">0xFF</span>))</span><br><span class="line">                &amp; <span class="number">0xFFFFFFFFL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// md5 运算</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] md5(String value) &#123;</span><br><span class="line">        MessageDigest md5;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            md5 = MessageDigest.getInstance(<span class="string">&quot;MD5&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">        md5.reset();</span><br><span class="line">        <span class="type">byte</span>[] bytes = value.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        md5.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> md5.digest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一致 hash 实现过程就是先创建好虚拟节点，虚拟节点保存在 TreeMap 中。TreeMap 的 key 为配置的参数先进行 md5 运算，然后将 md5 值进行 hash 运算。TreeMap 的 value 为被选中的 Invoker。</p><p>最后请求时，计算参数的 hash 值，去从 TreeMap 中获取 Invoker。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Dubbo 负载均衡的实现，技巧上还是比较优雅，可以多多学习其编码思维。在研究其代码时，需要仔细研究其实现原理，否则比较难懂其思想。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://images.ytao.top/dubbo.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;负载均衡是指在集群中，将多个数据请求分散在不同单元上进行执行，主要为了提高系统容错能力和加强系统对数据的处理能力。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Dubbo 中，一次服务的调用就是对所有实体域 Invoker 的一次筛选过滤，最终选定具体调用的 Invoker。首先在 Directory 中获取全部 Invoker 列表，通过路由筛选出符合规则的 Invoker，最后再经过负载均衡选出具体的 Invoker。所以 Dubbo 负载均衡机制是决定一次服务调用使用哪个提供者的服务。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Dubbo" scheme="https://ytao.top/categories/Dubbo/"/>
    
    
    <category term="Dubbo" scheme="https://ytao.top/tags/Dubbo/"/>
    
    <category term="Java" scheme="https://ytao.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java 线程基础，从这篇开始</title>
    <link href="https://ytao.top/2020/04/19/22-thread-base/"/>
    <id>https://ytao.top/2020/04/19/22-thread-base/</id>
    <published>2020-04-18T16:00:00.000Z</published>
    <updated>2023-10-10T14:18:14.206Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.ytao.top/thread-base.png"></p><blockquote><p>线程作为操作系统中最少调度单位，在当前系统的运行环境中，一般都拥有多核处理器，为了更好的充分利用 CPU，掌握其正确使用方式，能更高效的使程序运行。同时，在 Java 面试中，也是极其重要的一个模块。</p></blockquote><span id="more"></span><h1 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h1><p>一个独立运行的程序是一个进程，一个进程中可以包含一个或多个线程，每个线程都有属于自己的一些属性，如堆栈，计数器等等。同时，一个线程在一个时间点上只能运行在一个 CPU 处理器核心上，不同线程之间也可以访问共享变量。线程在运行时，系统给每个线程分配一些 CPU 时间片，CPU 在时间片这段时间运行某个线程，当这个时间片运行完又跳转至下一段时间片线程，CPU 在这些线程中进行高速切换，使得程序像是在同时进行多个线程操作。</p><h1 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h1><p>实现线程常用的两种方式：继承 java.lang.Thread 类、实现 java.lang.Runnable 接口。</p><h2 id="继承-Thread-类方式"><a href="#继承-Thread-类方式" class="headerlink" title="继承 Thread 类方式"></a>继承 Thread 类方式</h2><p>通过实例化 java.lang.Thread 类获得线程。创建 Thread 对象，一般使用继承 Thread 类的方式，然后通过方法重写覆盖 Thread 的某些方法。</p><p>首先创建一个继承 Thread 的子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写 Thread 类中的 run 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// currentThread().getName() 获取当前线程名称</span></span><br><span class="line">        System.out.println(<span class="string">&quot;java.lang.Thread 创建的&quot;</span>+ currentThread().getName() +<span class="string">&quot;线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码 DemoThread 实例化的对象就代表一个线程，通过重写 run 方法，在 run 方法中实现该线程的逻辑实现。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 实例化 DemoThread 得到新创建的线程实例</span></span><br><span class="line">        <span class="type">DemoThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoThread</span>();</span><br><span class="line">        <span class="comment">// 给创建的子线程命名</span></span><br><span class="line">        thread.setName(<span class="string">&quot;DemoThread 子线程&quot;</span>);</span><br><span class="line">        <span class="comment">// 启动线程</span></span><br><span class="line">        thread.start();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过主线程打印信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序执行的主线程中创建子线程，并且命名为<code>DemoThread 子线程</code>，在程序的最后打印主线程打印的信息。调用线程必须调用<code>start()</code>方法，在调用此方法之前，子线程是不存在的，只有<code>start()</code>方法调用后，才是真正的创建了线程。</p><p>执行结果：</p><p><img src="https://images.ytao.top/thread-base-thread-result.png"></p><p>从结果可以看到，由于在主线程中创建了一个子线程，子线程相对于主线程就相当于是一个异步操作，所以打印结果就有可能main线程先于子线程执行打印操作。</p><h2 id="实现-Runnable-接口方式"><a href="#实现-Runnable-接口方式" class="headerlink" title="实现 Runnable 接口方式"></a>实现 Runnable 接口方式</h2><p>由于 Java 是单继承的特性，所以当创建线程的子类继承了其他的类，就无法实现继承操作。这时就可以通过实现 Runnable 接口，来实现线程创建的逻辑。</p><p>首先创建一个实现 Runnable 的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实现 Runnable 中的 run 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;java.lang.Runnable 创建的 &quot;</span>+ Thread.currentThread().getName() +<span class="string">&quot;线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Runnable 接口中定义有一个 run 方法，所以实现 Runnable 接口，就必须实现 run 方法。实际上 java.lang.Thread 类也实现了 Runnable 接口。</p><p><img src="https://images.ytao.top/thread-base-thread-impl.png"></p><p>创建线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Thread 实例，并给将要创建的线程给命名</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DemoRunnable</span>(), <span class="string">&quot;DemoRunnable 子线程&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建一个线程</span></span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;main 线程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果</p><p><img src="https://images.ytao.top/thread-base-runnable-result.png"></p><p>同样也实现了与继承 Thread 方式一样的结果。</p><p>创建 Thread 实例时，向新创建的 Thread 实例中传入了一个实现 Runnable 接口的对象的参数。</p><p><img src="https://images.ytao.top/thread-base-new-thread.png"></p><p>Thread 中初始化 Thread#init 的具体实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span><br><span class="line"><span class="params">                  <span class="type">long</span> stackSize, AccessControlContext acc,</span></span><br><span class="line"><span class="params">                  <span class="type">boolean</span> inheritThreadLocals)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;name cannot be null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给当前创建的 thread 实例中赋值线程名</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="comment">// 将要创建的线程的父线程即当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">parent</span> <span class="operator">=</span> currentThread();</span><br><span class="line">    <span class="comment">// 添加到线程组操作</span></span><br><span class="line">    <span class="type">SecurityManager</span> <span class="variable">security</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (g == <span class="literal">null</span>) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    g.checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (security != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 线程组中添加为启动的线程数</span></span><br><span class="line">    g.addUnstarted();</span><br><span class="line">    <span class="built_in">this</span>.group = g;</span><br><span class="line">    <span class="comment">// 设置父线程的一些属性到当前将要创建的线程</span></span><br><span class="line">    <span class="built_in">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="built_in">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">if</span> (security == <span class="literal">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="built_in">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="built_in">this</span>.inheritedAccessControlContext =</span><br><span class="line">            acc != <span class="literal">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将当前传入 target 的参数，赋值给当前 Thread 对象，使其持有 已实现 Runnable 接口的实例</span></span><br><span class="line">    <span class="built_in">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="literal">null</span>)</span><br><span class="line">        <span class="built_in">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置线程的堆栈大小</span></span><br><span class="line">    <span class="built_in">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给创建的线程一个 id</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码创建 thread 对象时的 init 方法，通过传入 Runnable 的实例对象，thread 对象中就持有该对象。</p><p>创建 thread 对象后，调用 start() 方法，该线程就运行持有 Runnable 实现类对象的 run() 方法。</p><p><img src="https://images.ytao.top/thread-base-thread-run.png"></p><p>例如本文中案例，就会执行 DemoRunnable#run 方法的逻辑。</p><p>这两种方法创建线程的方式，具体使用哪种，根据自身需求选择。如果需要继承其他非 Thread 类，就需要使用 Runnable 接口。</p><h1 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h1><p>Java 线程每个时间点都存在于6种状态中一种。</p><table><thead><tr><th align="center">状态</th><th>描述</th></tr></thead><tbody><tr><td align="center">NEW</td><td>初始状态，thread 对象调用 start() 方法前</td></tr><tr><td align="center">RUNNABLE</td><td>运行状态，线程 start() 后的就绪或运行中</td></tr><tr><td align="center">BLOCKED</td><td>阻塞状态，线程获得锁后的锁定状态</td></tr><tr><td align="center">WAITING</td><td>等待状态，线程进入等待状态，不会被分配时间片，需要等待其他线程来唤醒</td></tr><tr><td align="center">TIME_WAITING</td><td>超时等待状态，同样不分配时间片，当时间达到设定的等待时间后自动唤醒</td></tr><tr><td align="center">TERMINATED</td><td>终止状态，表示当前线程执行完成</td></tr></tbody></table><p>其中 NEW、RUNNABLE、TERMINATED 比较好理解，现在主要针对 BLOCKED、WAITING 和 TIME_WAITING 进行案例讲解。</p><h2 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h2><p><strong>阻塞状态</strong> 是将两个线程之间处于竞争关系，同时在调用 run 时进行加锁。</p><p>首先还是使用上面 Runnable 实现的方式进行改造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 通过对DemoRunnable加同步锁，进行无限循环不退出</span></span><br><span class="line">        <span class="keyword">synchronized</span> (DemoRunnable.class)&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;java.lang.Runnable 创建的 &quot;</span>+ Thread.currentThread().getName() +<span class="string">&quot;线程&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先竞争到 DemoRunnable 类的线程进入 run 会一直执行下去，未竞争到的线程则会一直处于阻塞状态。</p><p>创建两个线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建两个线程测试</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DemoRunnable</span>(), <span class="string">&quot;test-blocked-1&quot;</span>)</span><br><span class="line">                .start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DemoRunnable</span>(), <span class="string">&quot;test-blocked-2&quot;</span>)</span><br><span class="line">                .start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过分析执行后的线程如图：</p><p><img src="https://images.ytao.top/thread-base-state-blocked.png"></p><p>可以得知线程<code>test-blocked-1</code>竞争到 DemoRunnable 类，一直都在运行 while 循环，所以状态为 RUNNABLE。由于 DemoRunnable#run 中加了同步锁锁住 DemoRunnable 类，所以<code>test-blocked-2</code>一直处于 BLOCKED 阻塞状态。</p><h2 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a>WAITING</h2><p><strong>等待状态</strong> 线程是不被分配 CPU 时间片，线程如果要重新被唤醒，必须显示被其它线程唤醒，否则会一直等待下去。</p><p>实现等待状态例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="comment">// 调用 wait 方法，使线程在当前实例上处于等待状态</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;java.lang.Runnable 创建的 &quot;</span>+ Thread.currentThread().getName() +<span class="string">&quot;线程&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">DemoRunnable</span>(), <span class="string">&quot;test-waiting&quot;</span>)</span><br><span class="line">                .start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建该实例线程后，分析 test-waiting 线程，该线程处于 WAITING 状态。</p><p><img src="https://images.ytao.top/thread-base-state-waiting.png"></p><h2 id="TIME-WAITING"><a href="#TIME-WAITING" class="headerlink" title="TIME_WAITING"></a>TIME_WAITING</h2><p><strong>超时等待状态</strong> 线程也是不被分配 CPU 时间片，但是它通过设置的间隔时间后，可以自动唤醒当前线程。也就是说，将等待状态的线程加个时间限制就是超时等待状态。</p><p>只需对上面 WAITING 状态案例增加 wait 时间限制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 增加等待时长</span></span><br><span class="line">                    <span class="built_in">this</span>.wait(<span class="number">1000000</span>, <span class="number">999999</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">&quot;java.lang.Runnable 创建的 &quot;</span>+ Thread.currentThread().getName() +<span class="string">&quot;线程&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析线程结果，可以看到 test-time_waiting 线程处于超时等待状态，使用 sleep 睡眠时，线程也是属于超时等待状态。</p><p><img src="https://images.ytao.top/thread-base-state-time_waiting.png"></p><p>线程状态之间的转换，如图（来源网络）：</p><p><img src="https://images.ytao.top/thread-base-thread-state.jpg"></p><h1 id="Thread-常用方法"><a href="#Thread-常用方法" class="headerlink" title="Thread 常用方法"></a>Thread 常用方法</h1><h2 id="currentThread"><a href="#currentThread" class="headerlink" title="currentThread()"></a>currentThread()</h2><p>currentThread 是获取当前线程实例，返回 Thread 对象，这是一个静态方法，使用如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread();</span><br></pre></td></tr></table></figure><h2 id="start"><a href="#start" class="headerlink" title="start()"></a>start()</h2><p>start 方法是启动线程的入口方法，这个就是上面实现创建线程例子中的 start 方法。</p><h2 id="run"><a href="#run" class="headerlink" title="run()"></a>run()</h2><p>run 方法是线程创建后，线程会主动调用 run 方法执行里面的逻辑。</p><h2 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h2><p>join 方法即线程同步，比如上继承 Thread 方法实现创建线程的例子中，如果在 thread.start() 后调用 thread.join() 方法，则 main 线程打印的信息一定在子线程打印的信息之后。这里的 main 线程会等待子线程执行完后，再继续执行。</p><h2 id="getName"><a href="#getName" class="headerlink" title="getName()"></a>getName()</h2><p>getName 返回线程名称。</p><h2 id="getId"><a href="#getId" class="headerlink" title="getId()"></a>getId()</h2><p>获取线程 Id，这是返回一个 long 类型的 Id 值。</p><h2 id="setDaemon"><a href="#setDaemon" class="headerlink" title="setDaemon()"></a>setDaemon()</h2><p>setDaemon(boolean on) 方法是设置线程类型，setDaemon 接受一个 boolean 类型参数。设置为 true 时，线程类型为守护线程，设置为 false 时，线程类型为用户线程。</p><h2 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h2><p>yield 方法是线程让步，让当前线程进入就绪状态，去执行其它相同优先级的线程，但不一定会执行其他线程，有可能让步后的线程再次被执行。</p><h2 id="setPriority"><a href="#setPriority" class="headerlink" title="setPriority()"></a>setPriority()</h2><p>setPriority(int newPriority) 是设置线程执行的优先级，数值为1~10，默认值为5，数值越大线程越先执行。</p><h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h2><p>interrupt 方法的作用是中断线程，但是它还是会继续运行。它只是表示其他线程给打了个中断标志。</p><h2 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h2><p>interrupted 方法是检查当前线程是否被中断。调用此方法时会清除该线程的中断标志。</p><h2 id="isInterrupted"><a href="#isInterrupted" class="headerlink" title="isInterrupted()"></a>isInterrupted()</h2><p>isInterrupted 方法检测当前线程是否被中断，如果被中断了，也不会清除中断标志。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>本文对线程的常用功能及概念进行了分析，主要是讲解单线程的一些操作，线程操作的使用在生产中是极容易出现问题的，所以在掌握概念和使用后，需要多研究，多思考应用的设计及实现。在掌握多线程操作时，必须对这些的基本使用和概念进行掌握，今后会出进一步对多线程分析的文章。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://images.ytao.top/thread-base.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;线程作为操作系统中最少调度单位，在当前系统的运行环境中，一般都拥有多核处理器，为了更好的充分利用 CPU，掌握其正确使用方式，能更高效的使程序运行。同时，在 Java 面试中，也是极其重要的一个模块。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Java" scheme="https://ytao.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://ytao.top/tags/Java/"/>
    
    <category term="线程" scheme="https://ytao.top/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo 路由机制的实现</title>
    <link href="https://ytao.top/2020/04/12/21-dubbo-router/"/>
    <id>https://ytao.top/2020/04/12/21-dubbo-router/</id>
    <published>2020-04-11T16:00:00.000Z</published>
    <updated>2023-10-10T14:18:14.206Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.ytao.top/dubbo.png"></p><p>Dubbo 路由机制是在服务间的调用时，通过将服务提供者按照设定的路由规则来决定调用哪一个具体的服务。</p><h1 id="路由服务结构"><a href="#路由服务结构" class="headerlink" title="路由服务结构"></a>路由服务结构</h1><p>Dubbo 实现路由都是通过实现 RouterFactory 接口。当前版本 dubbo-2.7.5 实现该接口类如下：</p><span id="more"></span><p><img src="https://images.ytao.top/dubbo-router-factory.png"></p><p>路由实现工厂类是在 router 包下</p><p><img src="https://images.ytao.top/dubbo-router-class.png"></p><p>由于 RouterFactory 是 SPI 接口，同时在获取路由 RouterFactory#getRouter 方法上有 @Adaptive(“protocol”) 注解，所以在获取路由的时候会动态调用需要的工厂类。</p><p><img src="https://images.ytao.top/dubbo-router-factory-interface.png"></p><p>可以看到 getRouter 方法返回的是一个 Router 接口，该接口信息如下</p><p><img src="https://images.ytao.top/dubbo-router-router-interface.png"></p><p>其中 Router#route 是服务路由的入口，对于不同类型的路由工厂，有特定的 Router 实现类。</p><p><img src="https://images.ytao.top/dubbo-router-router-class.png"></p><p>以上就是通过解析 URL，获取到具体的 Router，通过调用 Router#router 过滤出符合当前路由规则的 invokers。</p><h1 id="服务路由实现"><a href="#服务路由实现" class="headerlink" title="服务路由实现"></a>服务路由实现</h1><p>上面展示了路由实现类，这几个实现类型中，ConditionRouter 条件路由是最为常用的类型，由于文章篇幅有限，本文就不对全部的路由类型逐一分析，只对条件路由进行具体分析，只要弄懂这一个类型，其它类型的解析就能容易掌握。</p><h2 id="条件路由参数规则"><a href="#条件路由参数规则" class="headerlink" title="条件路由参数规则"></a>条件路由参数规则</h2><p>在分析条件路由前，先了解条件路由的参数配置，官方文档如下：</p><p><img src="https://images.ytao.top/dubbo-router-condition-config.png"></p><p>条件路由规则内容如下：</p><p><img src="https://images.ytao.top/dubbo-router-condition-rule.png"></p><h2 id="条件路由实现分析"><a href="#条件路由实现分析" class="headerlink" title="条件路由实现分析"></a>条件路由实现分析</h2><p>分析路由实现，主要分析工厂类的 xxxRouterFactory#getRouter 和 xxxRouter#route 方法。</p><h3 id="ConditionRouterFactory-getRouter"><a href="#ConditionRouterFactory-getRouter" class="headerlink" title="ConditionRouterFactory#getRouter"></a>ConditionRouterFactory#getRouter</h3><p>ConditionRouterFactory 中通过创建 ConditionRouter 对象来初始化解析相关参数配置。</p><p><img src="https://images.ytao.top/dubbo-router-new-conditionRouter.png"></p><p>在 ConditionRouter 构造函数中，从 URL 里获取 rule 的字符串格式的规则，解析规则在 ConditionRouter#init 初始化方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(String rule)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rule == <span class="literal">null</span> || rule.trim().length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal route rule!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去掉 consumer. 和 provider. 的标识</span></span><br><span class="line">        rule = rule.replace(<span class="string">&quot;consumer.&quot;</span>, <span class="string">&quot;&quot;</span>).replace(<span class="string">&quot;provider.&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取 消费者匹配条件 和 提供者地址匹配条件 的分隔符</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> rule.indexOf(<span class="string">&quot;=&gt;&quot;</span>);</span><br><span class="line">        <span class="comment">// 消费者匹配条件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">whenRule</span> <span class="operator">=</span> i &lt; <span class="number">0</span> ? <span class="literal">null</span> : rule.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">        <span class="comment">// 提供者地址匹配条件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">thenRule</span> <span class="operator">=</span> i &lt; <span class="number">0</span> ? rule.trim() : rule.substring(i + <span class="number">2</span>).trim();</span><br><span class="line">        <span class="comment">// 解析消费者路由规则</span></span><br><span class="line">        Map&lt;String, MatchPair&gt; when = StringUtils.isBlank(whenRule) || <span class="string">&quot;true&quot;</span>.equals(whenRule) ? <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, MatchPair&gt;() : parseRule(whenRule);</span><br><span class="line">        <span class="comment">// 解析提供者路由规则</span></span><br><span class="line">        Map&lt;String, MatchPair&gt; then = StringUtils.isBlank(thenRule) || <span class="string">&quot;false&quot;</span>.equals(thenRule) ? <span class="literal">null</span> : parseRule(thenRule);</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> It should be determined on the business level whether the `When condition` can be empty or not.</span></span><br><span class="line">        <span class="built_in">this</span>.whenCondition = when;</span><br><span class="line">        <span class="built_in">this</span>.thenCondition = then;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以路由规则字符串中的<code>=&gt;</code>为分隔符，将消费者匹配条件和提供者匹配条件分割，解析两个路由规则后，赋值给当前对象的变量。</p><p>调用 parseRule 方法来解析消费者和服务者路由规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正则验证路由规则</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Pattern</span> <span class="variable">ROUTE_PATTERN</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;([&amp;!=,]*)\\s*([^&amp;!=,\\s]+)&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, MatchPair&gt; <span class="title function_">parseRule</span><span class="params">(String rule)</span></span><br><span class="line">        <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 条件变量和条件变量值的映射关系</span></span><br><span class="line"><span class="comment">     * 比如 host =&gt; 127.0.0.1 则保存着 host 和 127.0.0.1 的映射关系</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Map&lt;String, MatchPair&gt; condition = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, MatchPair&gt;();</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(rule)) &#123;</span><br><span class="line">        <span class="keyword">return</span> condition;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Key-Value pair, stores both match and mismatch conditions</span></span><br><span class="line">    <span class="type">MatchPair</span> <span class="variable">pair</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// Multiple values</span></span><br><span class="line">    Set&lt;String&gt; values = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> ROUTE_PATTERN.matcher(rule);</span><br><span class="line">    <span class="keyword">while</span> (matcher.find()) &#123; </span><br><span class="line">        <span class="comment">// 获取正则前部分匹配（第一个括号）的内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">separator</span> <span class="operator">=</span> matcher.group(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获取正则后部分匹配（第二个括号）的内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> matcher.group(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 如果获取前部分为空，则表示规则开始位置，则当前 content 必为条件变量</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(separator)) &#123;</span><br><span class="line">            pair = <span class="keyword">new</span> <span class="title class_">MatchPair</span>();</span><br><span class="line">            condition.put(content, pair);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果分隔符是 &amp;,则 content 为条件变量</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;&amp;&quot;</span>.equals(separator)) &#123;</span><br><span class="line">            <span class="comment">// 当前 content 是条件变量，用来做映射集合的 key 的，如果没有则添加一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (condition.get(content) == <span class="literal">null</span>) &#123;</span><br><span class="line">                pair = <span class="keyword">new</span> <span class="title class_">MatchPair</span>();</span><br><span class="line">                condition.put(content, pair);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pair = condition.get(content);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前分割符是 = ，则当前 content 为条件变量值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;=&quot;</span>.equals(separator)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ParseException</span>(<span class="string">&quot;Illegal route rule \&quot;&quot;</span></span><br><span class="line">                        + rule + <span class="string">&quot;\&quot;, The error char &#x27;&quot;</span> + separator</span><br><span class="line">                        + <span class="string">&quot;&#x27; at index &quot;</span> + matcher.start() + <span class="string">&quot; before \&quot;&quot;</span></span><br><span class="line">                        + content + <span class="string">&quot;\&quot;.&quot;</span>, matcher.start());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 由于 pair 还没有被重新初始化，所以还是上一个条件变量的对象，所以可以将当前条件变量值在引用对象上赋值</span></span><br><span class="line">            values = pair.matches;</span><br><span class="line">            values.add(content);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前分割符是 = ，则当前 content 也是条件变量值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;!=&quot;</span>.equals(separator)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ParseException</span>(<span class="string">&quot;Illegal route rule \&quot;&quot;</span></span><br><span class="line">                        + rule + <span class="string">&quot;\&quot;, The error char &#x27;&quot;</span> + separator</span><br><span class="line">                        + <span class="string">&quot;&#x27; at index &quot;</span> + matcher.start() + <span class="string">&quot; before \&quot;&quot;</span></span><br><span class="line">                        + content + <span class="string">&quot;\&quot;.&quot;</span>, matcher.start());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 与 = 时同理</span></span><br><span class="line">            values = pair.mismatches;</span><br><span class="line">            values.add(content);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前分割符为 &#x27;,&#x27;，则当前 content 也为条件变量值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;,&quot;</span>.equals(separator)) &#123; <span class="comment">// Should be separated by &#x27;,&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> (values == <span class="literal">null</span> || values.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ParseException</span>(<span class="string">&quot;Illegal route rule \&quot;&quot;</span></span><br><span class="line">                        + rule + <span class="string">&quot;\&quot;, The error char &#x27;&quot;</span> + separator</span><br><span class="line">                        + <span class="string">&quot;&#x27; at index &quot;</span> + matcher.start() + <span class="string">&quot; before \&quot;&quot;</span></span><br><span class="line">                        + content + <span class="string">&quot;\&quot;.&quot;</span>, matcher.start());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 直接向条件变量值集合中添加数据</span></span><br><span class="line">            values.add(content);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ParseException</span>(<span class="string">&quot;Illegal route rule \&quot;&quot;</span> + rule</span><br><span class="line">                    + <span class="string">&quot;\&quot;, The error char &#x27;&quot;</span> + separator + <span class="string">&quot;&#x27; at index &quot;</span></span><br><span class="line">                    + matcher.start() + <span class="string">&quot; before \&quot;&quot;</span> + content + <span class="string">&quot;\&quot;.&quot;</span>, matcher.start());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> condition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是解析条件路由规则的过程，条件变量的值都保存在 MatchPair 中的 matches、mismatches 属性中，<code>=</code>和<code>,</code>的条件变量值放在可以匹配的 matches 中，<code>!=</code>的条件变量值放在不可匹配路由规则的 mismatches 中。赋值过程中，代码还是比较优雅。</p><p><img src="https://images.ytao.top/dubbo-router-matchpair.png"></p><p>实际上 matches、mismatches 就是保存的是条件变量值。</p><h3 id="ConditionRouter-route"><a href="#ConditionRouter-route" class="headerlink" title="ConditionRouter#route"></a>ConditionRouter#route</h3><p><code>Router#route</code>的作用就是匹配出符合路由规则的 Invoker 集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在初始化中进行被复制的变量</span></span><br><span class="line"><span class="comment">// 消费者条件匹配规则</span></span><br><span class="line"><span class="keyword">protected</span> Map&lt;String, MatchPair&gt; whenCondition;</span><br><span class="line"><span class="comment">// 提供者条件匹配规则</span></span><br><span class="line"><span class="keyword">protected</span> Map&lt;String, MatchPair&gt; thenCondition;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; <span class="title function_">route</span><span class="params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span></span><br><span class="line">        <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="keyword">if</span> (!enabled) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 验证 invokers 是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isEmpty(invokers)) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokers;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 校验消费者是否有规则匹配，如果没有则返回传入的 Invoker</span></span><br><span class="line">        <span class="keyword">if</span> (!matchWhen(url, invocation)) &#123;</span><br><span class="line">            <span class="keyword">return</span> invokers;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Invoker&lt;T&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (thenCondition == <span class="literal">null</span>) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;The current consumer in the service blacklist. consumer: &quot;</span> + NetUtils.getLocalHost() + <span class="string">&quot;, service: &quot;</span> + url.getServiceKey());</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历传入的 invokers，匹配提供者是否有规则匹配</span></span><br><span class="line">        <span class="keyword">for</span> (Invoker&lt;T&gt; invoker : invokers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matchThen(invoker.getUrl(), url)) &#123;</span><br><span class="line">                result.add(invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 result 不为空，或当前对象 force=true 则返回 result 的 Invoker 列表 </span></span><br><span class="line">        <span class="keyword">if</span> (!result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (force) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;The route result is empty and force execute. consumer: &quot;</span> + NetUtils.getLocalHost() + <span class="string">&quot;, service: &quot;</span> + url.getServiceKey() + <span class="string">&quot;, router: &quot;</span> + url.getParameterAndDecoded(RULE_KEY));</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Failed to execute condition router rule: &quot;</span> + getUrl() + <span class="string">&quot;, invokers: &quot;</span> + invokers + <span class="string">&quot;, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> invokers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码可以看到，只要消费者没有匹配的规则或提供者没有匹配的规则及 force&#x3D;false 时，不会返回传入的参数的 Invoker。</p><p>匹配消费者路由规则和提供者路由规则方法是 matchWhen 和 matchThen</p><p><img src="https://images.ytao.top/dubbo-router-matchcondition.png"></p><p>这两个匹配方法都是调用同一个方法 matchCondition 实现的。将消费者或提供者 URL 转为 Map，然后与 whenCondition 或 thenCondition 进行匹配。</p><p>匹配过程中，如果 key （即 sampleValue 值）存在对应的值，则通过 MatchPair#isMatch 方法再进行匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String value, URL param)</span> &#123;</span><br><span class="line">    <span class="comment">// 存在可匹配的规则，不存在不可匹配的规则</span></span><br><span class="line">    <span class="keyword">if</span> (!matches.isEmpty() &amp;&amp; mismatches.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 不可匹配的规则列表为空时，只要可匹配的规则匹配上，直接返回 true</span></span><br><span class="line">        <span class="keyword">for</span> (String match : matches) &#123;</span><br><span class="line">            <span class="keyword">if</span> (UrlUtils.isMatchGlobPattern(match, value, param)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存在不可匹配的规则，不存在可匹配的规则</span></span><br><span class="line">    <span class="keyword">if</span> (!mismatches.isEmpty() &amp;&amp; matches.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 不可匹配的规则列表中存在，则返回false</span></span><br><span class="line">        <span class="keyword">for</span> (String mismatch : mismatches) &#123;</span><br><span class="line">            <span class="keyword">if</span> (UrlUtils.isMatchGlobPattern(mismatch, value, param)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存在可匹配的规则，也存在不可匹配的规则</span></span><br><span class="line">    <span class="keyword">if</span> (!matches.isEmpty() &amp;&amp; !mismatches.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 都不为空时，不可匹配的规则列表中存在，则返回 false</span></span><br><span class="line">        <span class="keyword">for</span> (String mismatch : mismatches) &#123;</span><br><span class="line">            <span class="keyword">if</span> (UrlUtils.isMatchGlobPattern(mismatch, value, param)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String match : matches) &#123;</span><br><span class="line">            <span class="keyword">if</span> (UrlUtils.isMatchGlobPattern(match, value, param)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后剩下的是 可匹配规则和不可匹配规则都为空时</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匹配过程再调用 UrlUtils#isMatchGlobPattern 实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMatchGlobPattern</span><span class="params">(String pattern, String value, URL param)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果以 $ 开头，则获取 URL 中对应的值</span></span><br><span class="line">    <span class="keyword">if</span> (param != <span class="literal">null</span> &amp;&amp; pattern.startsWith(<span class="string">&quot;$&quot;</span>)) &#123;</span><br><span class="line">        pattern = param.getRawParameter(pattern.substring(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">return</span> isMatchGlobPattern(pattern, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMatchGlobPattern</span><span class="params">(String pattern, String value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;*&quot;</span>.equals(pattern)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(pattern) &amp;&amp; StringUtils.isEmpty(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(pattern) || StringUtils.isEmpty(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取通配符位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> pattern.lastIndexOf(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="comment">// 如果value中没有 &quot;*&quot; 通配符，则整个字符串值匹配</span></span><br><span class="line">    <span class="keyword">if</span> (i == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.equals(pattern);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 &quot;*&quot; 在最后面，则匹配字符串 &quot;*&quot; 之前的字符串即可</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == pattern.length() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.startsWith(pattern.substring(<span class="number">0</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 &quot;*&quot; 在最前面，则匹配字符串 &quot;*&quot; 之后的字符串即可</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.endsWith(pattern.substring(i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 &quot;*&quot; 不在字符串两端，则同时匹配字符串 &quot;*&quot; 左右两边的字符串</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">prefix</span> <span class="operator">=</span> pattern.substring(<span class="number">0</span>, i);</span><br><span class="line">        <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> pattern.substring(i + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> value.startsWith(prefix) &amp;&amp; value.endsWith(suffix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这样完成全部的条件路由规则匹配，虽然看似代码较为繁杂，但是理清规则、思路，一步一步还是较好解析，前提是要熟悉相关参数的用法及形式，不然代码较难理解。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>单纯从逻辑上，如果能够掌握条件路由的实现，去研究其它方式的路由实现，相信不会有太大问题。只是例如像脚本路由的实现，你得先会使用脚本执行引擎为前提，不然就不理解它的代码。最后，在 dubbo-admin 上可以设置路由，大家可以尝试各种使用规则，通过实操才能更好掌握和理解路由机制的实现。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://images.ytao.top/dubbo.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Dubbo 路由机制是在服务间的调用时，通过将服务提供者按照设定的路由规则来决定调用哪一个具体的服务。&lt;/p&gt;
&lt;h1 id=&quot;路由服务结构&quot;&gt;&lt;a href=&quot;#路由服务结构&quot; class=&quot;headerlink&quot; title=&quot;路由服务结构&quot;&gt;&lt;/a&gt;路由服务结构&lt;/h1&gt;&lt;p&gt;Dubbo 实现路由都是通过实现 RouterFactory 接口。当前版本 dubbo-2.7.5 实现该接口类如下：&lt;/p&gt;</summary>
    
    
    
    <category term="Dubbo" scheme="https://ytao.top/categories/Dubbo/"/>
    
    
    <category term="Dubbo" scheme="https://ytao.top/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>你必须会的 JDK 动态代理和 CGLIB 动态代理</title>
    <link href="https://ytao.top/2020/04/05/20-java-proxy/"/>
    <id>https://ytao.top/2020/04/05/20-java-proxy/</id>
    <published>2020-04-04T16:00:00.000Z</published>
    <updated>2023-10-10T14:18:14.206Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.ytao.top/dynamic-prox.jpg"></p><p>我们在阅读一些 Java 框架的源码时，基本上常会看到使用动态代理机制，它可以无感的对既有代码进行方法的增强，使得代码拥有更好的拓展性。<br>通过从静态代理、JDK 动态代理、CGLIB 动态代理来进行本文的分析。</p><span id="more"></span><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>静态代理就是在程序运行之前，代理类字节码<code>.class</code>就已编译好，通常一个静态代理类也只代理一个目标类，代理类和目标类都实现相同的接口。<br>接下来就先通过 demo 进行分析什么是静态代理，当前创建一个 Animal 接口，里面包含<code>call</code>函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建目标类 Cat，同时实现 Animal 接口，下面是 Cat 发出叫声的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喵喵喵 ~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 Cat 叫之前是因为肚子饿了，所以我们需要在目标对象方法<code>Cat#call</code>之前说明是饥饿，这是使用静态代理实现猫饥饿然后发出叫声。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.proxy.jdk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> top.ytao.demo.proxy.Animal;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticProxyAnimal</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Animal impl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StaticProxyAnimal</span><span class="params">(Animal impl)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;猫饥饿&quot;</span>);</span><br><span class="line">        impl.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过调用静态代理实现猫饥饿和叫行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">staticProxy</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">staticProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticProxyAnimal</span>(<span class="keyword">new</span> <span class="title class_">Cat</span>());</span><br><span class="line">        staticProxy.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>执行结果</p><p><img src="https://images.ytao.top/java-proxy-static.png"></p><p>代理类、目标类、接口之间关系如图：</p><p><img src="https://images.ytao.top/java-proxy-static-class.png"></p><p>以上内容可以看到代理类中通过持有目标类对象，然后通过调用目标类的方法，实现静态代理。<br>静态代理虽然实现了代理，但在一些情况下存在比较明显不足之处：</p><ol><li>当我们在 Animal 接口中增加方法，这时不仅实现类 Cat 需要新增该方法的实现，同时，由于代理类实现了 Animal 接口，所以代理类也必须实现 Animal 新增的方法，这对项目规模较大时，在维护上就不太友好了。</li><li>代理类实现<code>Animal#call</code>是针对 Cat 目标类的对象进行设置的，如果再需要添加 Dog 目标类的代理，那就必须再针对 Dog 类实现一个对应的代理类，这样就使得代理类的重用型不友好，并且过多的代理类对维护上也是比较繁琐。</li></ol><p>上面问题，在 JDk 动态代理中就得到了较友好的解决。</p><h1 id="JDK-动态代理"><a href="#JDK-动态代理" class="headerlink" title="JDK 动态代理"></a>JDK 动态代理</h1><p>动态代理类与静态代理类最主要不同的是，代理类的字节码不是在程序运行前生成的，而是在程序运行时再虚拟机中程序自动创建的。<br>继续用上面 Cat 类和 Animal 接口实现 JDK 动态代理。</p><h2 id="实现-InvocationHandler-接口"><a href="#实现-InvocationHandler-接口" class="headerlink" title="实现 InvocationHandler 接口"></a>实现 InvocationHandler 接口</h2><p>JDK 动态代理类必须实现反射包中的 java.lang.reflect.InvocationHandler 接口，在此接口中只有一个 invoker 方法：</p><p><img src="https://images.ytao.top/java-proxy-invocationHandler.png"></p><p>在<code>InvocationHandler#invoker</code>中必须调用目标类被代理的方法，否则无法做到代理的实现。下面为实现 InvocationHandler 的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetInvoker</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">    <span class="comment">// 代理中持有的目标类</span></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TargetInvoker</span><span class="params">(Object target)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;jdk 代理执行前&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;jdk 代理执行后&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实现<code>InvocationHandler#invoker</code>时，该方法里有三个参数：</p><ul><li>proxy 代理目标对象的代理对象，它是真实的代理对象。</li><li>method 执行目标类的方法</li><li>args 执行目标类的方法的参数</li></ul><h2 id="创建-JDK-动态代理类"><a href="#创建-JDK-动态代理类" class="headerlink" title="创建 JDK 动态代理类"></a>创建 JDK 动态代理类</h2><p>创建 JDK 动态代理类实例同样也是使用反射包中的 java.lang.reflect.Proxy 类进行创建。通过调用<code>Proxy#newProxyInstance</code>静态方法进行创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicProxyAnimal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Object target)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proxy</span> <span class="operator">=</span> Proxy.newProxyInstance(</span><br><span class="line">                target.getClass().getClassLoader(), <span class="comment">// 指定目标类的类加载</span></span><br><span class="line">                target.getClass().getInterfaces(),  <span class="comment">// 代理需要实现的接口，可指定多个，这是一个数组</span></span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">TargetInvoker</span>(target)   <span class="comment">// 代理对象处理器</span></span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Proxy#newProxyInstance</code>中的三个参数（ClassLoader loader、Class&lt;?&gt;[] interfaces、InvocationHandler h）：</p><ul><li>loader 加载代理对象的类加载器</li><li>interfaces 代理对象实现的接口，与目标对象实现同样的接口</li><li>h 处理代理对象逻辑的处理器，即上面的 InvocationHandler 实现类。</li></ul><p>最后实现执行 DynamicProxyAnimal 动态代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dynamicProxy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">proxy</span> <span class="operator">=</span> (Animal) DynamicProxyAnimal.getProxy(cat);</span><br><span class="line">        proxy.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://images.ytao.top/java-proxy-jdk-test.png"></p><p>通过上面的代码，有两个问题：代理类是怎么创建的和代理类怎么调用方法的？</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从<code>Proxy#newProxyInstance</code>入口进行源码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span><br><span class="line"><span class="params">                                      InvocationHandler h)</span></span><br><span class="line">    <span class="keyword">throws</span> IllegalArgumentException</span><br><span class="line">&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">SecurityManager</span> <span class="variable">sm</span> <span class="operator">=</span> System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找或生成指定的代理类</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="literal">null</span>) &#123;</span><br><span class="line">            checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取代理的构造器</span></span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">        <span class="keyword">final</span> <span class="type">InvocationHandler</span> <span class="variable">ih</span> <span class="operator">=</span> h;</span><br><span class="line">        <span class="comment">// 处理代理类修饰符，使得能被访问</span></span><br><span class="line">        <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建代理类实例化</span></span><br><span class="line">        <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;h&#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException|InstantiationException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString(), e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        <span class="type">Throwable</span> <span class="variable">t</span> <span class="operator">=</span> e.getCause();</span><br><span class="line">        <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(t.toString(), t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>newProxyInstance 方法里面获取到代理类，如果类的作用不能访问，使其能被访问到，最后实例化代理类。这段代码中最为核心的是获取代理类的<code>getProxyClass0</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = <span class="keyword">new</span> <span class="title class_">WeakCache</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">KeyFactory</span>(), <span class="keyword">new</span> <span class="title class_">ProxyClassFactory</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="comment">// 实现类的接口不能超过 65535 个</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;interface limit exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取代理类</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 proxyClassCache 缓存中存在指定的代理类，则从缓存直接获取；如果不存在，则通过 ProxyClassFactory 创建代理类。<br>至于为什么接口最大为 65535，这个是由字节码文件结构和 Java 虚拟机规定的，具体可以通过研究字节码文件了解。</p><p>进入到<code>proxyClassCache#get</code>，获取代理类:</p><p><img src="https://images.ytao.top/java-proxy-jdk-getval.png"></p><p>继续进入<code>Factory#get</code>查看，</p><p><img src="https://images.ytao.top/java-proxy-jdk-getval2.png"></p><p>最后到<code>ProxyClassFactory#apply</code>，这里实现了代理类的创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ProxyClassFactory</span> <span class="keyword">implements</span> <span class="title class_">BiFunction</span>&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;&#123;</span><br><span class="line">    <span class="comment">// 所有代理类名称都已此前缀命名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">proxyClassNamePrefix</span> <span class="operator">=</span> <span class="string">&quot;$Proxy&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 代理类名的编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AtomicLong</span> <span class="variable">nextUniqueNumber</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicLong</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> <span class="title class_">IdentityHashMap</span>&lt;&gt;(interfaces.length);</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 校验代理和目标对象是否实现同一接口</span></span><br><span class="line">            Class&lt;?&gt; interfaceClass = <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                interfaceClass = Class.forName(intf.getName(), <span class="literal">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    intf + <span class="string">&quot; is not visible from class loader&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 校验 interfaceClass 是否为接口</span></span><br><span class="line">            <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    interfaceClass.getName() + <span class="string">&quot; is not an interface&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 判断当前 interfaceClass 是否被重复</span></span><br><span class="line">            <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                    <span class="string">&quot;repeated interface: &quot;</span> + interfaceClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 代理类的包名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">proxyPkg</span> <span class="operator">=</span> <span class="literal">null</span>;     </span><br><span class="line">        <span class="type">int</span> <span class="variable">accessFlags</span> <span class="operator">=</span> Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录非 public 修饰符代理接口的包，使生成的代理类与它在同一个包下</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">flags</span> <span class="operator">=</span> intf.getModifiers();</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                accessFlags = Modifier.FINAL;</span><br><span class="line">                <span class="comment">// 获取接口类名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> intf.getName();</span><br><span class="line">                <span class="comment">// 去掉接口的名称，获取所在包的包名</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">pkg</span> <span class="operator">=</span> ((n == -<span class="number">1</span>) ? <span class="string">&quot;&quot;</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (proxyPkg == <span class="literal">null</span>) &#123;</span><br><span class="line">                    proxyPkg = pkg;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(</span><br><span class="line">                        <span class="string">&quot;non-public interfaces from different packages&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果接口类是 public 修饰，则用 com.sun.proxy 包名</span></span><br><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建代理类名称</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> nextUniqueNumber.getAndIncrement();</span><br><span class="line">        <span class="type">String</span> <span class="variable">proxyName</span> <span class="operator">=</span> proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成代理类字节码文件</span></span><br><span class="line">        <span class="type">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces, accessFlags);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加载字节码，生成指定代理对象</span></span><br><span class="line">            <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                                proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是创建字节码流程，通过检查接口的属性，决定代理类字节码文件生成的包名及名称规则，然后加载字节码获取代理实例。操作生成字节码文件在<code>ProxyGenerator#generateProxyClass</code>中生成具体的字节码文件，字节码操作这里不做详细讲解。<br>生成的字节码文件，我们可以通过保存本地进行反编译查看类信息，保存生成的字节码文件可以通过两种方式：设置jvm参数或将生成 byte[] 写入文件。</p><p><img src="https://images.ytao.top/java-proxy-jdk-saveGproxy.png"></p><p>上图的<code>ProxyGenerator#generateProxyClass</code>方法可知，是通过 saveGeneratedFiles 属性值控制，该属性的值来源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="variable">saveGeneratedFiles</span> <span class="operator">=</span> ((Boolean)AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">GetBooleanAction</span>(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>))).booleanValue();</span><br></pre></td></tr></table></figure><p>所以通过设置将生成的代理类字节码保存到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dsun.misc.ProxyGenerator.saveGeneratedFiles=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>反编译查看生成的代理类：</p><p><img src="https://images.ytao.top/java-proxy-jdk-proxy-class.png"></p><p>生成的代理类继承了 Proxy 和实现了 Animal 接口，调用<code>call</code>方法，是通过调用 Proxy 持有的 InvocationHandler 实现<code>TargetInvoker#invoker</code>的执行。</p><h1 id="CGLIB-动态代理"><a href="#CGLIB-动态代理" class="headerlink" title="CGLIB 动态代理"></a>CGLIB 动态代理</h1><p>CGLIB 动态代理的实现机制是生成目标类的子类，通过调用父类（目标类）的方法实现，在调用父类方法时再代理中进行增强。</p><h2 id="实现-MethodInterceptor-接口"><a href="#实现-MethodInterceptor-接口" class="headerlink" title="实现 MethodInterceptor 接口"></a>实现 MethodInterceptor 接口</h2><p>相比于 JDK 动态代理的实现，CGLIB 动态代理不需要实现与目标类一样的接口，而是通过方法拦截的方式实现代理，代码实现如下，首先方法拦截接口 net.sf.cglib.proxy.MethodInterceptor。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetInterceptor</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CGLIB 调用前&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;CGLIB 调用后&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过方法拦截接口调用目标类的方法，然后在该被拦截的方法进行增强处理，实现方法拦截器接口的 intercept 方法里面有四个参数：</p><ul><li>obj 代理类对象</li><li>method 当前被代理拦截的方法</li><li>args 拦截方法的参数</li><li>proxy 代理类对应目标类的代理方法</li></ul><h2 id="创建-CGLIB-动态代理类"><a href="#创建-CGLIB-动态代理类" class="headerlink" title="创建 CGLIB 动态代理类"></a>创建 CGLIB 动态代理类</h2><p>创建 CGLIB 动态代理类使用 net.sf.cglib.proxy.Enhancer 类进行创建，它是 CGLIB 动态代理中的核心类，首先创建个简单的代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span>&#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">// 设置类加载</span></span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        <span class="comment">// 设置被代理类</span></span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        <span class="comment">// 设置方法拦截器</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">TargetInterceptor</span>());</span><br><span class="line">        <span class="comment">// 创建代理类</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置被代理类的信息和代理类拦截的方法的回调执行逻辑，就可以实现一个代理类。<br>实现 CGLIB 动态代理调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dynamicProxy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">cat</span> <span class="operator">=</span> (Animal) CglibProxy.getProxy(Cat.class);</span><br><span class="line">        cat.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://images.ytao.top/java-proxy-cglib-test.png"></p><p>CGLIB 动态代理简单应用就这样实现，但是 Enhancer 在使用过程中，常用且有特色功能还有回调过滤器 CallbackFilter 的使用，它在拦截目标对象的方法时，可以有选择性的执行方法拦截，也就是选择被代理方法的增强处理。使用该功能需要实现 net.sf.cglib.proxy.CallbackFilter 接口。<br>现在增加一个方法拦截的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetInterceptor2</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;CGLIB 调用前 TargetInterceptor2&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">&quot;CGLIB 调用后 TargetInterceptor2&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 Cat 中增加 hobby 方法，因为 CGLIB 代理无需实现接口，可以直接代理普通类，所以不需再 Animal 接口中增加方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> top.ytao.demo.proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;喵喵喵 ~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hobby</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fish ~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现回调过滤器 CallbackFilter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetCallbackFilter</span> <span class="keyword">implements</span> <span class="title class_">CallbackFilter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">accept</span><span class="params">(Method method)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;hobby&quot;</span>.equals(method.getName()))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为演示调用不同的方法拦截器，在 Enhancer 设置中，使用<code>Enhancer#setCallbacks</code>设置多个方法拦截器，参数是一个数组，<code>TargetCallbackFilter#accept</code>返回的数字即为该数组的索引，决定调用的回调选择器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YangTao</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CglibProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxy</span><span class="params">(Class&lt;?&gt; clazz)</span>&#123;</span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        enhancer.setClassLoader(clazz.getClassLoader());</span><br><span class="line">        enhancer.setSuperclass(clazz);</span><br><span class="line">        enhancer.setCallbacks(<span class="keyword">new</span> <span class="title class_">Callback</span>[]&#123;<span class="keyword">new</span> <span class="title class_">TargetInterceptor</span>(), <span class="keyword">new</span> <span class="title class_">TargetInterceptor2</span>()&#125;);</span><br><span class="line">        enhancer.setCallbackFilter(<span class="keyword">new</span> <span class="title class_">TargetCallbackFilter</span>());</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按代码实现逻辑，call 方法会调用 TargetInterceptor 类，hobby 类会调用 TargetInterceptor2 类，执行结果：</p><p><img src="https://images.ytao.top/java-proxy-cglib-test-2.png"></p><p>CGLIB 的实现原理是通过设置被代理的类信息到 Enhancer 中，然后利用配置信息在<code>Enhancer#create</code>生成代理类对象。生成类是使用 ASM 进行生成，本文不做重点分析。如果不关注 ASM 的操作原理，只看 CGLIB 的处理原理还是比较容易读懂。这里主要看生成后的代理类字节码文件，通过设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, <span class="string">&quot;F:\\xxx&quot;</span>);</span><br></pre></td></tr></table></figure><p>可保存生成的字节到 F:\xxx 文件夹中</p><p><img src="https://images.ytao.top/java-proxy-cglib-jad.png"></p><p>通过反编译可看到</p><p><img src="https://images.ytao.top/java-proxy-cglib-class.jpg"></p><p>代理类继承了目标类 Cat，同时将两个方法拦截器加载到了代理类中，通过 Callbacks 下标作为变量名后缀进行区分，最后调用指定的方法拦截器中的 intercept 实现代理的最终的执行结果。<br>这里需要注意的是 CGLIB 动态代理不能代理 final 修饰的类和方法。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>通过反编译生成的 JDK 代理类和 CGLIB 代理类，我们可以看到它们两种不同机制的实现：<br>JDK 动态代理是通过实现目标类的接口，然后将目标类在构造动态代理时作为参数传入，使代理对象持有目标对象，再通过代理对象的 InvocationHandler 实现动态代理的操作。<br>CGLIB 动态代理是通过配置目标类信息，然后利用 ASM 字节码框架进行生成目标类的子类。当调用代理方法时，通过拦截方法的方式实现代理的操作。<br>总的来说，JDK 动态代理利用接口实现代理，CGLIB 动态代理利用继承的方式实现代理。</p><p>动态代理在 Java 开发中是非常常见的，在日志，监控，事务中都有着广泛的应用，同时在大多主流框架中的核心组件中也是少不了使用的，掌握其要点，不管是开发还是阅读其他框架源码时，都是必须的。 </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://images.ytao.top/dynamic-prox.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们在阅读一些 Java 框架的源码时，基本上常会看到使用动态代理机制，它可以无感的对既有代码进行方法的增强，使得代码拥有更好的拓展性。&lt;br&gt;通过从静态代理、JDK 动态代理、CGLIB 动态代理来进行本文的分析。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://ytao.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://ytao.top/tags/Java/"/>
    
    <category term="JDK" scheme="https://ytao.top/tags/JDK/"/>
    
    <category term="CGLIB" scheme="https://ytao.top/tags/CGLIB/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo 扩展点加载机制：从 Java SPI 到 Dubbo SPI</title>
    <link href="https://ytao.top/2020/03/22/19-dubbo-spi/"/>
    <id>https://ytao.top/2020/03/22/19-dubbo-spi/</id>
    <published>2020-03-21T16:00:00.000Z</published>
    <updated>2023-10-10T14:18:14.206Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.ytao.top/iu.jpg"></p><p>SPI 全称为 Service Provider Interface，是一种服务发现机制。当程序运行调用接口时，会根据配置文件或默认规则信息加载对应的实现类。所以在程序中并没有直接指定使用接口的哪个实现，而是在外部进行装配。<br>要想了解 Dubbo 的设计与实现，其中 Dubbo SPI 加载机制是必须了解的，在 Dubbo 中有大量功能的实现都是基于 Dubbo SPI 实现解耦，同时也使得 Dubbo 获得如此好的可扩展性。</p><span id="more"></span><h1 id="Java-SPI"><a href="#Java-SPI" class="headerlink" title="Java SPI"></a>Java SPI</h1><p>通过完成一个 Java SPI 的操作来了解它的机制。</p><ul><li>创建一个 AnimalService 接口及 category 方法</li><li>创建一个实现类 Cat</li><li>创建 META-INF&#x2F;services 目录，并在该目录下创建一个文件，文件名为 AnimalService 的全限定名作为文件名</li><li>在文件中添加实现类 Cat 的全限定名</li></ul><p>Animal 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AnimalService</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">category</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Cat 实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">AnimalService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">category</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat: Meow ~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 META-INF&#x2F;services 目录下的 top.ytao.demo.spi.AnimalService 文件中添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top.ytao.demo.spi.Cat</span><br></pre></td></tr></table></figure><p>加载 SPI 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaSPITest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">javaSPI</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        ServiceLoader&lt;AnimalService&gt; serviceLoader = ServiceLoader.load(AnimalService.class);</span><br><span class="line">        <span class="comment">// 遍历在配置文件中已配置的 AnimalService 的所有实现类</span></span><br><span class="line">        <span class="keyword">for</span> (AnimalService animalService : serviceLoader) &#123;</span><br><span class="line">            animalService.category();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://images.ytao.top/dubbo-java-spi.png"></p><p>就这样，一个 Java SPI 就实现完成了，通过 <code>ServiceLoader.load</code> 获取加载所有接口已配置的接口实现类，然后可以遍历找出需要的实现。</p><h1 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h1><p>本文 Dubbo 版本为<code>2.7.5</code><br>Dubbo SPI 相较于 Java SPI 更为强大，并且都是由自己实现的一套 SPI 机制。其中主要的改进和优化：</p><ul><li>相对于 Java SPI 一次性加载所有实现，Dubbo SPI 是按需加载，只加载需要使用的实现类。同时带有缓存支持。</li><li>更为详细的扩展加载失败信息。</li><li>增加了对扩展 IOC 和 AOP的支持。</li></ul><h2 id="Dubbo-SPI-示例"><a href="#Dubbo-SPI-示例" class="headerlink" title="Dubbo SPI 示例"></a>Dubbo SPI 示例</h2><p>Dubbo SPI 的配置文件放在 META-INF&#x2F;dubbo 下面，并且实现类的配置方式采用 K-V 的方式，key 为实例化对象传入的参数，value 为扩展点实现类全限定名。例如 Cat 的配置文件内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> = top.ytao.demo.spi.Cat</span><br></pre></td></tr></table></figure><p>Dubbo SPI 加载过程中，对 Java SPI 的目录也是可以被兼容的。</p><p>同时需要在接口上增加 @SPI 注解，@SPI 中可以指定 key 值，加载 SPI 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DubboSPITest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dubboSPI</span><span class="params">()</span>&#123;</span><br><span class="line">        ExtensionLoader&lt;AnimalService&gt; extensionLoader = ExtensionLoader.getExtensionLoader(AnimalService.class);</span><br><span class="line">        <span class="comment">// 获取扩展类实现</span></span><br><span class="line">        <span class="type">AnimalService</span> <span class="variable">cat</span> <span class="operator">=</span> extensionLoader.getExtension(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Dubbo SPI&quot;</span>);</span><br><span class="line">        cat.category();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><p><img src="https://images.ytao.top/dubbo-dubbo-spi.png"></p><h3 id="获取-ExtensionLoader-实例"><a href="#获取-ExtensionLoader-实例" class="headerlink" title="获取 ExtensionLoader 实例"></a>获取 ExtensionLoader 实例</h3><p>获取 ExtensionLoader 实例是通过上面 getExtensionLoader 方法，具体实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; ExtensionLoader&lt;T&gt; <span class="title function_">getExtensionLoader</span><span class="params">(Class&lt;T&gt; type)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (type == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension type == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查 type 必须为接口</span></span><br><span class="line">    <span class="keyword">if</span> (!type.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension type (&quot;</span> + type + <span class="string">&quot;) is not an interface!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查接口是否有 SPI 注解</span></span><br><span class="line">    <span class="keyword">if</span> (!withExtensionAnnotation(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension type (&quot;</span> + type +</span><br><span class="line">                <span class="string">&quot;) is not an extension, because it is NOT annotated with @&quot;</span> + SPI.class.getSimpleName() + <span class="string">&quot;!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存中获取 ExtensionLoader 实例</span></span><br><span class="line">    ExtensionLoader&lt;T&gt; loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    <span class="keyword">if</span> (loader == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 加载 ExtensionLoader 实例到缓存中</span></span><br><span class="line">        EXTENSION_LOADERS.putIfAbsent(type, <span class="keyword">new</span> <span class="title class_">ExtensionLoader</span>&lt;T&gt;(type));</span><br><span class="line">        loader = (ExtensionLoader&lt;T&gt;) EXTENSION_LOADERS.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> loader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面获取扩展类加载器过程主要是检查传入的 type 是否合法，以及从扩展类加载器缓存中是否存在当前类型的接口，如果不存在则添加当前接口至缓存中。<br><code>ConcurrentMap&lt;Class&lt;?&gt;, ExtensionLoader&lt;?&gt;&gt; EXTENSION_LOADERS</code> 是扩展类加载器的缓存，它是以接口作为 key， 扩展类加载器作为 value 进行缓存。</p><h3 id="获取扩展类对象"><a href="#获取扩展类对象" class="headerlink" title="获取扩展类对象"></a>获取扩展类对象</h3><p>获取扩展类对象的方法<code>ExtensionLoader#getExtension</code>，在这里完成扩展对象的缓存及创建工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getExtension</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Extension name == null&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果传入的参数为 true ，则获取默认扩展类对象操作</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;true&quot;</span>.equals(name)) &#123;</span><br><span class="line">        <span class="keyword">return</span> getDefaultExtension();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取扩展对象，Holder 里的 value 属性保存着扩展对象实例</span></span><br><span class="line">    <span class="keyword">final</span> Holder&lt;Object&gt; holder = getOrCreateHolder(name);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> holder.get();</span><br><span class="line">    <span class="comment">// 使用双重检查锁</span></span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (holder) &#123;</span><br><span class="line">            instance = holder.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建扩展对象</span></span><br><span class="line">                instance = createExtension(name);</span><br><span class="line">                holder.set(instance);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取 holder 对象是从缓存<code>ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances</code>中获取，如果不存在，则以扩展名 key，创建一个 Holder 对象作为 value，设置到扩展对象缓存。<br>如果是新创建的扩展对象实例，那么 holder.get() 一定是 null ，扩展对象为空时，经过双重检查锁，创建扩展对象。</p><h3 id="创建扩展对象"><a href="#创建扩展对象" class="headerlink" title="创建扩展对象"></a>创建扩展对象</h3><p>创建扩展对象过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">createExtension</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="comment">// 从全部扩展类中，获取当前扩展名对应的扩展类</span></span><br><span class="line">    Class&lt;?&gt; clazz = getExtensionClasses().get(name);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> findException(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 从缓存中获取扩展实例，及设置扩展实例缓存</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">instance</span> <span class="operator">=</span> (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());</span><br><span class="line">            instance = (T) EXTENSION_INSTANCES.get(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 向当前实例注入依赖</span></span><br><span class="line">        injectExtension(instance);</span><br><span class="line">        <span class="comment">// 获取包装扩展类缓存</span></span><br><span class="line">        Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isNotEmpty(wrapperClasses)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;</span><br><span class="line">                <span class="comment">// 创建包装扩展类实例，并向其注入依赖</span></span><br><span class="line">                instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化扩展对象</span></span><br><span class="line">        initExtension(instance);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Extension instance (name: &quot;</span> + name + <span class="string">&quot;, class: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;) couldn&#x27;t be instantiated: &quot;</span> + t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面创建扩展过程中，里面有个 Wrapper 类，这里使用到装饰器模式，该类是没有具体的实现，而是把通用逻辑进行抽象。<br>创建这个过程是从所有扩展类中获取当前扩展名对应映射关系的扩展类，以及向当前扩展对象注入依赖。</p><p>获取所有扩展类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; getExtensionClasses() &#123;</span><br><span class="line">    <span class="comment">// 获取普通扩展类缓存</span></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; classes = cachedClasses.get();</span><br><span class="line">    <span class="comment">// 如果缓存中没有，通过双重检查锁后进行加载</span></span><br><span class="line">    <span class="keyword">if</span> (classes == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (cachedClasses) &#123;</span><br><span class="line">            classes = cachedClasses.get();</span><br><span class="line">            <span class="keyword">if</span> (classes == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 加载全部扩展类</span></span><br><span class="line">                classes = loadExtensionClasses();</span><br><span class="line">                cachedClasses.set(classes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>检查普通扩展类缓存是否为空，如果不为空则重新加载，真正加载扩展类在<code>loadExtensionClasses</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SERVICES_DIRECTORY</span> <span class="operator">=</span> <span class="string">&quot;META-INF/services/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DUBBO_DIRECTORY</span> <span class="operator">=</span> <span class="string">&quot;META-INF/dubbo/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DUBBO_INTERNAL_DIRECTORY</span> <span class="operator">=</span> DUBBO_DIRECTORY + <span class="string">&quot;internal/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Map&lt;String, Class&lt;?&gt;&gt; loadExtensionClasses() &#123;</span><br><span class="line">    <span class="comment">// 获取 @SPI 上的默认扩展名</span></span><br><span class="line">    cacheDefaultExtensionName();</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; extensionClasses = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 先加载 Dubbo 内部的扩展类， 通过 Boolean 值控制</span></span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName(), <span class="literal">true</span>);</span><br><span class="line">    <span class="comment">// 由于 Dubbo 迁到 apache ，所以包名有变化，会替换之前的 alibaba 为 apache</span></span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY, type.getName().replace(<span class="string">&quot;org.apache&quot;</span>, <span class="string">&quot;com.alibaba&quot;</span>), <span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName());</span><br><span class="line">    loadDirectory(extensionClasses, DUBBO_DIRECTORY, type.getName().replace(<span class="string">&quot;org.apache&quot;</span>, <span class="string">&quot;com.alibaba&quot;</span>));</span><br><span class="line">    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName());</span><br><span class="line">    loadDirectory(extensionClasses, SERVICES_DIRECTORY, type.getName().replace(<span class="string">&quot;org.apache&quot;</span>, <span class="string">&quot;com.alibaba&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> extensionClasses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面获取 @SPI 扩展名，以及指定要加载的文件。从上面静态常量中，我们可以看到，Dubbo SPI 也是支持加载 Java SPI 的目录，同时还加载 META-INF&#x2F;dubbo&#x2F;internal (该目录为 Dubbo 的内部扩展类目录)，在 loadDirectory 加载目录配置文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadDirectory</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, String dir, String type, <span class="type">boolean</span> extensionLoaderClassLoaderFirst)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取文件在项目中的路径，如：META-INF/dubbo/top.ytao.demo.spi.AnimalService</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> dir + type;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Enumeration&lt;java.net.URL&gt; urls = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> findClassLoader();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载内部扩展类</span></span><br><span class="line">        <span class="keyword">if</span> (extensionLoaderClassLoaderFirst) &#123;</span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">extensionLoaderClassLoader</span> <span class="operator">=</span> ExtensionLoader.class.getClassLoader();</span><br><span class="line">            <span class="keyword">if</span> (ClassLoader.getSystemClassLoader() != extensionLoaderClassLoader) &#123;</span><br><span class="line">                urls = extensionLoaderClassLoader.getResources(fileName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 加载当前 fileName 文件</span></span><br><span class="line">        <span class="keyword">if</span>(urls == <span class="literal">null</span> || !urls.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (classLoader != <span class="literal">null</span>) &#123;</span><br><span class="line">                urls = classLoader.getResources(fileName);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                urls = ClassLoader.getSystemResources(fileName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (urls != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 迭代加载同名文件的内容</span></span><br><span class="line">            <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">                java.net.<span class="type">URL</span> <span class="variable">resourceURL</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">                <span class="comment">// 加载文件内容</span></span><br><span class="line">                loadResource(extensionClasses, classLoader, resourceURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Exception occurred when loading extension class (interface: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;, description file: &quot;</span> + fileName + <span class="string">&quot;).&quot;</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里获取文件名后加载所有同名文件，然后迭代各个文件，逐个加载文件内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadResource</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, ClassLoader classLoader, java.net.URL resourceURL)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(resourceURL.openStream(), StandardCharsets.UTF_8))) &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="comment">// 整行读取文件内容</span></span><br><span class="line">            <span class="keyword">while</span> ((line = reader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取当前行中第一个 &quot;#&quot; 的位置索引</span></span><br><span class="line">                <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ci</span> <span class="operator">=</span> line.indexOf(<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">                <span class="comment">// 如果当前行存在 &quot;#&quot;,则去除 &quot;#&quot; 后的内容</span></span><br><span class="line">                <span class="keyword">if</span> (ci &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    line = line.substring(<span class="number">0</span>, ci);</span><br><span class="line">                &#125;</span><br><span class="line">                line = line.trim();</span><br><span class="line">                <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">                        <span class="comment">// 获取当前行 &quot;=&quot; 的索引</span></span><br><span class="line">                        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> line.indexOf(<span class="string">&#x27;=&#x27;</span>);</span><br><span class="line">                        <span class="comment">// 如果当前行存在 &quot;=&quot;，将 &quot;=&quot; 左右的值分开复制给 name 和 line</span></span><br><span class="line">                        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            name = line.substring(<span class="number">0</span>, i).trim();</span><br><span class="line">                            line = line.substring(i + <span class="number">1</span>).trim();</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (line.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 加载扩展类</span></span><br><span class="line">                            loadClass(extensionClasses, resourceURL, Class.forName(line, <span class="literal">true</span>, classLoader), name);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                        <span class="type">IllegalStateException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to load extension class (interface: &quot;</span> + type + <span class="string">&quot;, class line: &quot;</span> + line + <span class="string">&quot;) in &quot;</span> + resourceURL + <span class="string">&quot;, cause: &quot;</span> + t.getMessage(), t);</span><br><span class="line">                        exceptions.put(line, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        logger.error(<span class="string">&quot;Exception occurred when loading extension class (interface: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;, class file: &quot;</span> + resourceURL + <span class="string">&quot;) in &quot;</span> + resourceURL, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码完成文件内容加载和解析，接下来通过 <code>loadClass</code> 加载扩展类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">loadClass</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; extensionClasses, java.net.URL resourceURL, Class&lt;?&gt; clazz, String name)</span> <span class="keyword">throws</span> NoSuchMethodException &#123;</span><br><span class="line">    <span class="comment">// 检查当前实现类是否实现了 type 接口</span></span><br><span class="line">    <span class="keyword">if</span> (!type.isAssignableFrom(clazz)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Error occurred when loading extension class (interface: &quot;</span> +</span><br><span class="line">                type + <span class="string">&quot;, class line: &quot;</span> + clazz.getName() + <span class="string">&quot;), class &quot;</span></span><br><span class="line">                + clazz.getName() + <span class="string">&quot; is not subtype of interface.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前实现类是否有 Adaptive 注解</span></span><br><span class="line">    <span class="keyword">if</span> (clazz.isAnnotationPresent(Adaptive.class)) &#123;</span><br><span class="line">        cacheAdaptiveClass(clazz);</span><br><span class="line">    <span class="comment">// 当前类是否为 Wrapper 包装扩展类 </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isWrapperClass(clazz)) &#123;</span><br><span class="line">        cacheWrapperClass(clazz);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试当前类是否有无参构造方法</span></span><br><span class="line">        clazz.getConstructor();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(name)) &#123;</span><br><span class="line">            <span class="comment">// 如果 name 为空，则获取 clazz 的 @Extension 注解的值，如果注解值也没有，则使用小写类名</span></span><br><span class="line">            name = findAnnotationName(clazz);</span><br><span class="line">            <span class="keyword">if</span> (name.length() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No such extension name for the class &quot;</span> + clazz.getName() + <span class="string">&quot; in the config &quot;</span> + resourceURL);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] names = NAME_SEPARATOR.split(name);</span><br><span class="line">        <span class="keyword">if</span> (ArrayUtils.isNotEmpty(names)) &#123;</span><br><span class="line">            <span class="comment">// 缓存 扩展名和@Activate的缓存</span></span><br><span class="line">            cacheActivateClass(clazz, names[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">for</span> (String n : names) &#123;</span><br><span class="line">                <span class="comment">// 缓存 扩展类和扩展名的缓存</span></span><br><span class="line">                cacheName(clazz, n);</span><br><span class="line">                <span class="comment">// 将 扩展类和扩展名 保存到extensionClasses 扩展名-&gt;扩展类 关系映射中</span></span><br><span class="line">                saveInExtensionClass(extensionClasses, clazz, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，getExtensionClasses() 加载扩展类方法分析完成，接下分析注入依赖 injectExtension() 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">injectExtension</span><span class="params">(T instance)</span> &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="keyword">if</span> (objectFactory == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Method method : instance.getClass().getMethods()) &#123;</span><br><span class="line">            <span class="comment">// 遍历当前扩展类的全部方法，如果当前方法不属于 setter 方法，</span></span><br><span class="line">            <span class="comment">// 即不是以 &#x27;set&#x27;开头的方法名，参数不是一个的，该方法访问级别不是 public 的，则不往下执行</span></span><br><span class="line">            <span class="keyword">if</span> (!isSetter(method)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当前方法是否添加了不要注入依赖的注解</span></span><br><span class="line">            <span class="keyword">if</span> (method.getAnnotation(DisableInject.class) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">// 判断当前参数是否属于 八个基本类型或void</span></span><br><span class="line">            <span class="keyword">if</span> (ReflectUtils.isPrimitives(pt)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通过属性 setter 方法获取属性名</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">property</span> <span class="operator">=</span> getSetterProperty(method);</span><br><span class="line">                <span class="comment">// 获取依赖对象</span></span><br><span class="line">                <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> objectFactory.getExtension(pt, property);</span><br><span class="line">                <span class="keyword">if</span> (object != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 设置依赖</span></span><br><span class="line">                    method.invoke(instance, object);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Failed to inject via method &quot;</span> + method.getName()</span><br><span class="line">                        + <span class="string">&quot; of interface &quot;</span> + type.getName() + <span class="string">&quot;: &quot;</span> + e.getMessage(), e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.error(e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过遍历扩展类所有方法，找到相对应的依赖，然后使用反射调用 settter 方法来进行设置依赖。<br>objectFactory 对象如图：</p><p><img src="https://images.ytao.top/dubbo-objectFactory.png"></p><p>其中找到相应依赖是在 SpiExtensionFactory 或 SpringExtensionFactory 中，同时，这两个 Factory 保存在 AdaptiveExtensionFactory 中进行维护。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdaptiveExtensionFactory</span> <span class="keyword">implements</span> <span class="title class_">ExtensionFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ExtensionFactory&gt; factories;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AdaptiveExtensionFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">getExtension</span><span class="params">(Class&lt;T&gt; type, String name)</span> &#123;</span><br><span class="line">        <span class="comment">// 通过遍历匹配到 type-&gt;name 的映射</span></span><br><span class="line">        <span class="keyword">for</span> (ExtensionFactory factory : factories) &#123;</span><br><span class="line">            <span class="type">T</span> <span class="variable">extension</span> <span class="operator">=</span> factory.getExtension(type, name);</span><br><span class="line">            <span class="keyword">if</span> (extension != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> extension;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是对 Dubbo SPI 扩展类简单加载过程分析完成。</p><h2 id="自适应加载机制"><a href="#自适应加载机制" class="headerlink" title="自适应加载机制"></a>自适应加载机制</h2><p>为 Dubbo 更加灵活的使一个接口不通过硬编码加载扩展机制，而是通过使用过程中进行加载，Dubbo 的另一加载机制——自适应加载。<br>自适应加载机制使用 @Adaptive 标注：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Adaptive &#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Adaptive 的值是一个数组，可以配置多个 key。初始化时，遍历所有 key 进行匹配，如果没有则匹配 @SPI 的值。<br>当 Adaptive 注解标注在类上时，则简单对应该实现。如果注解标注在接口方法上时，则会根据参数动态生成代码来获取扩展点的实现。<br>类上注解处理还是比较好理解，方法上的注解加载相对比较有研读性。通过调用<code>ExtensionLoader#getAdaptiveExtension</code>来进行获取扩展实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">getAdaptiveExtension</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取实例化对象缓存</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">instance</span> <span class="operator">=</span> cachedAdaptiveInstance.get();</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (createAdaptiveInstanceError != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to create adaptive instance: &quot;</span> +</span><br><span class="line">                    createAdaptiveInstanceError.toString(),</span><br><span class="line">                    createAdaptiveInstanceError);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 双重检查锁后创建自适应扩展</span></span><br><span class="line">        <span class="keyword">synchronized</span> (cachedAdaptiveInstance) &#123;</span><br><span class="line">            instance = cachedAdaptiveInstance.get();</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 创建自适应扩展</span></span><br><span class="line">                    instance = createAdaptiveExtension();</span><br><span class="line">                    cachedAdaptiveInstance.set(instance);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    createAdaptiveInstanceError = t;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Failed to create adaptive instance: &quot;</span> + t.toString(), t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (T) instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">createAdaptiveExtension</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取自适应扩展后，注入依赖</span></span><br><span class="line">        <span class="keyword">return</span> injectExtension((T) getAdaptiveExtensionClass().newInstance());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Can&#x27;t create adaptive extension &quot;</span> + type + <span class="string">&quot;, cause: &quot;</span> + e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面代码完成了扩展类对象是否存在缓存中，如果不存在，则通过创建自适应扩展，并将实例注入依赖后，设置在实例化后的自适应扩展对象中。<br>其中<code>getAdaptiveExtensionClass</code>是比较核心的流程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; getAdaptiveExtensionClass() &#123;</span><br><span class="line">    <span class="comment">// 加载全部扩展类</span></span><br><span class="line">    getExtensionClasses();</span><br><span class="line">    <span class="comment">// 加载全部扩展类后，如果有 @Adaptive 标注的类，cachedAdaptiveClass 则一定不会为空</span></span><br><span class="line">    <span class="keyword">if</span> (cachedAdaptiveClass != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedAdaptiveClass;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建自适应扩展类</span></span><br><span class="line">    <span class="type">return</span> <span class="variable">cachedAdaptiveClass</span> <span class="operator">=</span> createAdaptiveExtensionClass();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;</span><br><span class="line">    <span class="comment">// 生成自适应扩展代码</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdaptiveClassCodeGenerator</span>(type, cachedDefaultName).generate();</span><br><span class="line">    <span class="comment">// 获取扩展类加载器</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> findClassLoader();</span><br><span class="line">    <span class="comment">// 获取编译器类型的实现类</span></span><br><span class="line">    org.apache.dubbo.common.compiler.<span class="type">Compiler</span> <span class="variable">compiler</span> <span class="operator">=</span> ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();</span><br><span class="line">    <span class="comment">// 编译代码，返回该对象</span></span><br><span class="line">    <span class="keyword">return</span> compiler.compile(code, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里完成的工作主要是，加载全部扩展类，代表所有扩展接口类的实现类，在其加载过程中，如果有 @Adaptive 标注的类，会保存到 cachedAdaptiveClass 中。通过自动生成自适应扩展代码，并被编译后，获取扩展类实例化对象。<br>上面编译器类型是可以指定的，通过 compiler 进行指定，例如：<code>&lt;dubbo:application name=&quot;taomall-provider&quot; compiler=&quot;jdk&quot; /&gt;</code>，该编译器默认使用 javassist 编译器。</p><p>在 generate 方法中动态生成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">generate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 检查当前扩展接口的方法上是否有 Adaptive 注解</span></span><br><span class="line">    <span class="keyword">if</span> (!hasAdaptiveMethod()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No adaptive method exist on extension &quot;</span> + type.getName() + <span class="string">&quot;, refuse to create the adaptive class!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成代码</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">code</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="comment">// 生成类的包名</span></span><br><span class="line">    code.append(generatePackageInfo());</span><br><span class="line">    <span class="comment">// 生成类的依赖类</span></span><br><span class="line">    code.append(generateImports());</span><br><span class="line">    <span class="comment">// 生成类的声明信息</span></span><br><span class="line">    code.append(generateClassDeclaration());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成方法</span></span><br><span class="line">    Method[] methods = type.getMethods();</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        code.append(generateMethod(method));</span><br><span class="line">    &#125;</span><br><span class="line">    code.append(<span class="string">&quot;&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        logger.debug(code.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> code.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是生成类信息的方法，生成设计原理是按照已设置好的模板，进行替换操作，生成类。具体信息不代码很多，但阅读还是比较简单。<br>自适应加载机制，已简单分析完，咋一眼看，非常复杂，但是了解整体结构和流程，再去细研的话，相对还是好理解。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>从 Dubbo 设计来看，其良好的扩展性，比较重要的一点是得益于 Dubbo SPI 加载机制。在学习它的设计理念，对可扩展性方面的编码思考也有一定的启发。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://images.ytao.top/iu.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;SPI 全称为 Service Provider Interface，是一种服务发现机制。当程序运行调用接口时，会根据配置文件或默认规则信息加载对应的实现类。所以在程序中并没有直接指定使用接口的哪个实现，而是在外部进行装配。&lt;br&gt;要想了解 Dubbo 的设计与实现，其中 Dubbo SPI 加载机制是必须了解的，在 Dubbo 中有大量功能的实现都是基于 Dubbo SPI 实现解耦，同时也使得 Dubbo 获得如此好的可扩展性。&lt;/p&gt;</summary>
    
    
    
    <category term="Dubbo" scheme="https://ytao.top/categories/Dubbo/"/>
    
    
    <category term="Dubbo" scheme="https://ytao.top/tags/Dubbo/"/>
    
    <category term="Java" scheme="https://ytao.top/tags/Java/"/>
    
    <category term="SPI" scheme="https://ytao.top/tags/SPI/"/>
    
  </entry>
  
  <entry>
    <title>volatile 手摸手带你解析</title>
    <link href="https://ytao.top/2020/03/15/18-volatile/"/>
    <id>https://ytao.top/2020/03/15/18-volatile/</id>
    <published>2020-03-14T16:00:00.000Z</published>
    <updated>2023-10-10T14:18:14.206Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.ytao.top/volatile.jpg"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>volatile 是 Java 里的一个重要的指令，它是由 Java 虚拟机里提供的一个轻量级的同步机制。一个共享变量声明为 volatile 后，特别是在多线程操作时，正确使用 volatile 变量，就要掌握好其原理。</p><span id="more"></span><h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>volatile 具有<strong>可见性</strong>和<strong>有序性</strong>的特性，同时，对 volatile 修饰的变量进行单个读写操作是具有<strong>原子性</strong>。</p><p>这几个特性到底是什么意思呢？</p><ul><li><strong>可见性：</strong> 当一个线程更新了 volatile 修饰的共享变量，那么任意其他线程都能知道这个变量最后修改的值。简单的说，就是多线程运行时，一个线程修改 volatile 共享变量后，其他线程获取值时，一定都是这个修改后的值。</li><li><strong>有序性：</strong> 一个线程中的操作，相对于自身，都是有序的，Java 内存模型会限制编译器重排序和处理器重排序。意思就会说 volatile 内存语义单个线程中是串行的语义。</li><li><strong>原子性：</strong> 多线程操作中，非复合操作单个 volatile 的读写是具有原子性的。</li></ul><h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><p>可见性是在多线程中保证共享变量的数据有效，接下来我们通过有 volatile 修饰的变量和无 volatile 修饰的变量代码的执行结果来做对比分析。</p><h2 id="无-volatile-修饰变量"><a href="#无-volatile-修饰变量" class="headerlink" title="无 volatile 修饰变量"></a>无 volatile 修饰变量</h2><p>以下是没有 volatile 修饰变量代码，通过创建两个线程，来验证 flag 被其中一个线程修改后的执行情况。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YANGTAO on 2020/3/15 0015.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValatileDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A 线程，判断其他线程修改 flag 之后，数据是否对本线程有效</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.printf(<span class="string">&quot;********** %s 线程执行结束！ **********&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// B 线程，修改 flag 值</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 避免 B 线程比 A 线程先运行修改 flag 值  </span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 如果 flag 值修改后，让 B 线程先打印信息</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                System.out.printf(<span class="string">&quot;********** %s 线程执行结束！ **********&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，当 flag 初始值 true，被 B 线程修改为 false。如果修改后的值对 A 线程有效，那么正常情况下 A 线程会先于 B 线程结束。执行结果如下：</p><p><img src="https://images.ytao.top/volatile-no-kejian.png"></p><p>执行结果是：当 B 线程执行结束后，<code>flag = false</code>并未对 A 线程生效，A 线程死循环。</p><h2 id="volatile-修饰变量"><a href="#volatile-修饰变量" class="headerlink" title="volatile 修饰变量"></a>volatile 修饰变量</h2><p>在上述代码中，当我们把 flag 使用 volatile 修饰:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YANGTAO on 2020/3/15 0015.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValatileDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">Boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// A 线程，判断其他线程修改 flag 之后，数据是否对本线程有效</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (flag) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.printf(<span class="string">&quot;********** %s 线程执行结束！ **********&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">        &#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// B 线程，修改 flag 值</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 避免 B 线程比 A 线程先运行修改 flag 值  </span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 如果 flag 值修改后，让 B 线程先打印信息</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                System.out.printf(<span class="string">&quot;********** %s 线程执行结束！ **********&quot;</span>, Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;B&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://images.ytao.top/volatile-kejian.png"></p><p>B 线程修改 flag 值后，对 A 线程数据有效，A 线程跳出循环，执行完成。所以 volatile 修饰的变量，有新值写入后，对其他线程来说，数据是有效的，能被其他线程读到。</p><h2 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h2><p>上面代码中的变量加了 volatile 修饰，为什么就能被其他线程读取到，这就涉及到 Java 内存模型规定的变量访问规则。</p><ul><li><strong>主内存：</strong>主内存是机器硬件的内存，主要对应Java 堆中的对象实例数据部分。</li><li><strong>工作内存：</strong>每个线程都有自己的工作内存，对应虚拟机栈中的部分区域，线程对变量的读&#x2F;写操作都必须在工作内存中进行，不能直接读写主内存的变量。</li></ul><p>上面<code>无 volatile 修饰变量</code>部分的代码执行示意图如下：</p><p><img src="https://images.ytao.top/volatile-no-volatile.png"></p><p>当 A 线程读取到 flag 的初始值为<code>true</code>，进行 while 循环操作，B 线程将工作内存 B 里的 flag 更新为<code>false</code>，然后将值发送到主内存进行更新。随后，由于此时的 A 线程不会主动刷新主内存中的值到工作内存 A 中，所以线程 A 所取得 flag 值一直都是<code>true</code>，A 线程也就为死循环不会停止下来。</p><p>上面<code>volatile 修饰变量</code>部分的代码执行示意图如下：</p><p><img src="https://images.ytao.top/volatile-has-volatile.png"></p><p>当 B 线程更新 volatile 修饰的变量时，会向 A 线程通过线程之间的通信发送通知（JDK5 或更高版本），并且将工作内存 B 中更新的值同步到主内存中。A 线程接收到通知后，不会再读取工作内存 A 中的值，会将主内存的变量通过主内存和工作内存之间的交互协议，拷贝到工作内存 A 中，这时读取的值就是线程 A 更新后的值<code>flag = false</code>。<br>整个变量值得传递过程中，线程之间不能直接访问自身以外的工作内存，必须通过主内存作为中转站传递变量值。在这传递过程中是存在拷贝操作的，但是对象的引用，虚拟机不会整个对象进行拷贝，会存在线程访问的字段拷贝。</p><h1 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h1><p>volatile 包含禁止指令重排的语义，Java 内存模型会限制编译器重排序和处理器重排序，简而言之就是单个线程内表现为串行语义。<br><strong>那什么是重排序？</strong><br>重排序的目的是编译器和处理器为了优化程序性能而对指令序列进行重排序，但在单线程和单处理器中，重排序不会改变有数据依赖关系的两个操作顺序。<br>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YANGTAO on 2020/3/15 0015.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReorderDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">        b = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重排序后：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReorderDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        b = <span class="number">3</span>;  <span class="comment">// a 和 b 重排序后，调换了位置</span></span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果在单核处理器和单线程中数据之间存在依赖关系则不会进行重排序，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YANGTAO on 2020/3/15 0015.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReorderDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        a = <span class="number">2</span>;</span><br><span class="line">        b = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于 a 和 b 存在数据依赖关系，则不会进行重排序</span></span><br></pre></td></tr></table></figure><p>volatile 实现特有的内存语义，Java 内存模型定义以下规则（表格中的 No 代表不可以重排序）：</p><p><img src="https://images.ytao.top/volatile-rule.png"></p><p>Java 内存模型在指令序列中插入内存屏障来处理 volatile 重排序规则，策略如下：</p><ul><li>volatile 写操作前插入一个 StoreStore 屏障</li><li>volatile 写操作后插入一个 StoreLoad 屏障</li><li>volatile 读操作后插入一个 LoadLoad 屏障</li><li>volatile 读操作后插入一个 LoadStore 屏障</li></ul><p>该四种屏障意义：</p><ul><li>StoreStore：在该屏障后的写操作执行之前，保证该屏障前的写操作已刷新到主内存。</li><li>StoreLoad：在该屏障后的读取操作执行之前，保证该屏障前的写操作已刷新到主内存。</li><li>LoadLoad：在该屏障后的读取操作执行之前，保证该屏障前的读操作已读取完毕。</li><li>LoadStore：在该屏障后的写操作执行之前，保证该屏障前的读操作已读取完毕。</li></ul><h1 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h1><p>前面有提到 volatile 的原子性是相对于单个 volatile 变量的读&#x2F;写具有，比如下面代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by YANGTAO on 2020/3/15 0015.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;  <span class="comment">// 创建 10 个线程</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;    <span class="comment">// 每个线程累加 1000</span></span><br><span class="line">                    num ++;</span><br><span class="line">                &#125;</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;, String.valueOf(i+<span class="number">1</span>)).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        latch.await();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 所有线程累加计算的数据</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;num: %d&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，如果 volatile 修饰 num，在 num++ 运算中能持有原子性，那么根据以上数量的累加，最后应该是 <code>num: 10000</code>。<br>代码执行结果：</p><p><img src="https://images.ytao.top/volatile-atomic.png"></p><p>结果与我们预计数据的相差挺多，虽然 volatile 变量在更新值的时候回通知其他线程刷新主内存中最新数据，但这只能保证其基本类型变量读&#x2F;写的原子操作（如：num &#x3D; 2）。由于<code>num++</code>是属于一个非原子操作的复合操作，所以不能保证其原子性。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><ol><li>volatile 变量最后的运算结果不依赖变量的当前值，也就是前面提到的直接赋值变量的原子操作，比如：保存数据遍历的特定条件的一个值。</li><li>可以进行状态标记，比如：是否初始化，是否停止等等。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>volatile 是一个简单又轻量级的同步机制，但在使用过程中，局限性比较大，要想使用好它，必须了解其原理及本质，所以在使用过程中遇到的问题，相比于其他同步机制来说，更容易出现问题。但使用好 volatile，在某些解决问题上能获取更佳的性能。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://images.ytao.top/volatile.jpg&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;volatile 是 Java 里的一个重要的指令，它是由 Java 虚拟机里提供的一个轻量级的同步机制。一个共享变量声明为 volatile 后，特别是在多线程操作时，正确使用 volatile 变量，就要掌握好其原理。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://ytao.top/categories/Java/"/>
    
    
    <category term="Java" scheme="https://ytao.top/tags/Java/"/>
    
    <category term="volatile" scheme="https://ytao.top/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo之服务消费原理</title>
    <link href="https://ytao.top/2020/03/08/17-dubbo-reference/"/>
    <id>https://ytao.top/2020/03/08/17-dubbo-reference/</id>
    <published>2020-03-07T16:00:00.000Z</published>
    <updated>2023-10-10T14:18:14.206Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.ytao.top/dubbo.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上篇文章<a href="https://ytao.top/2020/03/01/16-dubbo/">《Dubbo之服务暴露》</a>分析 Dubbo 服务是如何暴露的，本文接着分析 Dubbo 服务的消费流程。主要从以下几个方面进行分析：<strong>注册中心的暴露</strong>；<strong>通过注册中心进行服务消费通知</strong>；<strong>直连服务进行消费</strong>。<br>服务消费端启动时，将自身的信息注册到注册中心的目录，同时还订阅服务提供方的目录，当服务提供方的 URL 发生更改时，实时获取新的数据。</p><span id="more"></span><h1 id="服务消费端流程"><a href="#服务消费端流程" class="headerlink" title="服务消费端流程"></a>服务消费端流程</h1><p>下面是一个服务消费的流程图：</p><p><img src="https://images.ytao.top/dubbo_rpc_refer.jpg"></p><p>上图中可以看到，服务消费的流程与服务暴露的流程有点类似逆向的。同样，Dubbo 服务也是分为两个大步骤：第一步就是将远程服务通过<code>Protocol</code>转换成<code>Invoker</code>(概念在上篇文章中有解释)。第二步通过动态代理将<code>Invoker</code>转换成消费服务需要的接口。</p><p><code>org.apache.dubbo.config.ReferenceConfig </code>类是<code>ReferenceBean</code>的父类，与生产端服务的<code>ServiceBean</code>一样，存放着解析出来的 XML 和注解信息。类关系如下：</p><p><img src="https://images.ytao.top/dubbo_referencebean.png"></p><h1 id="服务初始化中转换的入口"><a href="#服务初始化中转换的入口" class="headerlink" title="服务初始化中转换的入口"></a>服务初始化中转换的入口</h1><p>当我们消费端调用本地接口就能实现远程服务的调用，这是怎么实现的呢？根据上面的流程图，来分析消费原理。<br>在消费端进行初始化时<code>ReferenceConfig#init</code>，会执行<code>ReferenceConfig#createProxy</code>来完成这一系列操作。以下为<code>ReferenceConfig#createProxy</code>主要的代码部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> T <span class="title function_">createProxy</span><span class="params">(Map&lt;String, String&gt; map)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断是否为 Jvm 本地引用</span></span><br><span class="line">    <span class="keyword">if</span> (shouldJvmRefer(map)) &#123;</span><br><span class="line">        <span class="comment">// 通过 injvm 协议，获取本地服务</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(LOCAL_PROTOCOL, LOCALHOST_VALUE, <span class="number">0</span>, interfaceClass.getName()).addParameters(map);</span><br><span class="line">        invoker = REF_PROTOCOL.refer(interfaceClass, url);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        urls.clear();</span><br><span class="line">        <span class="comment">// 判断是否有自定义的直连地址，或注册中心地址</span></span><br><span class="line">        <span class="keyword">if</span> (url != <span class="literal">null</span> &amp;&amp; url.length() &gt; <span class="number">0</span>) &#123; </span><br><span class="line">            String[] us = SEMICOLON_SPLIT_PATTERN.split(url);</span><br><span class="line">            <span class="keyword">if</span> (us != <span class="literal">null</span> &amp;&amp; us.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String u : us) &#123;</span><br><span class="line">                    <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> URL.valueOf(u);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isEmpty(url.getPath())) &#123;</span><br><span class="line">                        url = url.setPath(interfaceName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (UrlUtils.isRegistry(url)) &#123;</span><br><span class="line">                        <span class="comment">// 如果是注册中心Protocol类型，则向地址中添加 refer 服务消费元数据</span></span><br><span class="line">                        urls.add(url.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 直连服务提供端</span></span><br><span class="line">                        urls.add(ClusterUtils.mergeUrl(url, map));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 组装注册中心的配置</span></span><br><span class="line">            <span class="keyword">if</span> (!LOCAL_PROTOCOL.equalsIgnoreCase(getProtocol())) &#123;</span><br><span class="line">                <span class="comment">// 检查配置中心</span></span><br><span class="line">                checkRegistry();</span><br><span class="line">                List&lt;URL&gt; us = ConfigValidationUtils.loadRegistries(<span class="built_in">this</span>, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (CollectionUtils.isNotEmpty(us)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (URL u : us) &#123;</span><br><span class="line">                        <span class="type">URL</span> <span class="variable">monitorUrl</span> <span class="operator">=</span> ConfigValidationUtils.loadMonitor(<span class="built_in">this</span>, u);</span><br><span class="line">                        <span class="keyword">if</span> (monitorUrl != <span class="literal">null</span>) &#123;</span><br><span class="line">                            <span class="comment">// 监控上报信息</span></span><br><span class="line">                            map.put(MONITOR_KEY, URL.encode(monitorUrl.toFullString()));</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 注册中心地址添加 refer 服务消费元数据</span></span><br><span class="line">                        urls.add(u.addParameterAndEncoded(REFER_KEY, StringUtils.toQueryString(map)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只有一条注册中心数据，即单注册中心</span></span><br><span class="line">        <span class="keyword">if</span> (urls.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 将远程服务转化成 Invoker</span></span><br><span class="line">            invoker = REF_PROTOCOL.refer(interfaceClass, urls.get(<span class="number">0</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 因为多注册中心就会存在多个 Invoker，这里用保存在 List 中</span></span><br><span class="line">            List&lt;Invoker&lt;?&gt;&gt; invokers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Invoker&lt;?&gt;&gt;();</span><br><span class="line">            <span class="type">URL</span> <span class="variable">registryURL</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (URL url : urls) &#123;</span><br><span class="line">                <span class="comment">// 将每个注册中心转换成 Invoker 数据</span></span><br><span class="line">                invokers.add(REF_PROTOCOL.refer(interfaceClass, url));</span><br><span class="line">                <span class="keyword">if</span> (UrlUtils.isRegistry(url)) &#123;</span><br><span class="line">                    <span class="comment">// 会覆盖前遍历的注册中心，使用最后一条注册中心数据</span></span><br><span class="line">                    registryURL = url;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (registryURL != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 默认使用 zone-aware 策略来处理多个订阅</span></span><br><span class="line">                <span class="type">URL</span> <span class="variable">u</span> <span class="operator">=</span> registryURL.addParameterIfAbsent(CLUSTER_KEY, ZoneAwareCluster.NAME);</span><br><span class="line">                <span class="comment">// 将转换后的多个 Invoker 合并成一个</span></span><br><span class="line">                invoker = CLUSTER.join(<span class="keyword">new</span> <span class="title class_">StaticDirectory</span>(u, invokers));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                invoker = CLUSTER.join(<span class="keyword">new</span> <span class="title class_">StaticDirectory</span>(invokers));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 利用动态代理，将 Invoker 转换成本地接口代理</span></span><br><span class="line">    <span class="keyword">return</span> (T) PROXY_FACTORY.getProxy(invoker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面转换的过程中，主要可概括为：先分为本地引用和远程引用两类。本地就是以 inJvm 协议的获取本地服务，这不做过多说明；远程引用分为直连服务和通过注册中心。注册中心分为单注册中心和多注册中心的情况，单注册中心好解决，直接使用即可，多注册中心时，将转换后的 Invoker 合并成一个 Invoker。最后通过动态代理将 Invoker 转换成本地接口代理。</p><h1 id="获取-Invoker-实例"><a href="#获取-Invoker-实例" class="headerlink" title="获取 Invoker 实例"></a>获取 Invoker 实例</h1><p>由于本地服务时直接从缓存中获取，这里就注册中心的消费进行分析，上面代码片段中使用的是<code>REF_PROTOCOL.refer</code>进行转换，该方法代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">    <span class="comment">// 获取服务的注册中心url，里面会设置注册中心的协议和移除 registry 的参数</span></span><br><span class="line">    url = getRegistryUrl(url);</span><br><span class="line">    <span class="comment">// 获取注册中心实例</span></span><br><span class="line">    <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> registryFactory.getRegistry(url);</span><br><span class="line">    <span class="keyword">if</span> (RegistryService.class.equals(type)) &#123;</span><br><span class="line">        <span class="keyword">return</span> proxyFactory.getInvoker((T) registry, type, url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取服务消费元数据</span></span><br><span class="line">    Map&lt;String, String&gt; qs = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));</span><br><span class="line">    <span class="comment">// 从服务消费元数据中获取分组信息</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> qs.get(GROUP_KEY);</span><br><span class="line">    <span class="keyword">if</span> (group != <span class="literal">null</span> &amp;&amp; group.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((COMMA_SPLIT_PATTERN.split(group)).length &gt; <span class="number">1</span> || <span class="string">&quot;*&quot;</span>.equals(group)) &#123;</span><br><span class="line">            <span class="comment">// 执行 Invoker 转换工作</span></span><br><span class="line">            <span class="keyword">return</span> doRefer(getMergeableCluster(), registry, type, url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行 Invoker 转换工作</span></span><br><span class="line">    <span class="keyword">return</span> doRefer(cluster, registry, type, url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面主要是获取服务消费的注册中心实例和进行服务分组，最后调用<code>doRefer</code>方法进行转换工作，以下为<code>doRefer</code>的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; Invoker&lt;T&gt; <span class="title function_">doRefer</span><span class="params">(Cluster cluster, Registry registry, Class&lt;T&gt; type, URL url)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建 RegistryDirectory 对象</span></span><br><span class="line">    RegistryDirectory&lt;T&gt; directory = <span class="keyword">new</span> <span class="title class_">RegistryDirectory</span>&lt;T&gt;(type, url);</span><br><span class="line">    <span class="comment">// 设置注册中心</span></span><br><span class="line">    directory.setRegistry(registry);</span><br><span class="line">    <span class="comment">// 设置协议</span></span><br><span class="line">    directory.setProtocol(protocol);</span><br><span class="line">    <span class="comment">// directory.getUrl().getParameters() 是服务消费元数据</span></span><br><span class="line">    Map&lt;String, String&gt; parameters = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;(directory.getUrl().getParameters());</span><br><span class="line">    <span class="type">URL</span> <span class="variable">subscribeUrl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(CONSUMER_PROTOCOL, parameters.remove(REGISTER_IP_KEY), <span class="number">0</span>, type.getName(), parameters);</span><br><span class="line">    <span class="keyword">if</span> (!ANY_VALUE.equals(url.getServiceInterface()) &amp;&amp; url.getParameter(REGISTER_KEY, <span class="literal">true</span>)) &#123;</span><br><span class="line">        directory.setRegisteredConsumerUrl(getRegisteredConsumerUrl(subscribeUrl, url));</span><br><span class="line">        <span class="comment">// 消费消息注册到注册中心</span></span><br><span class="line">        registry.register(directory.getRegisteredConsumerUrl());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    directory.buildRouterChain(subscribeUrl);</span><br><span class="line">    <span class="comment">// 服务消费者订阅：服务提供端，动态配置，路由的通知</span></span><br><span class="line">    directory.subscribe(subscribeUrl.addParameter(CATEGORY_KEY,</span><br><span class="line">            PROVIDERS_CATEGORY + <span class="string">&quot;,&quot;</span> + CONFIGURATORS_CATEGORY + <span class="string">&quot;,&quot;</span> + ROUTERS_CATEGORY));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多个Invoker合并为一个</span></span><br><span class="line">    <span class="type">Invoker</span> <span class="variable">invoker</span> <span class="operator">=</span> cluster.join(directory);</span><br><span class="line">    <span class="keyword">return</span> invoker;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面实现主要是完成创建 RegistryDirectory 对象，将消费服务元数据注册到注册中心，通过 RegistryDirectory 对象里的信息，实现服务提供端，动态配置及路由的订阅相关功能。</p><p>RegistryDirectory 这个类实现了 NotifyListener 这个通知监听接口，当订阅的服务，配置或路由发生变化时，会接收到通知，进行相应改变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(List&lt;URL&gt; urls)</span> &#123;</span><br><span class="line">    <span class="comment">// 将服务提供方配置，路由配置，服务提供方的服务分别以不同的 key 保存在 Map 中</span></span><br><span class="line">    Map&lt;String, List&lt;URL&gt;&gt; categoryUrls = urls.stream()</span><br><span class="line">            .filter(Objects::nonNull)</span><br><span class="line">            .filter(<span class="built_in">this</span>::isValidCategory)</span><br><span class="line">            .filter(<span class="built_in">this</span>::isNotCompatibleFor26x)</span><br><span class="line">            .collect(Collectors.groupingBy(url -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (UrlUtils.isConfigurator(url)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> CONFIGURATORS_CATEGORY;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UrlUtils.isRoute(url)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ROUTERS_CATEGORY;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (UrlUtils.isProvider(url)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> PROVIDERS_CATEGORY;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新服务提供方配置</span></span><br><span class="line">    List&lt;URL&gt; configuratorURLs = categoryUrls.getOrDefault(CONFIGURATORS_CATEGORY, Collections.emptyList());</span><br><span class="line">    <span class="built_in">this</span>.configurators = Configurator.toConfigurators(configuratorURLs).orElse(<span class="built_in">this</span>.configurators);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新路由配置</span></span><br><span class="line">    List&lt;URL&gt; routerURLs = categoryUrls.getOrDefault(ROUTERS_CATEGORY, Collections.emptyList());</span><br><span class="line">    toRouters(routerURLs).ifPresent(<span class="built_in">this</span>::addRouters);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载服务提供方的服务信息</span></span><br><span class="line">    List&lt;URL&gt; providerURLs = categoryUrls.getOrDefault(PROVIDERS_CATEGORY, Collections.emptyList());</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.x added for extend URL address</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ExtensionLoader&lt;AddressListener&gt; addressListenerExtensionLoader = ExtensionLoader.getExtensionLoader(AddressListener.class);</span><br><span class="line">    List&lt;AddressListener&gt; supportedListeners = addressListenerExtensionLoader.getActivateExtension(getUrl(), (String[]) <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (supportedListeners != <span class="literal">null</span> &amp;&amp; !supportedListeners.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (AddressListener addressListener : supportedListeners) &#123;</span><br><span class="line">            providerURLs = addressListener.notify(providerURLs, getUrl(),<span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重新加载 Invoker 实例</span></span><br><span class="line">    refreshOverrideAndInvoker(providerURLs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RegistryDirectory#notify</code>里面最后会刷新 Invoker 进行重新加载，下面是核心代码的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshOverrideAndInvoker</span><span class="params">(List&lt;URL&gt; urls)</span> &#123;</span><br><span class="line">    <span class="comment">// mock zookeeper://xxx?mock=return null</span></span><br><span class="line">    overrideDirectoryUrl();</span><br><span class="line">    <span class="comment">// 刷新 invoker </span></span><br><span class="line">    refreshInvoker(urls);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">refreshInvoker</span><span class="params">(List&lt;URL&gt; invokerUrls)</span> &#123;</span><br><span class="line">    Assert.notNull(invokerUrls, <span class="string">&quot;invokerUrls should not be null&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (invokerUrls.size() == <span class="number">1</span></span><br><span class="line">            &amp;&amp; invokerUrls.get(<span class="number">0</span>) != <span class="literal">null</span></span><br><span class="line">            &amp;&amp; EMPTY_PROTOCOL.equals(invokerUrls.get(<span class="number">0</span>).getProtocol())) &#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 刷新之前的 Invoker</span></span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; oldUrlInvokerMap = <span class="built_in">this</span>.urlInvokerMap; <span class="comment">// local reference</span></span><br><span class="line">        <span class="comment">// 加载新的 Invoker Map</span></span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = toInvokers(invokerUrls);<span class="comment">// Translate url list to Invoker map</span></span><br><span class="line">        <span class="comment">// 获取新的 Invokers</span></span><br><span class="line">        List&lt;Invoker&lt;T&gt;&gt; newInvokers = Collections.unmodifiableList(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(newUrlInvokerMap.values()));</span><br><span class="line">        <span class="comment">// 缓存新的 Invokers</span></span><br><span class="line">        routerChain.setInvokers(newInvokers);</span><br><span class="line">        <span class="built_in">this</span>.invokers = multiGroup ? toMergeInvokerList(newInvokers) : newInvokers;</span><br><span class="line">        <span class="built_in">this</span>.urlInvokerMap = newUrlInvokerMap;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 通过新旧 Invokers 对比，销毁无用的 Invokers</span></span><br><span class="line">            destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap); <span class="comment">// Close the unused Invoker</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(<span class="string">&quot;destroyUnusedInvokers error. &quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取刷新前后的 Invokers，将新的 Invokers 重新缓存起来，通过对比，销毁无用的 Invoker。</p><p>上面将 URL 转换 Invoker 是在<code>RegistryDirectory#toInvokers</code>中进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, Invoker&lt;T&gt;&gt; <span class="title function_">toInvokers</span><span class="params">(List&lt;URL&gt; urls)</span> &#123;</span><br><span class="line">    Map&lt;String, Invoker&lt;T&gt;&gt; newUrlInvokerMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">   </span><br><span class="line">    Set&lt;String&gt; keys = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">String</span> <span class="variable">queryProtocols</span> <span class="operator">=</span> <span class="built_in">this</span>.queryMap.get(PROTOCOL_KEY);</span><br><span class="line">    <span class="keyword">for</span> (URL providerUrl : urls) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 过滤消费端不匹配的协议，及非法协议</span></span><br><span class="line">        ......</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并服务提供端配置数据</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> mergeUrl(providerUrl);</span><br><span class="line">        <span class="comment">// 过滤重复的服务提供端配置数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> url.toFullString();</span><br><span class="line">        <span class="keyword">if</span> (keys.contains(key)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        keys.add(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 缓存键是不与使用者端参数合并的url，无论使用者如何合并参数，如果服务器url更改，则再次引用</span></span><br><span class="line">        Map&lt;String, Invoker&lt;T&gt;&gt; localUrlInvokerMap = <span class="built_in">this</span>.urlInvokerMap; <span class="comment">// local reference</span></span><br><span class="line">        Invoker&lt;T&gt; invoker = localUrlInvokerMap == <span class="literal">null</span> ? <span class="literal">null</span> : localUrlInvokerMap.get(key);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 缓存无对应 invoker，再次调用 protocol#refer 是否有数据</span></span><br><span class="line">        <span class="keyword">if</span> (invoker == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">enabled</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (url.hasParameter(DISABLED_KEY)) &#123;</span><br><span class="line">                    enabled = !url.getParameter(DISABLED_KEY, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    enabled = url.getParameter(ENABLED_KEY, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (enabled) &#123;</span><br><span class="line">                    invoker = <span class="keyword">new</span> <span class="title class_">InvokerDelegate</span>&lt;&gt;(protocol.refer(serviceType, url), url, providerUrl);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.error(<span class="string">&quot;Failed to refer invoker for interface:&quot;</span> + serviceType + <span class="string">&quot;,url:(&quot;</span> + url + <span class="string">&quot;)&quot;</span> + t.getMessage(), t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将新的 Invoker 缓存起来</span></span><br><span class="line">            <span class="keyword">if</span> (invoker != <span class="literal">null</span>) &#123; <span class="comment">// Put new invoker in cache</span></span><br><span class="line">                newUrlInvokerMap.put(key, invoker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 缓存里有数据，则进行重新覆盖</span></span><br><span class="line">            newUrlInvokerMap.put(key, invoker);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    keys.clear();</span><br><span class="line">    <span class="keyword">return</span> newUrlInvokerMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>通过《Dubbo之服务暴露》和本文两篇文章对 Dubbo 服务暴露和服务消费原理的了解。我们可以看到，不管是暴露还是消费，Dubbo 都是以 Invoker 为数据交换主体进行，通过对 Invoker 发起调用，实现一个远程或本地的实现。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://images.ytao.top/dubbo.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上篇文章&lt;a href=&quot;https://ytao.top/2020/03/01/16-dubbo/&quot;&gt;《Dubbo之服务暴露》&lt;/a&gt;分析 Dubbo 服务是如何暴露的，本文接着分析 Dubbo 服务的消费流程。主要从以下几个方面进行分析：&lt;strong&gt;注册中心的暴露&lt;/strong&gt;；&lt;strong&gt;通过注册中心进行服务消费通知&lt;/strong&gt;；&lt;strong&gt;直连服务进行消费&lt;/strong&gt;。&lt;br&gt;服务消费端启动时，将自身的信息注册到注册中心的目录，同时还订阅服务提供方的目录，当服务提供方的 URL 发生更改时，实时获取新的数据。&lt;/p&gt;</summary>
    
    
    
    <category term="Dubbo" scheme="https://ytao.top/categories/Dubbo/"/>
    
    
    <category term="Dubbo" scheme="https://ytao.top/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo之服务暴露</title>
    <link href="https://ytao.top/2020/03/01/16-dubbo/"/>
    <id>https://ytao.top/2020/03/01/16-dubbo/</id>
    <published>2020-02-29T16:00:00.000Z</published>
    <updated>2023-10-10T14:18:14.206Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.ytao.top/dubbo.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文 Dubbo 使用版本<code>2.7.5</code><br>Dubbo 通过使用<code>dubbo:service</code>配置或<code>@service</code>在解析完配置后进行服务暴露，供服务消费者消费。<br>Dubbo 的服务暴露有两种：</p><ul><li>远程暴露</li><li>本地暴露</li></ul><p>可以通过<code>scope </code>显式指定暴露方式：</p><ul><li>none 不暴露</li><li>remote 远程暴露</li><li>local 本地暴露</li></ul><span id="more"></span><h1 id="服务暴露流程"><a href="#服务暴露流程" class="headerlink" title="服务暴露流程"></a>服务暴露流程</h1><p>下面是一个服务暴露的流程图：</p><p><img src="https://images.ytao.top/dubbo_rpc_export.jpg"></p><p><strong>ProxyFactory</strong> 是动态代理，用来创建 Invoker 对象，实现代理使用<code>JavassistProxyFactory</code>和<code>JdkProxyFactory</code>。<br><strong>Invoker</strong> 是一个服务对象实例，Dubbo 框架的实体域。它可以是一个本地的实现，一个远程的实现或一个集群的实现，可以向它发起 Invoker 调用。<br><strong>Protocol</strong> 是服务域，负责 Invoker 的生命周期管理，是 Invoker 暴露和引用的主要功能入口，对应该类的<code>export</code>和<code>refer</code>方法。<br><strong>Exporter</strong> 是根据不同协议暴露 Invoker 进行封装的类，它会根据不同的协议头进行识别（比如：<code>registry://</code>和<code>dubbo://</code>），调用对应<code>XXXProtocol</code>的<code>export()</code>方法。</p><p>从上图中可以看到，Dubbo 中服务暴露分为两个大步骤：第一步通过代理将服务实例转换成 Invoker，这就是通过我们常用的反射实现。第二步将 Invoker 根据具体的协议转换成 Exporter，这是就是我们要分析的核心。从这里可以看到 Dubbo 服务对象都是围绕 Invoker 进行工作。</p><h1 id="远程暴露"><a href="#远程暴露" class="headerlink" title="远程暴露"></a>远程暴露</h1><p>服务远程暴露从字面上理解，就是将服务跨网络进行远程通信，并非同一 JVM 中的服务进行调用。<br>服务最后都是转换成<code>org.apache.dubbo.config.spring.ServiceBean</code>，它的UML类图：</p><p><img src="https://images.ytao.top/dubbo_servicebean-uml.png"></p><p><code>ServiceBean</code>继承自<code>ServiceConfig</code>，服务在<code>ServiceConfig#doExportUrls</code>根据不同协议进行暴露。</p><p><img src="https://images.ytao.top/dubbo_serviceconfig_doexporturls.png"></p><p>通过获取所有注册中心实例（registryURLs）后，进行依次暴露，暴露操作在<code>doExportUrlsFor1Protocol</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doExportUrlsFor1Protocol</span><span class="params">(ProtocolConfig protocolConfig, List&lt;URL&gt; registryURLs)</span> &#123;</span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br><span class="line"><span class="comment">// 配置信息存入 map</span></span><br><span class="line"></span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取服务URL</span></span><br><span class="line"><span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> findConfigedHosts(protocolConfig, registryURLs, map);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">port</span> <span class="operator">=</span> findConfigedPorts(protocolConfig, name, map);</span><br><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(name, host, port, getContextPath(protocolConfig).map(p -&gt; p + <span class="string">&quot;/&quot;</span> + path).orElse(path), map);</span><br><span class="line">    </span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">scope</span> <span class="operator">=</span> url.getParameter(SCOPE_KEY);</span><br><span class="line"><span class="comment">// 如果 scope 配置为 none，则服务不进行暴露</span></span><br><span class="line"><span class="keyword">if</span> (!SCOPE_NONE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本地暴露</span></span><br><span class="line"><span class="keyword">if</span> (!SCOPE_REMOTE.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">exportLocal(url);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 远程暴露</span></span><br><span class="line"><span class="keyword">if</span> (!SCOPE_LOCAL.equalsIgnoreCase(scope)) &#123;</span><br><span class="line">    <span class="comment">// 判断是否有注册中心</span></span><br><span class="line"><span class="keyword">if</span> (CollectionUtils.isNotEmpty(registryURLs)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (URL registryURL : registryURLs) &#123;</span><br><span class="line">                    <span class="comment">//if protocol is only injvm ,not register</span></span><br><span class="line">                    <span class="keyword">if</span> (LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    url = url.addParameterIfAbsent(DYNAMIC_KEY, registryURL.getParameter(DYNAMIC_KEY));</span><br><span class="line">                    <span class="comment">// 获取监控URL</span></span><br><span class="line">                    <span class="type">URL</span> <span class="variable">monitorUrl</span> <span class="operator">=</span> ConfigValidationUtils.loadMonitor(<span class="built_in">this</span>, registryURL);</span><br><span class="line">                    <span class="keyword">if</span> (monitorUrl != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 追加监控上报地址，在拦截器上报数据</span></span><br><span class="line">                        url = url.addParameterAndEncoded(MONITOR_KEY, monitorUrl.toFullString());</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 日志打印</span></span><br><span class="line">                    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (url.getParameter(REGISTER_KEY, <span class="literal">true</span>)) &#123;</span><br><span class="line">                            logger.info(<span class="string">&quot;Register dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; url &quot;</span> + url + <span class="string">&quot; to registry &quot;</span> + registryURL);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            logger.info(<span class="string">&quot;Export dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; to url &quot;</span> + url);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// For providers, this is used to enable custom proxy to generate invoker</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">proxy</span> <span class="operator">=</span> url.getParameter(PROXY_KEY);</span><br><span class="line">                    <span class="keyword">if</span> (StringUtils.isNotEmpty(proxy)) &#123;</span><br><span class="line">                        registryURL = registryURL.addParameter(PROXY_KEY, proxy);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将服务对象转换成 Invoker</span></span><br><span class="line">                    Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));</span><br><span class="line">                    <span class="type">DelegateProviderMetaDataInvoker</span> <span class="variable">wrapperInvoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegateProviderMetaDataInvoker</span>(invoker, <span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 暴露服务，向注册中心注册服务，进入对应的 RegistryProtocol</span></span><br><span class="line">                    Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                    exporters.add(exporter);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 没有注册中心时</span></span><br><span class="line">                <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">                    logger.info(<span class="string">&quot;Export dubbo service &quot;</span> + interfaceClass.getName() + <span class="string">&quot; to url &quot;</span> + url);</span><br><span class="line">                &#125;</span><br><span class="line">                Invoker&lt;?&gt; invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, url);</span><br><span class="line">                <span class="type">DelegateProviderMetaDataInvoker</span> <span class="variable">wrapperInvoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DelegateProviderMetaDataInvoker</span>(invoker, <span class="built_in">this</span>);</span><br><span class="line">                <span class="comment">// 直接暴露服务</span></span><br><span class="line">                Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</span><br><span class="line">                exporters.add(exporter);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 存储Dubbo服务的元数据，元数据可以存储在远端配置中心和本地，默认是存储在本地</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@since</span> 2.7.0</span></span><br><span class="line"><span class="comment">             * ServiceData Store</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="type">WritableMetadataService</span> <span class="variable">metadataService</span> <span class="operator">=</span> WritableMetadataService.getExtension(url.getParameter(METADATA_KEY, DEFAULT_METADATA_STORAGE_TYPE));</span><br><span class="line">            <span class="keyword">if</span> (metadataService != <span class="literal">null</span>) &#123;</span><br><span class="line">                metadataService.publishServiceDefinition(url);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.urls.add(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是代码片段为暴露服务的核心，可以看到 scope 由三个值控制是否暴露和远程或本地暴露，默认远程和本地都暴露。<br>在远程调用中，分为<strong>使用注册中心暴露</strong>和<strong>直接暴露</strong>（默认dubbo协议），它们之间的区别在url上：</p><ul><li>无注册中心：dubbo:&#x2F;&#x2F;192.168.3.19:20880&#x2F;xxxx</li><li>有注册中心：**registry:&#x2F;&#x2F;127.0.0.1:2181&#x2F;org.apache.dubbo.registry.RegistryService?application&#x3D;provider&amp;dubbo&#x3D;2.0.2&amp;export&#x3D;**dubbo:&#x2F;&#x2F;192.168.3.19:20880&#x2F;xxxx</li></ul><p>无注册中心的直接暴露服务。<br>有注册中心的先创建注册中心，再得到 export 的服务地址，然后暴露服务，当服务暴露成功后把服务元数据注册到注册中心。</p><p>代码中<code>protocol#export</code>会根据服务 url 的请求头进行区分不同<code>XXXProtocol#export</code>的逻辑，比如。<br>目前 Dubbo 中有以下几种：</p><p><img src="https://images.ytao.top/dubbo_protocol_impl.png"></p><h1 id="本地暴露"><a href="#本地暴露" class="headerlink" title="本地暴露"></a>本地暴露</h1><p>同一个应用中，可能既要提供服务远程暴露给其他应用引用，也要给自身提供引用。如果只提供远程暴露的话，当自身应用需要引用自身的服务时，需要通过远程通信访问，那么这大大浪费网络资源。这是就需要用 injvm 协议暴露，就是我们所说的本地暴露，无需跨网络远程通信，可以更好的节省资源。<br>通过上面代码中，我们知道本地暴露调用的是<code>ServiceConfig#exportLocal</code>方法。</p><p><img src="https://images.ytao.top/dubbo_serviceconfig_exportlocal.png"></p><p>本地暴露会指定 injvm 协议，并且 host 指定为本地<code>127.0.0.1</code>和端口号为0。<br>protocol.export 调用 <code>InjvmProtocol#export</code> 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; Exporter&lt;T&gt; <span class="title function_">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">InjvmExporter</span>&lt;T&gt;(invoker, invoker.getUrl().getServiceKey(), exporterMap);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>export 中返回了 InjvmExporter 实例化对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InjvmExporter</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">AbstractExporter</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap;</span><br><span class="line"></span><br><span class="line">    InjvmExporter(Invoker&lt;T&gt; invoker, String key, Map&lt;String, Exporter&lt;?&gt;&gt; exporterMap) &#123;</span><br><span class="line">        <span class="built_in">super</span>(invoker);</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.exporterMap = exporterMap;</span><br><span class="line">        exporterMap.put(key, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unexport</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.unexport();</span><br><span class="line">        exporterMap.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本地暴露就比较简单，将 Invoker 直接保存在 InjvmExporter 的 exporterMap 中。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote><p>本篇对 Dubbo 的服务暴露流程进行了分析，核心点就是开篇图中的得到 Invoker 后转化到 Export。其中更多详细的地方，由于展开后篇幅太大，不能一一写到，会在今后相关的 Dubbo 文章再进行讲解。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://images.ytao.top/dubbo.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文 Dubbo 使用版本&lt;code&gt;2.7.5&lt;/code&gt;&lt;br&gt;Dubbo 通过使用&lt;code&gt;dubbo:service&lt;/code&gt;配置或&lt;code&gt;@service&lt;/code&gt;在解析完配置后进行服务暴露，供服务消费者消费。&lt;br&gt;Dubbo 的服务暴露有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;远程暴露&lt;/li&gt;
&lt;li&gt;本地暴露&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以通过&lt;code&gt;scope &lt;/code&gt;显式指定暴露方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;none 不暴露&lt;/li&gt;
&lt;li&gt;remote 远程暴露&lt;/li&gt;
&lt;li&gt;local 本地暴露&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Dubbo" scheme="https://ytao.top/categories/Dubbo/"/>
    
    
    <category term="Dubbo" scheme="https://ytao.top/tags/Dubbo/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch之映射常用操作</title>
    <link href="https://ytao.top/2020/01/15/15-elasticsearch-mapping/"/>
    <id>https://ytao.top/2020/01/15/15-elasticsearch-mapping/</id>
    <published>2020-01-14T16:00:00.000Z</published>
    <updated>2023-10-10T14:18:14.206Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.ytao.top/elasticsearch.png"></p><p>本文案例操作，建议先阅读我之前的文章<a href="https://ytao.top/2019/12/14/11-elasticsearch/">《ElasticSearch之安装及基本操作API》</a></p><blockquote><p>Mapping (映射)类似关系型数据库中的表的结构定义。我们将数据以 JSON 格式存入到 ElasticSearch 中后，在搜索引擎中 JSON 字段映射对应的类型，这时需要 mapping 来定义内容的类型。</p></blockquote><span id="more"></span><h1 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h1><p>JSON 数据类型映射到 ElasticSearch 定义的类型，常用的简单类型有：</p><table><thead><tr><th align="center">JSON类型</th><th align="center">ElasticSearch 类型</th></tr></thead><tbody><tr><td align="center">文本类型</td><td align="center">Text&#x2F;Keyword</td></tr><tr><td align="center">整数类型</td><td align="center">long&#x2F;integer</td></tr><tr><td align="center">浮点类型</td><td align="center">float&#x2F;double</td></tr><tr><td align="center">时间类型</td><td align="center">date</td></tr><tr><td align="center">布尔值</td><td align="center">boolean</td></tr><tr><td align="center">数组</td><td align="center">Text&#x2F;Keyword</td></tr></tbody></table><p>上面要注意的是时间类型，JSON 中并没有时间类型，这里主要指时间格式数据的类型。</p><h1 id="定义映射"><a href="#定义映射" class="headerlink" title="定义映射"></a>定义映射</h1><p>在关系型数据库中，存储数据之前，我们会先创建表结构，给字段指定一个存在的类型。同样 ElasticSearch 在进行数据存储前，也可以先定义好存储数据的 Mapping 结构。<br>先定义一个简单的 person Mapping：</p><p><img src="https://images.ytao.top/es-mapping-1.png"></p><p>上图中就是一个 Mapping 的定义，如果是在 ElasticSearch7 之前，mappings 里还有 _type 属性。</p><h1 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h1><p>当没有事先定义好 Mapping，添加数据时，ElasticSearch 会自动根据字段进行换算出对应的类型，但是换算出来的类型并不一定是我们想要的字段类型，还是需要人为的干预进行修改成想要的 Mapping。</p><h1 id="更新映射"><a href="#更新映射" class="headerlink" title="更新映射"></a>更新映射</h1><p>使用 <strong>dynamic</strong> 控制映射是否可以被更新。</p><h2 id="dynamic-true"><a href="#dynamic-true" class="headerlink" title="dynamic-true"></a>dynamic-true</h2><p>设置 dynamic 为<code>true</code>是默认 dynamic 的默认值，新增字段数据可以写入，同时也可以被索引，Mapping 结构也会被更新。</p><p><img src="https://images.ytao.top/es-dynamic-true.png"></p><p>添加数据，同时多添加一个没被定义的 <code>gender</code> 字段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向 person 中添加数据</span></span><br><span class="line">PUT person/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;uId&quot;</span>: 1,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;ytao&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: 18,</span><br><span class="line">  <span class="string">&quot;address&quot;</span>: <span class="string">&quot;广东省珠海市&quot;</span>,</span><br><span class="line">  <span class="string">&quot;birthday&quot;</span>: <span class="string">&quot;2020-01-15T12:00:00Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;money&quot;</span>: 108.2,</span><br><span class="line">  <span class="string">&quot;isStrong&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">&quot;gender&quot;</span>: <span class="string">&quot;男&quot;</span>    <span class="comment"># Mapping 中未定义的字段</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加成功，搜索 <code>gender</code> 字段：</p><p><img src="https://images.ytao.top/es-dynamic-true-search.png"></p><p>查看 Mapping 结构：</p><p><img src="https://images.ytao.top/es-dynamic-true-mapping.png"></p><p>新添加的字段值，在添加过程中 Mapping 已自动添加字段。</p><h2 id="dynamic-false"><a href="#dynamic-false" class="headerlink" title="dynamic-false"></a>dynamic-false</h2><p>设置 dynamic 为<code>false</code>时，新增字段数据可以写入，不可以被索引，Mapping 结构会被更新。<br>同样先将 dynamic 设置为 false，然后向里面添加数据，其他步骤和上面 true 操作一样。定义 Mapping，添加数据。<br>搜索 <code>gender</code> 字段：</p><p><img src="https://images.ytao.top/es-dynamic-false-search.png"></p><p>此时新增字段数据无法被索引，但数据可以写入。</p><p><img src="https://images.ytao.top/es-dynamic-false-search2.png"></p><p>Mappnig 也不会添加新增的字段：</p><p><img src="https://images.ytao.top/es-dynamic-false-mapping.png"></p><h2 id="dynamic-strict"><a href="#dynamic-strict" class="headerlink" title="dynamic-strict"></a>dynamic-strict</h2><p>设置 dynamic 为<code>strict</code>时，从字面上意思也可以看出，对于动态映射是较严格的，新增字段数据不可以写入，不可以被索引，Mapping 结构不会被更新。只能按照定义好的 Mapping 结构添加数据。<br>在添加新字段数据时，就马上会抛出异常：</p><p><img src="https://images.ytao.top/es-dynamic-strict-search.png"></p><h1 id="自动识别日期类型"><a href="#自动识别日期类型" class="headerlink" title="自动识别日期类型"></a>自动识别日期类型</h1><p>上文中，当 dynamic 设置为 true 时，添加新字段数据自动识别类型更新 Mapping，如果是日期类型的话，我们是可以指定识别的类型。<br>指定 person 的 <strong>dynamic_date_formats</strong> 格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PUT person/_mapping</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;dynamic_date_formats&quot;</span>: [<span class="string">&quot;yyyy/MM/dd&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是可以指定多个时间格式。<br>向 person 添加新数据，分别是 today 和 firstDate：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT person/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;today&quot;</span>: <span class="string">&quot;2020-01-15&quot;</span>,</span><br><span class="line">  <span class="string">&quot;firstDate&quot;</span>: <span class="string">&quot;2020/01/15&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加新字段数据后的 Mapping：</p><p><img src="https://images.ytao.top/es-dynamic_date_format.png"></p><p>由于上面我们指定了时间格式为 <code>yyyy/MM/dd</code> 时是可以识别为时间格式，所以 today 字段的值为 <code>yyyy-MM-dd</code> 格式无法识别为时间类型，判为 text 类型。</p><h1 id="多字段"><a href="#多字段" class="headerlink" title="多字段"></a>多字段</h1><p>Mapping 中可以定义 <strong>fields</strong> 多字段属性，以满足不同场景下的实现。比如 <code>address</code> 定义为 <code>text</code> 类型，fields 里面又有定义 <code>keyword</code> 类型，这里主要是区分两个不同不同使用场景。</p><ul><li><code>text</code> 会建立分词倒排索引，用于全文检索。</li><li><code>keyword</code> 不会建立分词倒排索引，用于排序和聚合。</li></ul><p>添加数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向 person 中添加数据</span></span><br><span class="line">PUT person/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;uId&quot;</span>: 1,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;ytao&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: 18,</span><br><span class="line">  <span class="string">&quot;address&quot;</span>: <span class="string">&quot;广东省珠海市&quot;</span>,</span><br><span class="line">  <span class="string">&quot;birthday&quot;</span>: <span class="string">&quot;2020-01-15T12:00:00Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;money&quot;</span>: 108.2,</span><br><span class="line">  <span class="string">&quot;isStrong&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询<code>address</code>数据。</p><p><img src="https://images.ytao.top/es-search-text.png"></p><p>查询<code>address.keyword</code>数据。</p><p><img src="https://images.ytao.top/es-search-keyword.png"></p><p>通过<code>keyword</code>检索时，由于不会建立分词索引，并没有获取到数据。</p><h1 id="控制索引"><a href="#控制索引" class="headerlink" title="控制索引"></a>控制索引</h1><p>在字段中使用 <strong>index</strong> 指定当前字段索引是否能被搜索到。指定类型为 boolean 类型，false 为不可搜索到，true 为可以搜索到。<br>先删除之前的 Mapping：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE person</span><br></pre></td></tr></table></figure><p>创建 Mapping，设置<code>name</code>属性的 <code>index</code> 为 false。</p><p><img src="https://images.ytao.top/es-mapping-2.png"></p><p>再次添加上面的数据后搜索<code>name</code>字段：</p><p><img src="https://images.ytao.top/es-index-error.png"></p><p>字段 index 设置 false 后，由于没有被索引，所以搜索无法获取到索引。</p><h1 id="空值处理"><a href="#空值处理" class="headerlink" title="空值处理"></a>空值处理</h1><p>现在向 ElasticSearch 中添加一条 address 为空的数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT person/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;uId&quot;</span>: 2,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Jack&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: 22,</span><br><span class="line">  <span class="string">&quot;address&quot;</span>: null,</span><br><span class="line">  <span class="string">&quot;birthday&quot;</span>: <span class="string">&quot;2020-01-15T12:00:00Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;money&quot;</span>: 68.7,</span><br><span class="line">  <span class="string">&quot;isStrong&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搜索 address.keyword 为空的数据：</p><p><img src="https://images.ytao.top/es-search-null-1.png"></p><p>搜索返回异常，默认是不被允许搜索 NUll。<br>这是需要在 Mapping 指定 <strong>null_value</strong> 属性，并且不能在<code>text</code>类型中声明。</p><p><img src="https://images.ytao.top/es-null_value.png"></p><p>搜索 address.keyword 为空的数据：</p><p><img src="https://images.ytao.top/es-search-null-2.png"></p><p>设置 <code>&quot;null_value&quot;: &quot;NULL&quot;</code> 后，空值可以处理搜索。</p><h1 id="聚合多个字段"><a href="#聚合多个字段" class="headerlink" title="聚合多个字段"></a>聚合多个字段</h1><p>聚合多个字段放到一个索引中，使用 <strong>copy_to</strong> 进行聚合。例如我们在多字段查询中，这是不需要对每个字段进行过滤筛选，只需对聚合字段即可。<br>在使用 copy_to 时，是通过指定聚合的名称实现。</p><p><img src="https://images.ytao.top/es-copy_to.png"></p><p>实际上，copy_to 不使用数组格式添加名称，也会自动转换成数据格式。</p><p>添加两条数据，待校验搜索：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 向 person 中添加数据</span></span><br><span class="line">PUT person/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;uId&quot;</span>: 1,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;ytao&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: 18,</span><br><span class="line">  <span class="string">&quot;address&quot;</span>: <span class="string">&quot;广东省珠海市&quot;</span>,</span><br><span class="line">  <span class="string">&quot;birthday&quot;</span>: <span class="string">&quot;2020-01-15T12:00:00Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;money&quot;</span>: 108.2,</span><br><span class="line">  <span class="string">&quot;isStrong&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT person/_doc/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;uId&quot;</span>: 2,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;杨广东&quot;</span>,</span><br><span class="line">  <span class="string">&quot;age&quot;</span>: 22,</span><br><span class="line">  <span class="string">&quot;address&quot;</span>: null,</span><br><span class="line">  <span class="string">&quot;birthday&quot;</span>: <span class="string">&quot;2020-01-15T12:00:00Z&quot;</span>,</span><br><span class="line">  <span class="string">&quot;money&quot;</span>: 68.7,</span><br><span class="line">  <span class="string">&quot;isStrong&quot;</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询 <code>full_name</code> 的值，会返回 name 和 address 相关的值的对象。</p><p><img src="https://images.ytao.top/es-copy_to-search.png"></p><p>从上面返回结果看到，_source 中的字段没有增加相应的 copy_to 字段名，所以 copy_to 只会拷贝字段内容至索引，并不会改变包含的字段。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>通过本文对创建 Mapping 文件的常用并且实用的操作介绍，也基本能掌握这些日常的使用。了解 Mapping 的功能操作，相信对存储时的设计也有一定帮助。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://images.ytao.top/elasticsearch.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;本文案例操作，建议先阅读我之前的文章&lt;a href=&quot;https://ytao.top/2019/12/14/11-elasticsearch/&quot;&gt;《ElasticSearch之安装及基本操作API》&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Mapping (映射)类似关系型数据库中的表的结构定义。我们将数据以 JSON 格式存入到 ElasticSearch 中后，在搜索引擎中 JSON 字段映射对应的类型，这时需要 mapping 来定义内容的类型。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="ElasticSearch" scheme="https://ytao.top/categories/ElasticSearch/"/>
    
    
    <category term="ElasticSearch" scheme="https://ytao.top/tags/ElasticSearch/"/>
    
    <category term="搜索引擎" scheme="https://ytao.top/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Redis5新特性Streams作消息队列</title>
    <link href="https://ytao.top/2020/01/06/14-redis-streams/"/>
    <id>https://ytao.top/2020/01/06/14-redis-streams/</id>
    <published>2020-01-05T16:00:00.000Z</published>
    <updated>2023-10-10T14:18:14.206Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.ytao.top/banner-14.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>Redis 5 新特性中，Streams 数据结构的引入，可以说它是在本次迭代中最大特性。它使本次 5.x 版本迭代中，Redis 作为消息队列使用时，得到更完善，更强大的原生支持，其中尤为明显的是持久化消息队列。同时，stream 借鉴了 kafka 的消费组模型概念和设计，使消费消息处理上更加高效快速。本文就 Streams 数据结构中常用 API 进行分析。</p></blockquote><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>本文所使用 Redis 版本为 5.0.5 。如果使用更早的 5.x 版本，有些 API 使用效果，与本文中描述略有不同。</p><h1 id="添加消息"><a href="#添加消息" class="headerlink" title="添加消息"></a>添加消息</h1><p>Streams 添加数据使用 <strong>XADD</strong> 指令进行添加，消息中的数据以 K-V 键值对的形式进行操作。一条消息可以存在多个键值对，添加命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XADD key ID field string [field string ...]</span><br></pre></td></tr></table></figure><span id="more"></span><p>其中 key 为 Streams 的名称，ID 为消息的唯一标志，不可重复，field string 就为键值对。下面我们就添加以 person 为名称的流，进行操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XADD person * name ytao des https://ytao.top</span><br></pre></td></tr></table></figure><p>上面添加案例中，ID 使用 * 号复制，这里代表着服务端自动生成 Id，添加后返回数据 <code>&quot;1578238486193-0&quot;</code></p><p>这里自动生成的 Id 格式为 <code>&lt;millisecondsTime&gt;-&lt;sequenceNumber&gt;</code><br>Id 是由两部分组成：</p><ol><li>millisecondsTime 为当前服务器时间毫秒时间戳。</li><li>sequenceNumber 当前序列号，取值来源于当前毫秒内，生成消息的顺序，默认从 0 开始加 1 递增。</li></ol><p>比如：1578238486193-3 表示在 1578238486193 毫秒的时间戳时，添加的第 4 条消息。</p><p>除了服务端自动生成 Id 方式外，也支持指定 Id 的生成，但是指定 Id 有以下条件限制：</p><ol><li>Id 中的前后部分必须为数字。</li><li>最小 Id 为 0-1，不能为 0-0，但是 2-0，3-0 …. 是被允许的。</li><li>添加的消息，Id 的前半部分不能比存在 Id 最大的值小，Id 后半部分不能比存在前半部分相同的最大后半部分小。</li></ol><p>否则，当不满足上述条件时，添加后会抛出异常：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(error) ERR The ID specified <span class="keyword">in</span> XADD is equal or smaller than the target stream top item</span><br></pre></td></tr></table></figure><p>实际上，当添加一条消息时，会进行两部操作。第一步，先判断如果不存在 Streams，则创建 Streams 的名称，再添加消息到 Streams 中。即使添加消息时，由于 Id 异常，也可以在 Redis 中存在以当前 Streams 的名称。<br>Streams 中 Id 也可作为指针使用，因为它是一个有序的标记。</p><p>生产中，如果这样使用添加消息，会存在一个问题，那就是消息数量太大时，会使服务宕机。这里 Streams 的设计初期也有考虑到这个问题，那就是可以指定 Streams 的容量。如果容量操作这个设定的值，就会对调旧的消息。在添加消息时，设置 <code>MAXLEN</code> 参数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XADD person MAXLEN 5 * name ytao des https://ytao.top</span><br></pre></td></tr></table></figure><p>这样就指定该了 Streams 中的容量为 5 条消息。也可使用 <strong>XTRIM</strong> 截取消息，从小到大剔除多余的消息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XTRIM person MAXLEN 8</span><br></pre></td></tr></table></figure><h1 id="消息数量"><a href="#消息数量" class="headerlink" title="消息数量"></a>消息数量</h1><p>查看消息数量使用 <strong>XLEN</strong> 指令进行操作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XLEN key</span><br></pre></td></tr></table></figure><p>例：查看 person 流中的消息数量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; XLEN person</span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure><h1 id="查询消息"><a href="#查询消息" class="headerlink" title="查询消息"></a>查询消息</h1><p>查询 Streams 中的消息使用 <strong>XRANGE</strong> 和 <strong>XREVRANGE</strong> 指令。</p><h2 id="XRANGE"><a href="#XRANGE" class="headerlink" title="XRANGE"></a>XRANGE</h2><p>查询数据时，可以按照指定 Id 范围进行查询，XRANGE 查询指令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XRANGE key start end [COUNT count]</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>key 为 Streams 的名称</li><li>start 为范围查询开始 Id，包含本 Id。</li><li>start 为范围查询结束 Id，包含本 Id。</li><li>Count 为查询返回最大的消息数量，非必填。</li></ul><p>这里 start 和 end 有<code>-</code>和<code>+</code>两个非指定值，他们分别表示无穷小和无穷大，所以当使用这个两个值时，会查询出全部的消息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; XRANGE person - +</span><br><span class="line">1) 1) <span class="string">&quot;0-1&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;ytao&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;https://ytao.top&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;0-2&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;luffy&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;valiant!&quot;</span></span><br><span class="line">3) 1) <span class="string">&quot;2-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;gaga&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;fishion!&quot;</span></span><br></pre></td></tr></table></figure><p>上面查询的消息数据，可以看到是按照先进先出的顺序查询出来的。</p><p>使用 COUNT 指定查询返回的数量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询所有的消息，并且返回一条数据</span></span><br><span class="line">&gt; XRANGE person - + COUNT 1</span><br><span class="line">1) 1) <span class="string">&quot;0-1&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;ytao&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;https://ytao.top&quot;</span></span><br></pre></td></tr></table></figure><p>在范围查询中，Id 的后半部分可省略，后半部分中的数据会全部查询到。</p><h2 id="XREVRANGE"><a href="#XREVRANGE" class="headerlink" title="XREVRANGE"></a>XREVRANGE</h2><p><strong>XREVRANGE</strong> 的查询和 <strong>XRANGE</strong> 指令中的使用类似，但查询的 start 和 end 参数顺序进行了调换：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREVRANGE key end start [COUNT count]</span><br></pre></td></tr></table></figure><p>使用案例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&gt; XREVRANGE person +  -</span><br><span class="line">1) 1) <span class="string">&quot;2-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;gaga&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;fishion!&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;0-2&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;luffy&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;valiant!&quot;</span></span><br><span class="line">3) 1) <span class="string">&quot;0-1&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;ytao&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;https://ytao.top&quot;</span></span><br></pre></td></tr></table></figure><p>查询后的结果与 <strong>XRANGE</strong> 的结果顺序刚好相反，其他都一样，这两个指令可进行消息的升序和降序的返回。</p><h1 id="删除消息"><a href="#删除消息" class="headerlink" title="删除消息"></a>删除消息</h1><p>删除消息使用 <strong>XDEL</strong> 指令操作，只需指定将要删除的 Streams 名称和 Id 即可，支持一次删除多个消息 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XDEL key ID [ID ...]</span><br></pre></td></tr></table></figure><p>删除案例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询所有消息</span></span><br><span class="line">&gt; XRANGE person - +</span><br><span class="line">1) 1) <span class="string">&quot;0-1&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;ytao&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;https://ytao.top&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;0-2&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;luffy&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;valiant!&quot;</span></span><br><span class="line">3) 1) <span class="string">&quot;2-0&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;gaga&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;fishion!&quot;</span></span><br><span class="line"><span class="comment"># 删除消息      </span></span><br><span class="line">&gt; XDEL person 2-0</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line"><span class="comment"># 再次查询删除后的所有消息</span></span><br><span class="line">&gt; XRANGE person - +</span><br><span class="line">1) 1) <span class="string">&quot;0-1&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;ytao&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;https://ytao.top&quot;</span></span><br><span class="line">2) 1) <span class="string">&quot;0-2&quot;</span></span><br><span class="line">   2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">      2) <span class="string">&quot;luffy&quot;</span></span><br><span class="line">      3) <span class="string">&quot;des&quot;</span></span><br><span class="line">      4) <span class="string">&quot;valiant!&quot;</span></span><br><span class="line"><span class="comment"># 查询删除后的长度      </span></span><br><span class="line">&gt; XLEN person</span><br><span class="line">(<span class="built_in">integer</span>) 2            </span><br></pre></td></tr></table></figure><p>从上面可以看到，删除消息后，长度也会减少相应的数量。</p><h1 id="消费消息"><a href="#消费消息" class="headerlink" title="消费消息"></a>消费消息</h1><p>在 Redis 的 PUB&#x2F;SUB 中，我们是通过订阅来消费消息，在 Streams 数据结构中，同样也能实现同等功能，当没有新的消息时，可进行阻塞等待。不仅支持单独消费，而且还可以支持群组消费。</p><h2 id="单独消费"><a href="#单独消费" class="headerlink" title="单独消费"></a>单独消费</h2><p>单独消费使用 <strong>XREAD</strong> 指令。可以看到，下面命令中，STREAMS，key, 以及 ID 为必填项。ID 表示将要读取大于该 ID 的消息。当 ID 值使用 <code>$</code> 赋予时，表示已存在消息的最大 Id 值。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure><p>上面的 <code>COUNT</code> 参数用来指定读取的最大数量，与 <strong>XRANGE</strong> 的用法一样。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; XREAD COUNT 1 STREAMS person 0</span><br><span class="line">1) 1) <span class="string">&quot;person&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;0-1&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;ytao&quot;</span></span><br><span class="line">            3) <span class="string">&quot;des&quot;</span></span><br><span class="line">            4) <span class="string">&quot;https://ytao.top&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; XREAD COUNT 2 STREAMS person 0</span><br><span class="line">1) 1) <span class="string">&quot;person&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;0-1&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;ytao&quot;</span></span><br><span class="line">            3) <span class="string">&quot;des&quot;</span></span><br><span class="line">            4) <span class="string">&quot;https://ytao.top&quot;</span></span><br><span class="line">      2) 1) <span class="string">&quot;0-2&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;luffy&quot;</span></span><br><span class="line">            3) <span class="string">&quot;des&quot;</span></span><br><span class="line">            4) <span class="string">&quot;valiant!&quot;</span></span><br></pre></td></tr></table></figure><p>在 <strong>XREAD</strong> 里面还有个 <code>BLOCK</code> 参数，这个是用来阻塞订阅消息的，<code>BLOCK</code> 携带的参数为阻塞时间，单位为毫秒，如果在这个时间内没有新的消息消费，那么就会释放该阻塞。当这里的时间指定为 0 时，会一直阻塞，直到有新的消息来消费到。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 窗口 1 开启阻塞，等待新消息的到来</span></span><br><span class="line">&gt; XREAD BLOCK 0 STREAMS person $</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另开一个连接窗口 2，添加一条新的消息</span></span><br><span class="line">&gt; XADD person 2-2 name tao des coder</span><br><span class="line"><span class="string">&quot;2-2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 窗口 1，获取到有新的消息来消费，并且带有阻塞的时间</span></span><br><span class="line">&gt; XREAD BLOCK 0 STREAMS person $</span><br><span class="line">1) 1) <span class="string">&quot;person&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;2-2&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;tao&quot;</span></span><br><span class="line">            3) <span class="string">&quot;des&quot;</span></span><br><span class="line">            4) <span class="string">&quot;coder&quot;</span></span><br><span class="line">(60.81s)</span><br></pre></td></tr></table></figure><p>当使用 <strong>XREAD</strong> 进行顺序消费时，需要额外记录下读取到位置的 Id，方便下次继续消费。</p><h2 id="群组消费"><a href="#群组消费" class="headerlink" title="群组消费"></a>群组消费</h2><p>群组消费的主要目的也就是为了分流消息给不同的客户端处理，以更高效的速率处理消息。为达到这一肝功能需求，我们需要做三件事：<strong>创建群组</strong>，<strong>群组读取消息</strong>，<strong>向服务端确认消息以处理</strong>。</p><h3 id="群组操作"><a href="#群组操作" class="headerlink" title="群组操作"></a>群组操作</h3><p>操作群组使用 <strong>XGROUP</strong> 指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP [CREATE key groupname id-or-$] [SETID key id-or-$] [DESTROY key groupname] [DELCONSUMER key groupname consumername]</span><br></pre></td></tr></table></figure><p>上面命令中，包含操作有：</p><ul><li>CREATE 创建消费组。</li><li>SETID 修改下一个处理消息的 Id。</li><li>DESTROY 销毁消费组。</li><li>DELCONSUMER 删除消费组中指定的消费者。</li></ul><p>我们当前需要使用的是创建消费组：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以当前存在的最大 Id 作为消费起始 </span></span><br><span class="line">&gt; XGROUP CREATE person group1 $</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h3 id="群组读取消息"><a href="#群组读取消息" class="headerlink" title="群组读取消息"></a>群组读取消息</h3><p>群组读取使用 <strong>XREADGROUP</strong> 指令，<code>COUNT</code>和<code>BLOCK</code>的使用类似 <strong>XREAD</strong> 的操作，只是多了个群组和消费者的指定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure><p>由于群组消费和单独消费类似，这里只进行个阻塞分析，这里 Id 也有个特殊值<code>&gt;</code>，表示还未进行消费的消息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 窗口 1，消费群组中，taotao 消费者建立阻塞监听</span></span><br><span class="line">XREADGROUP GROUP group1 taotao BLOCK 0 STREAMS person &gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 窗口 2，消费群组中，yangyang 消费者建立阻塞监听 </span></span><br><span class="line">XREADGROUP GROUP group1 yangyang BLOCK 0 STREAMS person &gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 窗口 3，添加消费消息</span></span><br><span class="line">&gt; XADD person 3-1 name tony des 666</span><br><span class="line"><span class="string">&quot;3-1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 窗口 1，读取到新消息，此时 窗口 2 没有任何反应</span></span><br><span class="line">&gt; XREADGROUP GROUP group1 taotao BLOCK 0 STREAMS person &gt;</span><br><span class="line">1) 1) <span class="string">&quot;person&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;3-1&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;tony&quot;</span></span><br><span class="line">            3) <span class="string">&quot;des&quot;</span></span><br><span class="line">            4) <span class="string">&quot;666&quot;</span></span><br><span class="line">(77.54s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 窗口 3，再次添加消费消息</span></span><br><span class="line">&gt; XADD person 3-2 name james des abc!</span><br><span class="line"><span class="string">&quot;3-2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 窗口 2，读取到新消息，此时 窗口 1 没有任何反应</span></span><br><span class="line">&gt; XREADGROUP GROUP group1 yangyang BLOCK 0 STREAMS person &gt;</span><br><span class="line">1) 1) <span class="string">&quot;person&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;3-2&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;james&quot;</span></span><br><span class="line">            3) <span class="string">&quot;des&quot;</span></span><br><span class="line">            4) <span class="string">&quot;abc!&quot;</span></span><br><span class="line">(76.36s)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上执行流程中，group1 群组中有两个消费者，当添加两条消息后，这两个消费者轮流消费。</p><h3 id="消息ACK"><a href="#消息ACK" class="headerlink" title="消息ACK"></a>消息ACK</h3><p>消息消费后，为避免再次重复消费，这是需要向服务端发送 ACK，确保消息被消费后的标记。<br>例如下列情况，我们上面我们将最新两条消息已进行了消费，但是当我们再次读取消息时，还是被读到：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;  XREADGROUP GROUP group1 yangyang STREAMS person 0</span><br><span class="line">1) 1) <span class="string">&quot;person&quot;</span></span><br><span class="line">   2) 1) 1) <span class="string">&quot;3-2&quot;</span></span><br><span class="line">         2) 1) <span class="string">&quot;name&quot;</span></span><br><span class="line">            2) <span class="string">&quot;james&quot;</span></span><br><span class="line">            3) <span class="string">&quot;des&quot;</span></span><br><span class="line">            4) <span class="string">&quot;abc!&quot;</span></span><br></pre></td></tr></table></figure><p>这时，我们使用 <strong>XACK</strong> 指令告诉服务器，我们已处理的消息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XACK key group ID [ID ...]0</span><br></pre></td></tr></table></figure><p>让服务器标记 3-2 已处理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; XACK person group1 3-2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure><p>再次获取群组读取消息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;  XREADGROUP GROUP group1 yangyang STREAMS person 0</span><br><span class="line">1) 1) <span class="string">&quot;person&quot;</span></span><br><span class="line">   2) (empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure><p>队列中没有了可读消息。<br>除了上面以讲解到的 API 外，查看消费群组信息可使用 <strong>XINFO</strong> 指令查看，本文不做分析。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>上面对 Streams 常用 API 进行了分析，我们可以感受到 Redis 在消息队列支持的道路上，也越来越强大。如果使用过它的 PUB&#x2F;SUB 功能的话，就会感受到 5.x 迭代正是将你的一些痛点进行了优化。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://images.ytao.top/banner-14.png&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Redis 5 新特性中，Streams 数据结构的引入，可以说它是在本次迭代中最大特性。它使本次 5.x 版本迭代中，Redis 作为消息队列使用时，得到更完善，更强大的原生支持，其中尤为明显的是持久化消息队列。同时，stream 借鉴了 kafka 的消费组模型概念和设计，使消费消息处理上更加高效快速。本文就 Streams 数据结构中常用 API 进行分析。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h1&gt;&lt;p&gt;本文所使用 Redis 版本为 5.0.5 。如果使用更早的 5.x 版本，有些 API 使用效果，与本文中描述略有不同。&lt;/p&gt;
&lt;h1 id=&quot;添加消息&quot;&gt;&lt;a href=&quot;#添加消息&quot; class=&quot;headerlink&quot; title=&quot;添加消息&quot;&gt;&lt;/a&gt;添加消息&lt;/h1&gt;&lt;p&gt;Streams 添加数据使用 &lt;strong&gt;XADD&lt;/strong&gt; 指令进行添加，消息中的数据以 K-V 键值对的形式进行操作。一条消息可以存在多个键值对，添加命令格式：&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;XADD key ID field string [field string ...]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Redis" scheme="https://ytao.top/categories/Redis/"/>
    
    
    <category term="Redis" scheme="https://ytao.top/tags/Redis/"/>
    
    <category term="Streams" scheme="https://ytao.top/tags/Streams/"/>
    
  </entry>
  
  <entry>
    <title>Netty之缓冲区ByteBuf解读（二）</title>
    <link href="https://ytao.top/2019/12/31/13-netty-buf/"/>
    <id>https://ytao.top/2019/12/31/13-netty-buf/</id>
    <published>2019-12-30T16:00:00.000Z</published>
    <updated>2023-10-10T14:18:14.206Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.ytao.top/banner-13.jpg"></p><blockquote><p>上篇介绍了 ByteBuf 的简单读写操作以及读写指针的基本介绍，本文继续对 ByteBuf 的基本操作进行解读。</p></blockquote><h1 id="读写指针回滚"><a href="#读写指针回滚" class="headerlink" title="读写指针回滚"></a>读写指针回滚</h1><p>这里的 demo 例子还是使用上节使用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.buffer(<span class="number">15</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;ytao公众号&quot;</span>;</span><br><span class="line">buf.writeBytes(content.getBytes());</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;\nwrite: ridx=%s widx=%s cap=%s&quot;</span>, buf.readerIndex(), buf.writerIndex(), buf.capacity()));</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] dst = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">buf.readBytes(dst);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;\nread(4): ridx=%s widx=%s cap=%s&quot;</span>, buf.readerIndex(), buf.writerIndex(), buf.capacity()));</span><br></pre></td></tr></table></figure><span id="more"></span><p>进入 readBytes 方法，可以看到每次读取的时候，指针是累加的，如图：</p><p><img src="https://images.ytao.top/bytebuf-readbytes.png"></p><p>但是，有时我们可能需要对当前操作进行回滚，让指针回到之前的位置。这时，mark 和 reset 搭配使用，可以实现该操作需求。<br>mark 用来记录可能需要回滚的当前位置，reset 是将指针回滚至 mark 记录的值。<br>比如，接着面的 demo，再读取三个字节，然后回滚读取三个字节的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">buf.markReaderIndex();</span><br><span class="line">dst = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">3</span>];</span><br><span class="line">buf.readBytes(dst);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;\nmarkRead and read(3): ridx=%s widx=%s cap=%s&quot;</span>, buf.readerIndex(), buf.writerIndex(), buf.capacity()));</span><br><span class="line"></span><br><span class="line">buf.resetReaderIndex();</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;\nresetReaderIndex: ridx=%s widx=%s cap=%s&quot;</span>, buf.readerIndex(), buf.writerIndex(), buf.capacity()));</span><br></pre></td></tr></table></figure><p>先将读索引进行 mark，然后读取内容，在调用读取的 reset，指针索引如下：</p><p><img src="https://images.ytao.top/bytebuf-mark-reset-read.png"></p><p>读指针累加到 7 后，又重新回滚至 4 的位置。</p><p>同样，写指针也是如此操作进行回滚。所以 mark 和 reset 都有一个读和写。</p><p><img src="https://images.ytao.top/bytebuf-mark-method.png"></p><p>以及</p><p><img src="https://images.ytao.top/bytebuf-reset-method.png"></p><h1 id="读写指针清空"><a href="#读写指针清空" class="headerlink" title="读写指针清空"></a>读写指针清空</h1><p>将读写指针清为初始值，使用 clear() 函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.buffer(<span class="number">15</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;ytao公众号&quot;</span>;</span><br><span class="line">buf.writeBytes(content.getBytes());</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;\nwrite: ridx=%s widx=%s cap=%s&quot;</span>, buf.readerIndex(), buf.writerIndex(), buf.capacity()));</span><br><span class="line">buf.markWriterIndex();</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] dst = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">buf.readBytes(dst);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;\nread(4): ridx=%s widx=%s cap=%s&quot;</span>, buf.readerIndex(), buf.writerIndex(), buf.capacity()));</span><br><span class="line">buf.markReaderIndex();</span><br><span class="line"></span><br><span class="line">buf.clear();</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;\nclear: ridx=%s widx=%s cap=%s&quot;</span>, buf.readerIndex(), buf.writerIndex(), buf.capacity()));</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://images.ytao.top/bytebuf-clear.png"></p><p>clear 只会将指针的位置重置为初始值，并不会清空缓冲区里的内容，如下图。同时，也可使用 mark 和 reset 进行验证，这里不再进行演示。</p><p><img src="https://images.ytao.top/bytebuf-clear-method.png"></p><h1 id="查找字符位置"><a href="#查找字符位置" class="headerlink" title="查找字符位置"></a>查找字符位置</h1><p>查找字符是在很多场景下，都会使用到，比如前面文章讲过的粘包&#x2F;拆包处理，就有根据字符串进行划分包数据。其实现原理就是根据查找指定字符进行读取。<br>ByteBuf 也提供多种不同的查找方法进行处理：</p><h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><p>indexOf 函数，拥有三个参数，查找开始位置索引 <code>fromIndex</code>， 查询位置最大的索引 <code>toIndex</code>，查找字节 <code>value</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fromIndex 为 0， toIndex 为 13， value 为 a</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> buf.indexOf(<span class="number">0</span>, <span class="number">13</span>, (<span class="type">byte</span>)<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;[a]索引位置：&quot;</span>+i);</span><br></pre></td></tr></table></figure><p>在索引 0~13 中返回查找的字符 a 索引位置：</p><p><img src="https://images.ytao.top/bytebuf-search-indexOf.png"></p><p>indexOf 源码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ByteBuf 实现类</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex, <span class="type">byte</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ByteBufUtil.indexOf(<span class="built_in">this</span>, fromIndex, toIndex, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ByteBufUtil 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(ByteBuf buffer, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex, <span class="type">byte</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">// 判断查询起始和终点索引大小</span></span><br><span class="line">    <span class="keyword">if</span> (fromIndex &lt;= toIndex) &#123;</span><br><span class="line">        <span class="keyword">return</span> firstIndexOf(buffer, fromIndex, toIndex, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastIndexOf(buffer, fromIndex, toIndex, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">firstIndexOf</span><span class="params">(ByteBuf buffer, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex, <span class="type">byte</span> value)</span> &#123;</span><br><span class="line">    fromIndex = Math.max(fromIndex, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &gt;= toIndex || buffer.capacity() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从起始索引进行遍历到终点索引，如果这区间有查找的字节，就返回第一个字节的位置，否则返回 -1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> fromIndex; i &lt; toIndex; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer.getByte(i) == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lastIndexOf</span><span class="params">(ByteBuf buffer, <span class="type">int</span> fromIndex, <span class="type">int</span> toIndex, <span class="type">byte</span> value)</span> &#123;</span><br><span class="line">    fromIndex = Math.min(fromIndex, buffer.capacity());</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span> || buffer.capacity() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  从起始索引进行遍历到终点索引倒着遍历，获取的是查找区间的最后一个字节位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> fromIndex - <span class="number">1</span>; i &gt;= toIndex; i --) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buffer.getByte(i) == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bytesBefore"><a href="#bytesBefore" class="headerlink" title="bytesBefore"></a>bytesBefore</h2><p>bytesBefore 函数拥有三个重载方法：</p><p><img src="https://images.ytao.top/bytebuf-bytesBefore-list.png"></p><p>bytesBefore 函数的实现，就是在 indexOf 上进行一层查找区间的封装，最后都是在 indexOf 中实现查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">bytesBefore</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> length, <span class="type">byte</span> value)</span> &#123;</span><br><span class="line">    <span class="comment">// 最终都进入 indexOf 中查找</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> indexOf(index, index + length, value);</span><br><span class="line">    <span class="keyword">if</span> (endIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回相对查找起始索引的位置</span></span><br><span class="line">    <span class="keyword">return</span> endIndex - index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>这里返回的是相对查找起始索引的位置。</p><h2 id="forEachByte"><a href="#forEachByte" class="headerlink" title="forEachByte"></a>forEachByte</h2><p>forEachByte 函数有两个重载方法：</p><p><img src="https://images.ytao.top/bytebuf-forEachByte-list.png"></p><p>这里涉及到一个 ByteBufProcessor 接口，这个是对一些常用的字节，其中包括 空，空白键，换行等等进行了抽象定义。<br>forEachByte 函数实现主要逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">forEachByteAsc0</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> length, ByteBufProcessor processor)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (processor == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;processor&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">endIndex</span> <span class="operator">=</span> index + length;</span><br><span class="line"><span class="comment">// 起始 -&gt; 终点索引，进行遍历</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 如果可以匹配上字节，返回该索引位置</span></span><br><span class="line">        <span class="keyword">if</span> (processor.process(_getByte(i))) &#123;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; endIndex);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    PlatformDependent.throwException(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找区间遍历完没有匹配上，返回 -1</span></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="forEachByteDesc"><a href="#forEachByteDesc" class="headerlink" title="forEachByteDesc"></a>forEachByteDesc</h2><p>forEachByteDesc 也是有两个重载方法：</p><p><img src="https://images.ytao.top/bytebuf-forEachByteDesc-list.png"></p><p>forEachByteDesc 从函数名字可以看出，指的倒序查找。意指从查找区间最大索引到最小索引进行遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">forEachByteDesc0</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> length, ByteBufProcessor processor)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (processor == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;processor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从最大索引开始，进行遍历</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index + length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (processor.process(_getByte(i))) &#123;</span><br><span class="line">                i --;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// 直到 i 小于查找区间最小索引值时，遍历完成</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (i &gt;= index);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        PlatformDependent.throwException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有找到指定字节返回 -1</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查找操作的具体实现还是比较好理解，进入代码查看实现一般都能读懂。</p><h1 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h1><p>ByteBuf 复制后会生成一个新的 ByteBuf 对象。<br><strong>copy()</strong> 整个对象被复制，其所有数据都是该对象自身维护，与旧对象无任何关联关系。包括缓冲区内容，但是该方法的的容量默认为旧 buf 的可读区间大小，读索引为 0，写索引为旧数据写索引的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> buf.copy();</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;\ncopy: ridx=%s widx=%s cap=%s&quot;</span>, buf2.readerIndex(), buf2.writerIndex(), buf2.capacity()));</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://images.ytao.top/bytebuf-copy-1.png"></p><p><strong>copy(int index, int length)</strong> 为指定复制的起始位置及长度，其他与上面 copy() 类似。<br><strong>duplicate()</strong> 这个也是复制，但是与 copy 函数不同的是，复制后生成的 ByteBuf 和旧的 ByteBuf 是共享一份缓冲区内容的。它复制的只是自己可以单独维护的一份索引。并且它复制的默认容量也是和旧的一样。</p><h1 id="对象引用-回收"><a href="#对象引用-回收" class="headerlink" title="对象引用&#x2F;回收"></a>对象引用&#x2F;回收</h1><p>ByteBuf 对象被引用后，可以调用 <strong>retain()</strong> 函数进行累计计数。每调用一次 retain() 则会 +1。<br>其在 AbstractReferenceCountedByteBuf 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> ByteBuf <span class="title function_">retain</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">refCnt</span> <span class="operator">=</span> <span class="built_in">this</span>.refCnt;</span><br><span class="line">        <span class="keyword">if</span> (refCnt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalReferenceCountException</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 达到最大值时，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (refCnt == Integer.MAX_VALUE) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalReferenceCountException</span>(Integer.MAX_VALUE, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保证线程安全，这里 CAS 进行累加</span></span><br><span class="line">        <span class="keyword">if</span> (refCntUpdater.compareAndSet(<span class="built_in">this</span>, refCnt, refCnt + <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(T obj, <span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="comment">// unsafe 为jdk的 Unsafe 类</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(obj, offset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，可以进行添加多个引用，自己指定数量，<strong>retain(int increment)</strong> 带参函数实现，和上面 +1 实现思路一样，代码就不贴出来了。</p><p>ByteBuf 在申请内存使用完后，需要对其进行释放，否则可能会造成资源浪费及内存泄漏的风险。这也是 ByteBuf 自己实现的一套有效回收机制。<br>释放的函数为 **release()**，它的实现就是每次 -1。直到为 1 时，调用释放函数 <strong>deallocate()</strong> 进行释放。<br>其在 AbstractReferenceCountedByteBuf 实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">refCnt</span> <span class="operator">=</span> <span class="built_in">this</span>.refCnt;</span><br><span class="line">        <span class="keyword">if</span> (refCnt == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalReferenceCountException</span>(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 引用数量 -1</span></span><br><span class="line">        <span class="keyword">if</span> (refCntUpdater.compareAndSet(<span class="built_in">this</span>, refCnt, refCnt - <span class="number">1</span>)) &#123;</span><br><span class="line">            当引用数量为 <span class="number">1</span> 时，符合释放条件</span><br><span class="line">            <span class="keyword">if</span> (refCnt == <span class="number">1</span>) &#123;</span><br><span class="line">                deallocate();</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，释放也支持一次释放多个引用数量，也是通过指定数量，传递给 <strong>release(int decrement)</strong> 进行引用数量的减少并释放对象。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>本文对 ByteBuf 中最基本，最常用 API 进行的解读，这也是在实际开发中或阅读相关代码时，可能会遇到的基本 API，通过两篇文章的说明，相信对 ByteBuf 的基本使用不会存在太大问题，还有些未分析到的 API，根据自己对 ByteBuf 已有的理解，差不多也能进行分析。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://images.ytao.top/banner-13.jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上篇介绍了 ByteBuf 的简单读写操作以及读写指针的基本介绍，本文继续对 ByteBuf 的基本操作进行解读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;读写指针回滚&quot;&gt;&lt;a href=&quot;#读写指针回滚&quot; class=&quot;headerlink&quot; title=&quot;读写指针回滚&quot;&gt;&lt;/a&gt;读写指针回滚&lt;/h1&gt;&lt;p&gt;这里的 demo 例子还是使用上节使用的。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;ByteBuf&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; Unpooled.buffer(&lt;span class=&quot;number&quot;&gt;15&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;content&lt;/span&gt; &lt;span class=&quot;operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;quot;ytao公众号&amp;quot;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;buf.writeBytes(content.getBytes());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(String.format(&lt;span class=&quot;string&quot;&gt;&amp;quot;&#92;nwrite: ridx=%s widx=%s cap=%s&amp;quot;&lt;/span&gt;, buf.readerIndex(), buf.writerIndex(), buf.capacity()));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;type&quot;&gt;byte&lt;/span&gt;[] dst = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;byte&lt;/span&gt;[&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;buf.readBytes(dst);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(String.format(&lt;span class=&quot;string&quot;&gt;&amp;quot;&#92;nread(4): ridx=%s widx=%s cap=%s&amp;quot;&lt;/span&gt;, buf.readerIndex(), buf.writerIndex(), buf.capacity()));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Netty" scheme="https://ytao.top/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://ytao.top/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty之缓冲区ByteBuf解读（一）</title>
    <link href="https://ytao.top/2019/12/23/12-netty-buf/"/>
    <id>https://ytao.top/2019/12/23/12-netty-buf/</id>
    <published>2019-12-22T16:00:00.000Z</published>
    <updated>2023-10-10T14:18:14.206Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.ytao.top/luffy-s.jpg"></p><blockquote><p>Netty 在数据传输过程中，会使用缓冲区设计来提高传输效率。虽然，Java 在 NIO 编程中已提供 ByteBuffer 类进行使用，但是在使用过程中，其编码方式相对来说不太友好，也存在一定的不足。所以高性能的 Netty 框架实现了一套更加强大，完善的 ByteBuf，其设计理念也是堪称一绝。</p></blockquote><span id="more"></span><h1 id="ByteBuffer-分析"><a href="#ByteBuffer-分析" class="headerlink" title="ByteBuffer 分析"></a>ByteBuffer 分析</h1><p>在分析 ByteBuf 之前，先简单讲下 ByteBuffer 类的操作。便于更好理解 ByteBuf 。</p><p>ByteBuffer 的读写操作共用一个位置指针，读写过程通过以下代码案例分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分配一个缓冲区，并指定大小</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line"><span class="comment">// 设置当前最大缓存区大小限制</span></span><br><span class="line">buffer.limit(<span class="number">15</span>);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;allocate: pos=%s lim=%s cap=%s&quot;</span>, buffer.position(), buffer.limit(), buffer.capacity()));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;ytao公众号&quot;</span>;</span><br><span class="line"><span class="comment">// 向缓冲区写入数据</span></span><br><span class="line">buffer.put(content.getBytes());</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;put: pos=%s lim=%s cap=%s&quot;</span>, buffer.position(), buffer.limit(), buffer.capacity()));</span><br></pre></td></tr></table></figure><p>其中打印了缓冲区三个参数，分别是：</p><ul><li>position 读写指针位置</li><li>limit 当前缓存区大小限制</li><li>capacity 缓冲区大小</li></ul><p>打印结果：</p><p><img src="https://images.ytao.top/buf-buffer-put.png"></p><p>当我们写入内容后，读写指针值为 13，<code>ytao公众号</code>英文字符占 1 个 byte，每个中文占 4 个 byte，刚好 13，小于设置的当前缓冲区大小 15。</p><p>接下来，读取内容里的 ytao 数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buffer.flip();</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;flip: pos=%s lim=%s cap=%s&quot;</span>, buffer.position(), buffer.limit(), buffer.capacity()));</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] readBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">buffer.get(readBytes);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;get(4): pos=%s lim=%s cap=%s&quot;</span>, buffer.position(), buffer.limit(), buffer.capacity()));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">readContent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(readBytes);</span><br><span class="line">System.out.println(<span class="string">&quot;readContent:&quot;</span>+readContent);</span><br></pre></td></tr></table></figure><p>读取内容需要创建个 byte 数组来接收，并制定接收的数据大小。</p><p>在写入数据后再读取内容，必须主动调用<code>ByteBuffer#flip</code>或<code>ByteBuffer#clear</code>。</p><p><code>ByteBuffer#flip</code>它会将写入数据后的指针位置值作为当前缓冲区大小，再将指针位置归零。会使写入数据的缓冲区改为待取数据的缓冲区，也就是说，读取数据会从刚写入的数据第一个索引作为读取数据的起始索引。</p><p><code>ByteBuffer#flip</code>相关源码：</p><p><img src="https://images.ytao.top/buf-buffer-flip.png"></p><p><code>ByteBuffer#clear</code>则会重置 limit 为默认值，与 capacity 大小相同。</p><p><img src="https://images.ytao.top/buf-buffer-clear.png"></p><p>接下读取剩余部分内容：</p><p>第二次读取的时候，可使用<code>buffer#remaining</code>来获取大于或等于剩下的内容的字节大小，该函数实现为<code>limit - position</code>，所以当前缓冲区域一定在这个值范围内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">readBytes = <span class="keyword">new</span> <span class="title class_">byte</span>[buffer.remaining()];</span><br><span class="line">buffer.get(readBytes);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;get(remaining): pos=%s lim=%s cap=%s&quot;</span>, buffer.position(), buffer.limit(), buffer.capacity()));</span><br></pre></td></tr></table></figure><p>打印结果：</p><p><img src="https://images.ytao.top/buf-buffer-get-remaining.png"></p><p>以上操作过程中，索引变化如图：</p><p><img src="https://images.ytao.top/buf-buffer-idx-change.png"></p><h1 id="ByteBuf-读写操作"><a href="#ByteBuf-读写操作" class="headerlink" title="ByteBuf 读写操作"></a>ByteBuf 读写操作</h1><p>ByteBuf 有读写指针是分开的，分别是<code>buf#readerIndex</code>和<code>buf#writerIndex</code>，当前缓冲器大小<code>buf#capacity</code>。</p><p>这里缓冲区被两个指针索引和容量划分为三个区域：</p><ul><li>0 -&gt; readerIndex 为已读缓冲区域，已读区域可重用节约内存，readerIndex 值大于或等于 0</li><li>readerIndex -&gt; writerIndex 为可读缓冲区域，writerIndex 值大于或等于 readerIndex</li><li>writerIndex -&gt; capacity 为可写缓冲区域，capacity 值大于或等于 writerIndex</li></ul><p>如下图所示：</p><p><img src="https://images.ytao.top/buf-area.png"></p><h2 id="分配缓冲区"><a href="#分配缓冲区" class="headerlink" title="分配缓冲区"></a>分配缓冲区</h2><p>ByteBuf 分配一个缓冲区，仅仅给定一个初始值就可以。默认是 256。初始值不像 ByteBuffer 一样是最大值，ByteBuf 的最大值是<code>Integer.MAX_VALUE</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.buffer(<span class="number">13</span>);</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;init: ridx=%s widx=%s cap=%s&quot;</span>, buf.readerIndex(), buf.writerIndex(), buf.capacity()));</span><br></pre></td></tr></table></figure><p>打印结果：</p><p><img src="https://images.ytao.top/buf-init.png"></p><h2 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h2><p>ByteBuf 写操作和 ByteBuffer 类似，只是写指针是单独记录的，ByteBuf 的写操作支持多种类型，有以下多个API：</p><p><img src="https://images.ytao.top/buf-write-type.png"></p><p>写入字节数组类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;ytao公众号&quot;</span>;</span><br><span class="line">buf.writeBytes(content.getBytes());</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;write: ridx=%s widx=%s cap=%s&quot;</span>, buf.readerIndex(), buf.writerIndex(), buf.capacity()));</span><br></pre></td></tr></table></figure><p>打印结果：</p><p><img src="https://images.ytao.top/buf-write-console.png"></p><p>索引示意图：</p><p><img src="https://images.ytao.top/buf-write-idx.png"></p><h2 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h2><p>一样的，ByteBuf 写操作和 ByteBuffer 类似，只是写指针是单独记录的，ByteBuf 的读操作支持多种类型，有以下多个API：</p><p><img src="https://images.ytao.top/buf-read-type.png"></p><p>从当前 readerIndex 位置读取四个字节内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span>[] dst = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">buf.readBytes(dst);</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(dst));</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;read(4): ridx=%s widx=%s cap=%s&quot;</span>, buf.readerIndex(), buf.writerIndex(), buf.capacity()));</span><br></pre></td></tr></table></figure><p>打印结果：</p><p><img src="https://images.ytao.top/buf-read-console.png"></p><p>索引示意图：</p><p><img src="https://images.ytao.top/buf-read-idx.png"></p><h1 id="ByteBuf-动态扩容"><a href="#ByteBuf-动态扩容" class="headerlink" title="ByteBuf 动态扩容"></a>ByteBuf 动态扩容</h1><p>通过上面的 ByteBuffer 分配缓冲区例子，向里面添加 [ytao公众号ytao公众号] 内容，使写入的内容大于 limit 的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">buffer.limit(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;ytao公众号ytao公众号&quot;</span>;</span><br><span class="line">buffer.put(content.getBytes());</span><br></pre></td></tr></table></figure><p>运行结果异常：</p><p><img src="https://images.ytao.top/buf-buffer-overflow.png"></p><p>内容字节大小超过了 limit 的值时，缓冲区溢出异常，所以我们每次写入数据前，得检查缓区大小是否有足够空间，这样对编码上来说，不是一个好的体验。</p><p>使用 ByteBuf 添加同样的内容，给定同样的初始容器大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> Unpooled.buffer(<span class="number">15</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;ytao公众号ytao公众号&quot;</span>;</span><br><span class="line">buf.writeBytes(content.getBytes());</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;write: ridx=%s widx=%s cap=%s&quot;</span>, buf.readerIndex(), buf.writerIndex(), buf.capacity()));</span><br></pre></td></tr></table></figure><p>打印运行结果:</p><p><img src="https://images.ytao.top/buf-write-over-console.png"></p><p>通过上面打印信息，可以看到 cap 从设置的 15 变为了 64，当我们容器大小不够时，就是进行扩容，接下来我们分析扩容过程中是如何做的。<br>进入 writeBytes 里面：</p><p><img src="https://images.ytao.top/buf-over-code1.png"></p><p>校验写入内容长度：</p><p><img src="https://images.ytao.top/buf-over-code2.png"></p><p>在可写区域检查里：</p><ul><li>如果写入内容为空，抛出非法参数异常。</li><li>如果写入内容大小小于或等于可写区域大小，则返回当前缓冲区，当中的<code>writableBytes()</code>函数为可写区域大小<code>capacity - writerIndex</code></li><li>如果写入内容大小大于最大可写区域大小，则抛出索引越界异常。</li><li>最后剩下条件的就是写入内容大小大于可写区域，小于最大区域大小，则分配一个新的缓冲区域。</li></ul><p><img src="https://images.ytao.top/buf-over-code3.png"></p><p>在容量不足，重新分配缓冲区的里面，以 4M 为阀门：</p><ul><li>如果待写内容刚好为 4M, 那么就分配 4M 的缓冲区。</li><li>如果待写内容超过这个阀门且与阀门值之和不大于最大容量值，就分配(阀门值+内容大小值)的缓冲区；如果超过这个阀门且与阀门值之和大于最大容量值，则分配最大容量的缓冲区。</li><li>如果待写内容不超过阀门值且大于 64，那么待分配缓冲区大小就以 64 的大小进行倍增，直到相等或大于待写内容。</li><li>如果待写内容不超过阀门值且不大于 64，则返回待分配缓冲区大小为 64。</li></ul><p><img src="https://images.ytao.top/buf-over-code4.png"></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><blockquote><p>Netty 实现的缓冲区，八个基本类型中，除了布尔类型，其他7种都有自己对应的 Buffer，但是实际使用过程中， ByteBuf 才是我们尝试用的，它可兼容任何类型。ByteBuf 在 Netty 体系中是最基础也是最重要的一员，要想更好掌握和使用 Netty，先理解并掌握 ByteBuf 是必需条件之一。 </p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://images.ytao.top/luffy-s.jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Netty 在数据传输过程中，会使用缓冲区设计来提高传输效率。虽然，Java 在 NIO 编程中已提供 ByteBuffer 类进行使用，但是在使用过程中，其编码方式相对来说不太友好，也存在一定的不足。所以高性能的 Netty 框架实现了一套更加强大，完善的 ByteBuf，其设计理念也是堪称一绝。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Netty" scheme="https://ytao.top/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://ytao.top/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch之安装及基本操作API</title>
    <link href="https://ytao.top/2019/12/14/11-elasticsearch/"/>
    <id>https://ytao.top/2019/12/14/11-elasticsearch/</id>
    <published>2019-12-13T16:00:00.000Z</published>
    <updated>2023-10-10T14:18:14.206Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.ytao.top/elasticsearch.png"></p><blockquote><p>ElasticSearch 是目前非常流行的搜索引擎，对海量数据搜索是非常友好，并且在高并发场景下，也能发挥出稳定，快速特点。也是大数据和索搜服务的开发人员所极力追捧的中间件。虽然 ElasticSearch 深受大家的喜爱，但是它的迭代速度之快，所以在相关社区老是有听说到学不动了的话语，也正是这种不断完善，才能拥有现在的社区活跃。我使用 ElasticSearch 时，从 5.x 到  6.x 版本，再到现在接触到 7.x 版本。从版本升级中，也看到了 ElasticSearch 对主流技术变化的拥抱，最明显的是新版 JDK 版本的支持及容器技术的支持。</p></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p><strong>本文基于目前最新版本<code>ElasticSearch-7.5.0</code>进行操作，如官网下载太慢，可在【ytao公众号】中发送<code>es</code>获取下载链接。</strong></p><span id="more"></span><p>安装环境及本文相关包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">操作系统CentOS 7.5 64位</span><br><span class="line">ElasticSearch 7.5.0</span><br><span class="line">Kinbana 7.5.0</span><br></pre></td></tr></table></figure><h2 id="JDK-环境"><a href="#JDK-环境" class="headerlink" title="JDK 环境"></a>JDK 环境</h2><p>ElasticSearch 在 7.x 中自带 JDK 环境，所以现在不一定要安装 JDK。默认是先判断当前服务器是否安装 JDK，如果安装了就使用服务器已安装的 JDK，否则会使用自带的 JDK，当然这个也是可以手动设置。</p><h2 id="创建启动账号"><a href="#创建启动账号" class="headerlink" title="创建启动账号"></a>创建启动账号</h2><p>由于 ElasticSearch 默认是不支持 root 账号权限启动，所以第一步要先创建启动账号。<br>创建一个 ElasticSearch 的运行组 es:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd es</span><br></pre></td></tr></table></figure><p>在 es 组中创建用户：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd elastic -g es </span><br></pre></td></tr></table></figure><p>设置新用户密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd elastic</span><br></pre></td></tr></table></figure><p>给解压出的 ElasticSearch 包授权：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chown</span> -R elastic:es elasticsearch-7.5.0</span><br></pre></td></tr></table></figure><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>进入到<code>/elasticsearch-7.5.0</code>目录，在<code>config</code>目录里有个<code>elasticsearch.yml</code>文件，修改里面当前需要的配置。</p><ul><li>cluster.name 是所属集群的名称</li><li>node.name 当前节点名称</li><li>network.host 当前节点所绑定地址，绑定到<code>0.0.0.0</code>所有的访问</li><li>http.port 对外提供服务的端口号</li><li>path.data 数据存储目录，这个我一般不适用默认目录，但是要给自定义的目录授权</li><li>path.log 日志目录，和 path.data 类似配置</li></ul><p>另外一个重要的配置，在当前目录中的<code>jvm.options</code>文件设置。<br>这里设置堆内存大小，建议设置机器内存的 50% 大小。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms4g</span><br><span class="line">-Xmx4g</span><br></pre></td></tr></table></figure><p>其他配置暂时没用到，暂不分析，今后的文章中用到再进行讲解。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>安装配置文件设置的值默认启动，直接执行<code>./bin/elasticsearch</code>，果然不出乎所意料，启动异常。</p><p><img src="https://images.ytao.top/elasticsearch-start-error.png"></p><p>上图中抛了两个异常。</p><ul><li>第一个是说虚拟内存太小，至少需要 262144。</li><li>第二个当前默认配置不适合，[discovery.seed_hosts, discovery.seed_providers, cluster.initial_master_nodes]配置中至少有一个配置。</li></ul><p>现在就增大服务器虚拟内存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 编辑 sysctl.conf 文件</span><br><span class="line">vim /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line"># 在 sysctl.conf 中添加</span><br><span class="line">vm.max_map_count=262144</span><br><span class="line"></span><br><span class="line"># 查看刚设置的是否生效</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>设置 cluster.initial_master_nodes 配置参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cluster.initial_master_nodes: [<span class="string">&quot;node-1&quot;</span>]</span><br></pre></td></tr></table></figure><p>再次启动完成后，没有异常抛出，访问<code>ip:9200</code>，返回数据信息，其中包括集群名称，节点名，版本信息等等：</p><p><img src="https://images.ytao.top/elasticsearch-start-success.png"></p><h1 id="基本操作API"><a href="#基本操作API" class="headerlink" title="基本操作API"></a>基本操作API</h1><p>在进行 API 操作前先安装 kibana，以下命令执行将全部在 kibana 中执行。解压 kibana 后，在<code>kibana.yml</code>中设置 ElasticSearch 地址<code>elasticsearch.hosts: [&quot;http://ip:9200&quot;]</code>。通过<code>bin/kibana</code>进行启动。安装比较简单，这里不做详细阐述。</p><h2 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>创建 person 索引例子，number_of_shards 为分片数量，number_of_replicas 为索引的副本数，这里主要演示创建索引时可设置一些相关参数，且为非必填项。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">PUT /person</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;mappings&quot;</span> : &#123; </span><br><span class="line">   <span class="string">&quot;properties&quot;</span>: &#123;</span><br><span class="line">     <span class="string">&quot;name&quot;</span> : &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="string">&quot;fields&quot;</span> : &#123;</span><br><span class="line">          <span class="string">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">            <span class="string">&quot;ignore_above&quot;</span> : 256  // 长度超过ignore_above设定的值，不会被索引或存储</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;settings&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;number_of_shards&quot;</span>: 1,</span><br><span class="line">    <span class="string">&quot;number_of_replicas&quot;</span>: 1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行命令结果：</p><p><img src="https://images.ytao.top/elasticsearch-put-index.png"></p><h3 id="查询索引"><a href="#查询索引" class="headerlink" title="查询索引"></a>查询索引</h3><p>使用 GET 请求方式查询索引信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /person</span><br></pre></td></tr></table></figure><p>返回结果</p><p><img src="https://images.ytao.top/elasticsearch-get-index.png"></p><h3 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h3><p>使用 DELETE 请求方式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 删除 person 索引</span></span><br><span class="line">DELETE /person</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除全部索引</span></span><br><span class="line">DELETE /_all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通配符删除</span></span><br><span class="line">DELETE /person*</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="mapping-操作"><a href="#mapping-操作" class="headerlink" title="mapping 操作"></a>mapping 操作</h2><p>查询 person 索引的 mapping ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /person/_mapping</span><br></pre></td></tr></table></figure><p>向 person 索引中添加 remark 字段，之前 mapping 中的 name 不会被删除，。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /person/_mapping</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;properties&quot;</span> : &#123;</span><br><span class="line">      <span class="string">&quot;remark2&quot;</span> : &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span> : <span class="string">&quot;text&quot;</span>,</span><br><span class="line">        <span class="string">&quot;fields&quot;</span> : &#123;</span><br><span class="line">        <span class="string">&quot;keyword&quot;</span> : &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span> : <span class="string">&quot;keyword&quot;</span>,</span><br><span class="line">          <span class="string">&quot;ignore_above&quot;</span> : 256</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h2><h3 id="添加文档"><a href="#添加文档" class="headerlink" title="添加文档"></a>添加文档</h3><p>添加文档有两种方式，第一种就是使用指定索引的 type 添加文档，7.x开始，type 指定只能是 _doc 值，同时也是不支持多 type 的（ps：之前使用type主要用来将索引逻辑分区）。第二种就是使用 _create 进行创建数据。</p><h4 id="index-方式添加文档"><a href="#index-方式添加文档" class="headerlink" title="index 方式添加文档"></a>index 方式添加文档</h4><p>使用<code>_doc</code> API向 person 中添加文档：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /person/_doc/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>:<span class="string">&quot;ytao&quot;</span>,</span><br><span class="line">  <span class="string">&quot;blog&quot;</span>:<span class="string">&quot;公众号 ytao&quot;</span>,</span><br><span class="line">  <span class="string">&quot;remark&quot;</span>:<span class="string">&quot;https://ytao.top&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加文档后返回的数据：</p><p><img src="https://images.ytao.top/elasticsearch-put-doc.png"></p><p>上面命令执行过程，如果索引或 mapping 不存在，都会自动创建。这里的 id 我们也可以自动生成，但是请求不能使用 PUT 方式，要改为 POST 方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /person/_doc/</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>:<span class="string">&quot;ytao&quot;</span>,</span><br><span class="line">  <span class="string">&quot;blog&quot;</span>:<span class="string">&quot;公众号 ytao&quot;</span>,</span><br><span class="line">  <span class="string">&quot;remark&quot;</span>:<span class="string">&quot;https://ytao.top&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上面我们插入 id 为 1 的文档重复执行，那么会先删除掉旧的文档，再引用新的文档，并且所对应的<code>_version</code>版本号值会较之前的 +1。</p><h4 id="create-方式添加文档"><a href="#create-方式添加文档" class="headerlink" title="create 方式添加文档"></a>create 方式添加文档</h4><p>使用<code>_create</code> API向 person 添加文档：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /person/_create/2</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>:<span class="string">&quot;yangtao&quot;</span>,</span><br><span class="line">  <span class="string">&quot;blog&quot;</span>:<span class="string">&quot;ytao&#x27;s blog&quot;</span>,</span><br><span class="line">  <span class="string">&quot;remark&quot;</span>:<span class="string">&quot;coder&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 id 必须指明，否则添加失败，并且文档中已存在的 id 不能进行添加。</p><h3 id="获取和查询文档"><a href="#获取和查询文档" class="headerlink" title="获取和查询文档"></a>获取和查询文档</h3><h4 id="根据-id-获取文档"><a href="#根据-id-获取文档" class="headerlink" title="根据 id 获取文档"></a>根据 id 获取文档</h4><p>使用 GET 获取文档：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /person/_doc/1</span><br></pre></td></tr></table></figure><p>返回数据中：</p><p><img src="https://images.ytao.top/elasticsearch-get.png"></p><h4 id="根据字段进行查询"><a href="#根据字段进行查询" class="headerlink" title="根据字段进行查询"></a>根据字段进行查询</h4><p>使用<code>_search</code> API进行查询，这里暂时不做深入讲解。<br>查询 name 为 ytao 的文档，并且通过<code>from=0&amp;size=2</code>分页查询。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># q 为查询参数，查询的字段和值用 : 进行分割</span></span><br><span class="line">GET /person/_search?q=name:ytao&amp;from=0&amp;size=2</span><br></pre></td></tr></table></figure><p>返回结果：</p><p><img src="https://images.ytao.top/elasticsearch-simple-search.png"></p><h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><p>更新文档使用 <code>_update</code> API进行更新。<strong>更新内容必须包含在<code>doc</code>中</strong>。更新对源数据只能是添加或修改字段，这也是和使用<code>_doc</code>添加数据的区别，不是通过删除旧的文档进行更新的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST /person/_update/1</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;doc&quot;</span>:&#123;</span><br><span class="line">    <span class="string">&quot;blog&quot;</span>:<span class="string">&quot;ytao&#x27;s blog&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><p>文档删除使用 DELETE 请求，然后指定 id：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /person/_doc/1</span><br></pre></td></tr></table></figure><h3 id="批量操作文档"><a href="#批量操作文档" class="headerlink" title="批量操作文档"></a>批量操作文档</h3><p>批量处理可以一次请求中处理多个任务，使用<code>_bulk</code> API进行。<br>下面就以索引添加方式添加一个文档到索引中，然后更新文档中 blog 字段为例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST _bulk</span><br><span class="line">&#123;&quot;index&quot;:&#123;&quot;_index&quot;:&quot;person&quot;, &quot;_id&quot;:1&#125;&#125;</span><br><span class="line">&#123;&quot;name&quot;:&quot;ytao&quot;,&quot;blog&quot;:&quot;公众号 ytao&quot;,&quot;remark&quot;:&quot;https://ytao.top&quot;&#125;</span><br><span class="line">&#123;&quot;update&quot;:&#123;&quot;_index&quot;:&quot;person&quot;, &quot;_id&quot;:1&#125;&#125;</span><br><span class="line">&#123;&quot;doc&quot;:&#123;&quot;blog&quot;:&quot;ytao&#x27;s blog&quot;&#125;&#125;</span><br></pre></td></tr></table></figure><p>返回结果中，按每一个操作分别返回结果信息，当其中有请求错误时，不会影响其他请求操作。</p><p><img src="https://images.ytao.top/elasticsearch-bulk.png"></p><h3 id="批量获取文档"><a href="#批量获取文档" class="headerlink" title="批量获取文档"></a>批量获取文档</h3><p>批量获取文档，使用<code>_mget</code> API进行，通过一次指定多个文档 id，进行请求。<br>例如在 person 索引中获取 id 为 1,2 的文档：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST _mget</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;docs&quot;</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;person&quot;</span>,</span><br><span class="line">      <span class="string">&quot;_id&quot;</span>: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;_index&quot;</span>: <span class="string">&quot;person&quot;</span>,</span><br><span class="line">      <span class="string">&quot;_id&quot;</span>: 2</span><br><span class="line">    &#125; </span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果：</p><p><img src="https://images.ytao.top/elasticsearch-mget.png"></p><h3 id="批量查询文档"><a href="#批量查询文档" class="headerlink" title="批量查询文档"></a>批量查询文档</h3><p>批量查询文档，使用<code>_msearch</code> API进行，将多个查询整合到一个请求中。<br>下面就是分别在指定索引中查询的不同条件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET /person/_msearch</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:<span class="string">&quot;person&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;query&quot;</span>:&#123;<span class="string">&quot;match&quot;</span>:&#123;<span class="string">&quot;blog&quot;</span>:<span class="string">&quot;ytao&#x27;s blog&quot;</span>&#125;&#125;&#125;</span><br><span class="line">&#123;<span class="string">&quot;index&quot;</span>:<span class="string">&quot;person&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;query&quot;</span>:&#123;<span class="string">&quot;match&quot;</span>:&#123;<span class="string">&quot;remark&quot;</span>:<span class="string">&quot;coder&quot;</span>&#125;&#125;&#125;</span><br></pre></td></tr></table></figure><p>返回结果：</p><p><img src="https://images.ytao.top/elasticsearch-simple-msearch.png"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>本文对 ElasticSearch 的最基础的，常用的操作 API，这里已经介绍完毕。要想学习 ElasticSearch，建议从 API 操作入手，千万别上来就直接拿着代码就干，虽然各语言都已提供相关工具包，但是这些封装也都是基于 API 上的。更多的 API 在今后文章涉及时再进行分析。</p></blockquote><p>更多 API 相关信息，建议查阅官网，这里有比较详细的介绍：<br><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.5/rest-apis.html">https://www.elastic.co/guide/en/elasticsearch/reference/7.5/rest-apis.html</a> </p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://images.ytao.top/elasticsearch.png&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ElasticSearch 是目前非常流行的搜索引擎，对海量数据搜索是非常友好，并且在高并发场景下，也能发挥出稳定，快速特点。也是大数据和索搜服务的开发人员所极力追捧的中间件。虽然 ElasticSearch 深受大家的喜爱，但是它的迭代速度之快，所以在相关社区老是有听说到学不动了的话语，也正是这种不断完善，才能拥有现在的社区活跃。我使用 ElasticSearch 时，从 5.x 到  6.x 版本，再到现在接触到 7.x 版本。从版本升级中，也看到了 ElasticSearch 对主流技术变化的拥抱，最明显的是新版 JDK 版本的支持及容器技术的支持。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;本文基于目前最新版本&lt;code&gt;ElasticSearch-7.5.0&lt;/code&gt;进行操作，如官网下载太慢，可在【ytao公众号】中发送&lt;code&gt;es&lt;/code&gt;获取下载链接。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="ElasticSearch" scheme="https://ytao.top/categories/ElasticSearch/"/>
    
    
    <category term="ElasticSearch" scheme="https://ytao.top/tags/ElasticSearch/"/>
    
    <category term="搜索引擎" scheme="https://ytao.top/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"/>
    
  </entry>
  
  <entry>
    <title>Netty中粘包/拆包处理</title>
    <link href="https://ytao.top/2019/12/09/10-netty/"/>
    <id>https://ytao.top/2019/12/09/10-netty/</id>
    <published>2019-12-08T16:00:00.000Z</published>
    <updated>2023-10-10T14:18:14.206Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://images.ytao.top/10.jpg"></p><blockquote><p>TCP 是基于流传输的协议，请求数据在其传输的过程中是没有界限区分，所以我们在读取请求的时候，不一定能获取到一个完整的数据包。如果一个包较大时，可能会切分成多个包进行多次传输。同时，如果存在多个小包时，可能会将其整合成一个大包进行传输。这就是 TCP 协议的粘包&#x2F;拆包概念。</p></blockquote><span id="more"></span><p><strong>本文基于 Netty5 进行分析</strong></p><h1 id="粘包-拆包描述"><a href="#粘包-拆包描述" class="headerlink" title="粘包&#x2F;拆包描述"></a>粘包&#x2F;拆包描述</h1><p>假设当前有<code>123</code>和<code>abc</code>两个数据包，那么他们传输情况示意图如下：</p><p><img src="https://images.ytao.top/netty-tcp.png"></p><ul><li>I 为正常情况，两次传输两个独立完整的包。</li><li>II 为粘包情况，<code>123</code>和<code>abc</code>封装成了一个包。</li><li>III 为拆包情况，图中的描述是将<code>123</code>拆分成了<code>1</code>和<code>23</code>，并且<code>1</code>和<code>abc</code>一起传输。<code>123</code>和<code>abc</code>也可能是<code>abc</code>进行拆包。甚至<code>123</code>和<code>abc</code>进行多次拆分也有可能。</li></ul><h1 id="Netty-粘包-拆包问题"><a href="#Netty-粘包-拆包问题" class="headerlink" title="Netty 粘包&#x2F;拆包问题"></a>Netty 粘包&#x2F;拆包问题</h1><p>为突出 Netty 的粘包&#x2F;拆包问题，这里通过例子进行重现问题，以下为突出问题的主要代码：</p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端网络事件的读写操作类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Created by YangTao.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 接收消息计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// client端消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        i++;</span><br><span class="line">        </span><br><span class="line">        System.out.print(msg);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对每条读取到的消息进行打数标记</span></span><br><span class="line">        System.out.println(<span class="string">&quot;================== [&quot;</span>+ i +<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="comment">// 发送应答消息给客户端</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">rmsg</span> <span class="operator">=</span> Unpooled.copiedBuffer(String.valueOf(i).getBytes());</span><br><span class="line">        ctx.write(rmsg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他操作 .......</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端发送数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Created by YangTao.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .option(ChannelOption.TCP_NODELAY, <span class="literal">true</span>)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">                            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());</span><br><span class="line">                            pipeline.addLast(<span class="string">&quot;logger&quot;</span>, <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO));</span><br><span class="line">                            pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ClientHandler</span>());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.connect(HOST, PORT).channel();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= <span class="number">300</span>)&#123;</span><br><span class="line">                channel.writeAndFlush(String.format(<span class="string">&quot;【时间 %s: \t%s】&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), i));</span><br><span class="line">                <span class="comment">// 打印发送请求的次数</span></span><br><span class="line">                System.out.println(i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">             <span class="keyword">if</span> (group != <span class="literal">null</span>)</span><br><span class="line">                 group.shutdownGracefully();</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，我们第一反应理解的是，如果非异常情况下客户端所有数据发送成功，并且服务端全部接收到。那么从打印信息中可以看到客户端的发送次数<code>i</code>和服务端的接收消息计数<code>i</code>应该是相同的数。那么下面通过运行程序，查看打印结果。</p><p><img src="https://images.ytao.top/netty-e-1.png"></p><p>如上图所示，<code>【】</code>中的最后一个数字与<code>[]</code>中数字对上的是已独立完整的包接收到<strong>（粘包&#x2F;拆包示意图中的情况 I）</strong>。但是<code>【】</code>中为<code>37</code>和<code>38</code>的出现了粘包情况<strong>（粘包&#x2F;拆包示意图中的情况 II）</strong>，两条数据粘合在一起。</p><p><img src="https://images.ytao.top/netty-e-2.png"></p><p>上图中可以看到<code>【】</code>中<code>167</code>的数据被拆分为了两部分（图中画绿线数据），该情况为拆包<strong>（粘包&#x2F;拆包示意图中的情况 III）</strong>。</p><p>上面程序没有考虑到 TCP 的粘包&#x2F;拆包问题，所以如果是我们实际应用的程序的话，不能保证数据的正常情况，就会导致程序异常。</p><h1 id="Netty-解决粘包-拆包问题"><a href="#Netty-解决粘包-拆包问题" class="headerlink" title="Netty 解决粘包&#x2F;拆包问题"></a>Netty 解决粘包&#x2F;拆包问题</h1><h2 id="LineBasedFrameDecoder-换行符处理"><a href="#LineBasedFrameDecoder-换行符处理" class="headerlink" title="LineBasedFrameDecoder 换行符处理"></a>LineBasedFrameDecoder 换行符处理</h2><p>Netty 的强大，方便，简单使用的优势，在粘包&#x2F;拆包问题上也提供了多种编解码解决方案，并且很容易理解和掌握。<br>这里使用 LineBasedFrameDecoder 和 StringDecoder（将接收到的对象转换成字符串） 来解决粘包&#x2F;拆包问题。<br>只需在服务端和客户端分别添加 LineBasedFrameDecoder 和 StringDecoder解码器，因为是双向会话，所以两端都要添加，由于我一开始就添加 StringDecoder 编码器，所以只需添加 LineBasedFrameDecoder 就够了。<br>服务端：</p><p><img src="https://images.ytao.top/netty-decode-s.png"></p><p>客户端：</p><p><img src="https://images.ytao.top/netty-decode-c.png"></p><p>服务端网络事件操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务端网络事件的读写操作类</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Created by YangTao.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServerHandler</span> <span class="keyword">extends</span> <span class="title class_">ChannelHandlerAdapter</span> &#123;</span><br><span class="line">    <span class="comment">// 接收消息计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// client端消息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        i++;</span><br><span class="line">        </span><br><span class="line">        System.out.print(msg);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对每条读取到的消息进行打数标记</span></span><br><span class="line">        System.out.println(<span class="string">&quot;================== [&quot;</span>+ i +<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="comment">// 发送应答消息给客户端</span></span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">rmsg</span> <span class="operator">=</span> Unpooled.copiedBuffer(String.valueOf(i + System.getProperty(<span class="string">&quot;line.separator&quot;</span>)).getBytes());</span><br><span class="line">        ctx.write(rmsg);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 其他操作 .......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端发送数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端发送数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Created by YangTao.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NettyClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 连接操作 .......</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取 channel</span></span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channel();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= <span class="number">300</span>)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> String.format(<span class="string">&quot;【时间 %s: \t%s】&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>(), i) + System.getProperty(<span class="string">&quot;line.separator&quot;</span>);</span><br><span class="line">                <span class="type">byte</span>[] bytes = str.getBytes();</span><br><span class="line">                <span class="comment">// 写入缓冲区</span></span><br><span class="line">                buf = Unpooled.buffer(bytes.length);</span><br><span class="line">                buf.writeBytes(bytes);</span><br><span class="line">                channel.writeAndFlush(buf);</span><br><span class="line">                <span class="comment">// 打印发送请求的次数</span></span><br><span class="line">                System.out.println(i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 退出操作 .......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细心观察代码的变化，应该会发现现在的代码每次在发送消息的时候，在消息末尾后加了换行分隔符。<strong>注意，使用 LineBasedFrameDecoder 时，换行分隔符必须加，否则接收消息端收不到消息，如果手写换行分割，要记得区分不同系统的适配</strong>。</p><p>经过多次测试 3W 条请求，没有再出现过粘包&#x2F;拆包情况，看最后一条数据数字是否相同便知。</p><p><img src="https://images.ytao.top/netty-end-10.png"></p><h2 id="DelimiterBasedFrameDecoder-自定义分隔符"><a href="#DelimiterBasedFrameDecoder-自定义分隔符" class="headerlink" title="DelimiterBasedFrameDecoder 自定义分隔符"></a>DelimiterBasedFrameDecoder 自定义分隔符</h2><p>自定义分隔符和换行分隔符差不多，只需将发送的数据后换行符换成你自己设定的分割符即可。</p><p>服务端和客户端均在 pipeline 添加 DelimiterBasedFrameDecoder:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定的分隔符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">DELIMITER</span> <span class="operator">=</span> <span class="string">&quot;$@$&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前数据2048个字节中没有分隔符，就会抛出异常，避免内存溢出。也可以自定义预检查当前读取的数据，自定义这里超过的规则</span></span><br><span class="line">pipeline.addLast(<span class="keyword">new</span> <span class="title class_">DelimiterBasedFrameDecoder</span>(</span><br><span class="line">        <span class="number">2048</span>, </span><br><span class="line">        Unpooled.wrappedBuffer(DELIMITER.getBytes())) <span class="comment">// 分割符缓冲对象</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="FixedLengthFrameDecoder-根据固定长度"><a href="#FixedLengthFrameDecoder-根据固定长度" class="headerlink" title="FixedLengthFrameDecoder 根据固定长度"></a>FixedLengthFrameDecoder 根据固定长度</h2><p>设定固定长度，进行数据传输，如果不达固定长度，使用空格补全。</p><p>服务端和客户端均在 pipeline 添加 FixedLengthFrameDecoder:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 100为指定的固定长度</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p>每次读取数据时都会按照 FixedLengthFrameDecoder 中设置的固定长度进行解码，如果出现粘包，那么会进行多次解码，如果出现拆包的情况，那么 FixedLengthFrameDecoder 会先缓存当前部分包的信息，当接收下一个包时，会与缓存的部分包进行拼接，知道满足规定的长度。</p><h2 id="动态指定长度"><a href="#动态指定长度" class="headerlink" title="动态指定长度"></a>动态指定长度</h2><p>动态指定长度就是说，每条消息的长度都是随着消息头进行指定，这里使用的编码器为 LengthFieldBasedFrameDecoder。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pipeline().addLast(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(</span><br><span class="line">        <span class="number">2048</span>, <span class="comment">// 帧的最大长度，即每个数据包最大限度</span></span><br><span class="line">        <span class="number">0</span>, <span class="comment">// 长度字段偏移量</span></span><br><span class="line">        <span class="number">4</span>, <span class="comment">// 长度字段所占的字节数</span></span><br><span class="line">        <span class="number">0</span>, <span class="comment">// 消息头的长度，可以为负数</span></span><br><span class="line">        <span class="number">4</span>) <span class="comment">// 需要忽略的字节数，从消息头开始，这里是指整个包</span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>发送消息时，创建自己的消息对象编码器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 byteBuf</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> getBuf();</span><br><span class="line"></span><br><span class="line"><span class="comment">// .....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置该条消息内容长度</span></span><br><span class="line">buf.writeInt(msg.length());</span><br><span class="line"><span class="comment">// 设置消息内容</span></span><br><span class="line">buf.writeBytes(msg.getBytes(<span class="string">&quot;UTF-8&quot;</span>));</span><br></pre></td></tr></table></figure><p>服务端读取的时候就直接读取即可，没其他特殊操作。</p><p>除了以上 Netty 提供的现成方案，还可以通过重写 MessageToByteEncoder 编码实现自定义协议。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>Netty 极大的为使用者提供了多种解决粘包&#x2F;拆包方案，并且可以很愉快的对多种消息进行自动解码，在使用过程中也极容易掌握和理解，很大程度上提升开发效率和稳定性。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://images.ytao.top/10.jpg&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP 是基于流传输的协议，请求数据在其传输的过程中是没有界限区分，所以我们在读取请求的时候，不一定能获取到一个完整的数据包。如果一个包较大时，可能会切分成多个包进行多次传输。同时，如果存在多个小包时，可能会将其整合成一个大包进行传输。这就是 TCP 协议的粘包&amp;#x2F;拆包概念。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Netty" scheme="https://ytao.top/categories/Netty/"/>
    
    
    <category term="Netty" scheme="https://ytao.top/tags/Netty/"/>
    
  </entry>
  
</feed>
